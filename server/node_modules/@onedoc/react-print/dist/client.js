"use strict";
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self1) {
    if (self1 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self1;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self1 = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self1, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _construct(Parent, args, Class) {
    if (_is_native_reflect_construct()) {
        _construct = Reflect.construct;
    } else {
        _construct = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of(instance, Class.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
    } else {
        _get = function get(target, property, receiver) {
            var base = _super_prop_base(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver || target);
            }
            return desc.value;
        };
    }
    return _get(target, property, receiver || target);
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _is_native_function(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _possible_constructor_return(self1, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self1);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _super_prop_base(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = _get_prototype_of(object);
        if (object === null) break;
    }
    return object;
}
function _tagged_template_literal(strings, raw) {
    if (!raw) {
        raw = strings.slice(0);
    }
    return Object.freeze(Object.defineProperties(strings, {
        raw: {
            value: Object.freeze(raw)
        }
    }));
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _wrap_native_super(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super = function wrapNativeSuper(Class) {
        if (Class === null || !_is_native_function(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _get_prototype_of(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _set_prototype_of(Wrapper, Class);
    };
    return _wrap_native_super(Class);
}
function _is_native_reflect_construct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _create_super(Derived) {
    var hasNativeReflectConstruct = _is_native_reflect_construct();
    return function _createSuperInternal() {
        var Super = _get_prototype_of(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _get_prototype_of(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possible_constructor_return(this, result);
    };
}
function _ts_generator(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
function _ts_values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function _templateObject() {
    var data = _tagged_template_literal([
        "\frac{1}{2}"
    ], [
        "\\frac{1}{2}"
    ]);
    _templateObject = function _templateObject() {
        return data;
    };
    return data;
}
function _templateObject1() {
    var data = _tagged_template_literal([
        void 0
    ], [
        "% \\f is defined as #1f(#2) using the macro\n\\f\\relax{x} = \\int_{-\\infty}^\\infty\n    \\f\\hat\\xi\\,e^{2 \\pi i \\xi x}\n    \\,d\\xi"
    ]);
    _templateObject1 = function _templateObject() {
        return data;
    };
    return data;
}
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = function(fn, res) {
    return function __init() {
        return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
    };
};
var __commonJS = function(cb, mod) {
    return function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
};
var __export = function(target, all) {
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = function(to, from, except, desc) {
    if (from && typeof from === "object" || typeof from === "function") {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            var _loop = function() {
                var key = _step.value;
                if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
                    get: function() {
                        return from[key];
                    },
                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
                });
            };
            for(var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    return to;
};
var __toESM = function(mod, isNodeMode, target) {
    return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod);
};
var __toCommonJS = function(mod) {
    return __copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
};
// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js": function(exports) {
        "use strict";
        init_shim();
        exports.byteLength = byteLength;
        exports.toByteArray = toByteArray;
        exports.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for(i2 = 0, len = code.length; i2 < len; ++i2){
            lookup[i2] = code[i2];
            revLookup[code.charCodeAt(i2)] = i2;
        }
        var i2;
        var len;
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
            var len2 = b64.length;
            if (len2 % 4 > 0) {
                throw new Error("Invalid string. Length must be a multiple of 4");
            }
            var validLen = b64.indexOf("=");
            if (validLen === -1) validLen = len2;
            var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
            return [
                validLen,
                placeHoldersLen
            ];
        }
        function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i3;
            for(i3 = 0; i3 < len2; i3 += 4){
                tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
                arr[curByte++] = tmp >> 16 & 255;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 2) {
                tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 1) {
                tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            return arr;
        }
        function tripletToBase64(num) {
            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for(var i3 = start; i3 < end; i3 += 3){
                tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
                output.push(tripletToBase64(tmp));
            }
            return output.join("");
        }
        function fromByteArray(uint8) {
            var tmp;
            var len2 = uint8.length;
            var extraBytes = len2 % 3;
            var parts = [];
            var maxChunkLength = 16383;
            for(var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength){
                parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
            }
            if (extraBytes === 1) {
                tmp = uint8[len2 - 1];
                parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
            } else if (extraBytes === 2) {
                tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
                parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
            }
            return parts.join("");
        }
    }
});
// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js": function(exports) {
        "use strict";
        init_shim();
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e2, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i2 = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i2];
            i2 += d;
            e2 = s & (1 << -nBits) - 1;
            s >>= -nBits;
            nBits += eLen;
            for(; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d, nBits -= 8){}
            m = e2 & (1 << -nBits) - 1;
            e2 >>= -nBits;
            nBits += mLen;
            for(; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8){}
            if (e2 === 0) {
                e2 = 1 - eBias;
            } else if (e2 === eMax) {
                return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
                m = m + Math.pow(2, mLen);
                e2 = e2 - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e2 - mLen);
        };
        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e2, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i2 = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e2 = eMax;
            } else {
                e2 = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e2)) < 1) {
                    e2--;
                    c *= 2;
                }
                if (e2 + eBias >= 1) {
                    value += rt / c;
                } else {
                    value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                    e2++;
                    c /= 2;
                }
                if (e2 + eBias >= eMax) {
                    m = 0;
                    e2 = eMax;
                } else if (e2 + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen);
                    e2 = e2 + eBias;
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e2 = 0;
                }
            }
            for(; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8){}
            e2 = e2 << mLen | m;
            eLen += mLen;
            for(; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d, e2 /= 256, eLen -= 8){}
            buffer[offset + i2 - d] |= s * 128;
        };
    }
});
// node_modules/node-stdlib-browser/node_modules/buffer/index.js
var require_buffer = __commonJS({
    "node_modules/node-stdlib-browser/node_modules/buffer/index.js": function(exports) {
        "use strict";
        init_shim();
        var base64 = require_base64_js();
        var ieee754 = require_ieee754();
        var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
        exports.Buffer = Buffer3;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;
        var K_MAX_LENGTH = 2147483647;
        exports.kMaxLength = K_MAX_LENGTH;
        Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
        if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
            console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
        }
        function typedArraySupport() {
            try {
                var arr = new Uint8Array(1);
                var proto = {
                    foo: function foo() {
                        return 42;
                    }
                };
                Object.setPrototypeOf(proto, Uint8Array.prototype);
                Object.setPrototypeOf(arr, proto);
                return arr.foo() === 42;
            } catch (e2) {
                return false;
            }
        }
        Object.defineProperty(Buffer3.prototype, "parent", {
            enumerable: true,
            get: function get() {
                if (!Buffer3.isBuffer(this)) return void 0;
                return this.buffer;
            }
        });
        Object.defineProperty(Buffer3.prototype, "offset", {
            enumerable: true,
            get: function get() {
                if (!Buffer3.isBuffer(this)) return void 0;
                return this.byteOffset;
            }
        });
        function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
                throw new RangeError('The value "' + length + '" is invalid for option "size"');
            }
            var buf = new Uint8Array(length);
            Object.setPrototypeOf(buf, Buffer3.prototype);
            return buf;
        }
        function Buffer3(arg, encodingOrOffset, length) {
            if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                    throw new TypeError('The "string" argument must be of type string. Received type number');
                }
                return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
        }
        Buffer3.poolSize = 8192;
        function from(value, encodingOrOffset, length) {
            if (typeof value === "string") {
                return fromString(value, encodingOrOffset);
            }
            if (ArrayBuffer.isView(value)) {
                return fromArrayView(value);
            }
            if (value == null) {
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + (typeof value === "undefined" ? "undefined" : _type_of(value)));
            }
            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                return fromArrayBuffer(value, encodingOrOffset, length);
            }
            if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
                return fromArrayBuffer(value, encodingOrOffset, length);
            }
            if (typeof value === "number") {
                throw new TypeError('The "value" argument must not be of type number. Received type number');
            }
            var valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value) {
                return Buffer3.from(valueOf, encodingOrOffset, length);
            }
            var b = fromObject(value);
            if (b) return b;
            if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
            }
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + (typeof value === "undefined" ? "undefined" : _type_of(value)));
        }
        Buffer3.from = function(value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
        };
        Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
        Object.setPrototypeOf(Buffer3, Uint8Array);
        function assertSize(size) {
            if (typeof size !== "number") {
                throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
                throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
        }
        function alloc(size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
                return createBuffer(size);
            }
            if (fill !== void 0) {
                return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
            }
            return createBuffer(size);
        }
        Buffer3.alloc = function(size, fill, encoding) {
            return alloc(size, fill, encoding);
        };
        function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
        }
        Buffer3.allocUnsafe = function(size) {
            return allocUnsafe(size);
        };
        Buffer3.allocUnsafeSlow = function(size) {
            return allocUnsafe(size);
        };
        function fromString(string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
            }
            if (!Buffer3.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
            }
            var length = byteLength(string, encoding) | 0;
            var buf = createBuffer(length);
            var actual = buf.write(string, encoding);
            if (actual !== length) {
                buf = buf.slice(0, actual);
            }
            return buf;
        }
        function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            var buf = createBuffer(length);
            for(var i2 = 0; i2 < length; i2 += 1){
                buf[i2] = array[i2] & 255;
            }
            return buf;
        }
        function fromArrayView(arrayView) {
            if (isInstance(arrayView, Uint8Array)) {
                var copy = new Uint8Array(arrayView);
                return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
            }
            return fromArrayLike(arrayView);
        }
        function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('"offset" is outside of buffer bounds');
            }
            if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('"length" is outside of buffer bounds');
            }
            var buf;
            if (byteOffset === void 0 && length === void 0) {
                buf = new Uint8Array(array);
            } else if (length === void 0) {
                buf = new Uint8Array(array, byteOffset);
            } else {
                buf = new Uint8Array(array, byteOffset, length);
            }
            Object.setPrototypeOf(buf, Buffer3.prototype);
            return buf;
        }
        function fromObject(obj) {
            if (Buffer3.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                var buf = createBuffer(len);
                if (buf.length === 0) {
                    return buf;
                }
                obj.copy(buf, 0, 0, len);
                return buf;
            }
            if (obj.length !== void 0) {
                if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                    return createBuffer(0);
                }
                return fromArrayLike(obj);
            }
            if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                return fromArrayLike(obj.data);
            }
        }
        function checked(length) {
            if (length >= K_MAX_LENGTH) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
            }
            return length | 0;
        }
        function SlowBuffer(length) {
            if (+length != length) {
                length = 0;
            }
            return Buffer3.alloc(+length);
        }
        Buffer3.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true && b !== Buffer3.prototype;
        };
        Buffer3.compare = function compare(a, b) {
            if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
            if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
            if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            }
            if (a === b) return 0;
            var x = a.length;
            var y = b.length;
            for(var i2 = 0, len = Math.min(x, y); i2 < len; ++i2){
                if (a[i2] !== b[i2]) {
                    x = a[i2];
                    y = b[i2];
                    break;
                }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
        };
        Buffer3.isEncoding = function isEncoding(encoding) {
            switch(String(encoding).toLowerCase()){
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return true;
                default:
                    return false;
            }
        };
        Buffer3.concat = function concat(list2, length) {
            if (!Array.isArray(list2)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list2.length === 0) {
                return Buffer3.alloc(0);
            }
            var i2;
            if (length === void 0) {
                length = 0;
                for(i2 = 0; i2 < list2.length; ++i2){
                    length += list2[i2].length;
                }
            }
            var buffer = Buffer3.allocUnsafe(length);
            var pos = 0;
            for(i2 = 0; i2 < list2.length; ++i2){
                var buf = list2[i2];
                if (isInstance(buf, Uint8Array)) {
                    if (pos + buf.length > buffer.length) {
                        Buffer3.from(buf).copy(buffer, pos);
                    } else {
                        Uint8Array.prototype.set.call(buffer, buf, pos);
                    }
                } else if (!Buffer3.isBuffer(buf)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                } else {
                    buf.copy(buffer, pos);
                }
                pos += buf.length;
            }
            return buffer;
        };
        function byteLength(string, encoding) {
            if (Buffer3.isBuffer(string)) {
                return string.length;
            }
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                return string.byteLength;
            }
            if (typeof string !== "string") {
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + (typeof string === "undefined" ? "undefined" : _type_of(string)));
            }
            var len = string.length;
            var mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0) return 0;
            var loweredCase = false;
            for(;;){
                switch(encoding){
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return len;
                    case "utf8":
                    case "utf-8":
                        return utf8ToBytes(string).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return len * 2;
                    case "hex":
                        return len >>> 1;
                    case "base64":
                        return base64ToBytes(string).length;
                    default:
                        if (loweredCase) {
                            return mustMatch ? -1 : utf8ToBytes(string).length;
                        }
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                }
            }
        }
        Buffer3.byteLength = byteLength;
        function slowToString(encoding, start, end) {
            var loweredCase = false;
            if (start === void 0 || start < 0) {
                start = 0;
            }
            if (start > this.length) {
                return "";
            }
            if (end === void 0 || end > this.length) {
                end = this.length;
            }
            if (end <= 0) {
                return "";
            }
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
                return "";
            }
            if (!encoding) encoding = "utf8";
            while(true){
                switch(encoding){
                    case "hex":
                        return hexSlice(this, start, end);
                    case "utf8":
                    case "utf-8":
                        return utf8Slice(this, start, end);
                    case "ascii":
                        return asciiSlice(this, start, end);
                    case "latin1":
                    case "binary":
                        return latin1Slice(this, start, end);
                    case "base64":
                        return base64Slice(this, start, end);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return utf16leSlice(this, start, end);
                    default:
                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                        encoding = (encoding + "").toLowerCase();
                        loweredCase = true;
                }
            }
        }
        Buffer3.prototype._isBuffer = true;
        function swap(b, n2, m) {
            var i2 = b[n2];
            b[n2] = b[m];
            b[m] = i2;
        }
        Buffer3.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            }
            for(var i2 = 0; i2 < len; i2 += 2){
                swap(this, i2, i2 + 1);
            }
            return this;
        };
        Buffer3.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            }
            for(var i2 = 0; i2 < len; i2 += 4){
                swap(this, i2, i2 + 3);
                swap(this, i2 + 1, i2 + 2);
            }
            return this;
        };
        Buffer3.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            }
            for(var i2 = 0; i2 < len; i2 += 8){
                swap(this, i2, i2 + 7);
                swap(this, i2 + 1, i2 + 6);
                swap(this, i2 + 2, i2 + 5);
                swap(this, i2 + 3, i2 + 4);
            }
            return this;
        };
        Buffer3.prototype.toString = function toString() {
            var length = this.length;
            if (length === 0) return "";
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
        };
        Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
        Buffer3.prototype.equals = function equals(b) {
            if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
            if (this === b) return true;
            return Buffer3.compare(this, b) === 0;
        };
        Buffer3.prototype.inspect = function inspect() {
            var str = "";
            var max = exports.INSPECT_MAX_BYTES;
            str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
            if (this.length > max) str += " ... ";
            return "<Buffer " + str + ">";
        };
        if (customInspectSymbol) {
            Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
        }
        Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (isInstance(target, Uint8Array)) {
                target = Buffer3.from(target, target.offset, target.byteLength);
            }
            if (!Buffer3.isBuffer(target)) {
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + (typeof target === "undefined" ? "undefined" : _type_of(target)));
            }
            if (start === void 0) {
                start = 0;
            }
            if (end === void 0) {
                end = target ? target.length : 0;
            }
            if (thisStart === void 0) {
                thisStart = 0;
            }
            if (thisEnd === void 0) {
                thisEnd = this.length;
            }
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError("out of range index");
            }
            if (thisStart >= thisEnd && start >= end) {
                return 0;
            }
            if (thisStart >= thisEnd) {
                return -1;
            }
            if (start >= end) {
                return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target) return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);
            for(var i2 = 0; i2 < len; ++i2){
                if (thisCopy[i2] !== targetCopy[i2]) {
                    x = thisCopy[i2];
                    y = targetCopy[i2];
                    break;
                }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
        };
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (buffer.length === 0) return -1;
            if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
            } else if (byteOffset > 2147483647) {
                byteOffset = 2147483647;
            } else if (byteOffset < -2147483648) {
                byteOffset = -2147483648;
            }
            byteOffset = +byteOffset;
            if (numberIsNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer.length - 1;
            }
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
                if (dir) return -1;
                else byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
                if (dir) byteOffset = 0;
                else return -1;
            }
            if (typeof val === "string") {
                val = Buffer3.from(val, encoding);
            }
            if (Buffer3.isBuffer(val)) {
                if (val.length === 0) {
                    return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === "number") {
                val = val & 255;
                if (typeof Uint8Array.prototype.indexOf === "function") {
                    if (dir) {
                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                    } else {
                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                    }
                }
                return arrayIndexOf(buffer, [
                    val
                ], byteOffset, encoding, dir);
            }
            throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;
            if (encoding !== void 0) {
                encoding = String(encoding).toLowerCase();
                if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                    if (arr.length < 2 || val.length < 2) {
                        return -1;
                    }
                    indexSize = 2;
                    arrLength /= 2;
                    valLength /= 2;
                    byteOffset /= 2;
                }
            }
            function read(buf, i3) {
                if (indexSize === 1) {
                    return buf[i3];
                } else {
                    return buf.readUInt16BE(i3 * indexSize);
                }
            }
            var i2;
            if (dir) {
                var foundIndex = -1;
                for(i2 = byteOffset; i2 < arrLength; i2++){
                    if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
                        if (foundIndex === -1) foundIndex = i2;
                        if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
                    } else {
                        if (foundIndex !== -1) i2 -= i2 - foundIndex;
                        foundIndex = -1;
                    }
                }
            } else {
                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                for(i2 = byteOffset; i2 >= 0; i2--){
                    var found = true;
                    for(var j = 0; j < valLength; j++){
                        if (read(arr, i2 + j) !== read(val, j)) {
                            found = false;
                            break;
                        }
                    }
                    if (found) return i2;
                }
            }
            return -1;
        }
        Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };
        Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };
        function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = Number(length);
                if (length > remaining) {
                    length = remaining;
                }
            }
            var strLen = string.length;
            if (length > strLen / 2) {
                length = strLen / 2;
            }
            for(var i2 = 0; i2 < length; ++i2){
                var parsed = parseInt(string.substr(i2 * 2, 2), 16);
                if (numberIsNaN(parsed)) return i2;
                buf[offset + i2] = parsed;
            }
            return i2;
        }
        function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
        }
        function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }
        Buffer3.prototype.write = function write(string, offset, length, encoding) {
            if (offset === void 0) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
            } else if (length === void 0 && typeof offset === "string") {
                encoding = offset;
                length = this.length;
                offset = 0;
            } else if (isFinite(offset)) {
                offset = offset >>> 0;
                if (isFinite(length)) {
                    length = length >>> 0;
                    if (encoding === void 0) encoding = "utf8";
                } else {
                    encoding = length;
                    length = void 0;
                }
            } else {
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            }
            var remaining = this.length - offset;
            if (length === void 0 || length > remaining) length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                throw new RangeError("Attempt to write outside buffer bounds");
            }
            if (!encoding) encoding = "utf8";
            var loweredCase = false;
            for(;;){
                switch(encoding){
                    case "hex":
                        return hexWrite(this, string, offset, length);
                    case "utf8":
                    case "utf-8":
                        return utf8Write(this, string, offset, length);
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return asciiWrite(this, string, offset, length);
                    case "base64":
                        return base64Write(this, string, offset, length);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return ucs2Write(this, string, offset, length);
                    default:
                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                }
            }
        };
        Buffer3.prototype.toJSON = function toJSON() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            };
        };
        function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
            } else {
                return base64.fromByteArray(buf.slice(start, end));
            }
        }
        function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i2 = start;
            while(i2 < end){
                var firstByte = buf[i2];
                var codePoint = null;
                var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                if (i2 + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint;
                    switch(bytesPerSequence){
                        case 1:
                            if (firstByte < 128) {
                                codePoint = firstByte;
                            }
                            break;
                        case 2:
                            secondByte = buf[i2 + 1];
                            if ((secondByte & 192) === 128) {
                                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                                if (tempCodePoint > 127) {
                                    codePoint = tempCodePoint;
                                }
                            }
                            break;
                        case 3:
                            secondByte = buf[i2 + 1];
                            thirdByte = buf[i2 + 2];
                            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                                    codePoint = tempCodePoint;
                                }
                            }
                            break;
                        case 4:
                            secondByte = buf[i2 + 1];
                            thirdByte = buf[i2 + 2];
                            fourthByte = buf[i2 + 3];
                            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                                    codePoint = tempCodePoint;
                                }
                            }
                    }
                }
                if (codePoint === null) {
                    codePoint = 65533;
                    bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                    codePoint -= 65536;
                    res.push(codePoint >>> 10 & 1023 | 55296);
                    codePoint = 56320 | codePoint & 1023;
                }
                res.push(codePoint);
                i2 += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
        }
        var MAX_ARGUMENTS_LENGTH = 4096;
        function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
            }
            var res = "";
            var i2 = 0;
            while(i2 < len){
                res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
            }
            return res;
        }
        function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for(var i2 = start; i2 < end; ++i2){
                ret += String.fromCharCode(buf[i2] & 127);
            }
            return ret;
        }
        function latin1Slice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for(var i2 = start; i2 < end; ++i2){
                ret += String.fromCharCode(buf[i2]);
            }
            return ret;
        }
        function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            var out = "";
            for(var i2 = start; i2 < end; ++i2){
                out += hexSliceLookupTable[buf[i2]];
            }
            return out;
        }
        function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for(var i2 = 0; i2 < bytes.length - 1; i2 += 2){
                res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
            }
            return res;
        }
        Buffer3.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === void 0 ? len : ~~end;
            if (start < 0) {
                start += len;
                if (start < 0) start = 0;
            } else if (start > len) {
                start = len;
            }
            if (end < 0) {
                end += len;
                if (end < 0) end = 0;
            } else if (end > len) {
                end = len;
            }
            if (end < start) end = start;
            var newBuf = this.subarray(start, end);
            Object.setPrototypeOf(newBuf, Buffer3.prototype);
            return newBuf;
        };
        function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
            if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i2 = 0;
            while(++i2 < byteLength2 && (mul *= 256)){
                val += this[offset + i2] * mul;
            }
            return val;
        };
        Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
                checkOffset(offset, byteLength2, this.length);
            }
            var val = this[offset + --byteLength2];
            var mul = 1;
            while(byteLength2 > 0 && (mul *= 256)){
                val += this[offset + --byteLength2] * mul;
            }
            return val;
        };
        Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
        };
        Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
        };
        Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
        };
        Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
        };
        Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i2 = 0;
            while(++i2 < byteLength2 && (mul *= 256)){
                val += this[offset + i2] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
            return val;
        };
        Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) checkOffset(offset, byteLength2, this.length);
            var i2 = byteLength2;
            var mul = 1;
            var val = this[offset + --i2];
            while(i2 > 0 && (mul *= 256)){
                val += this[offset + --i2] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
            return val;
        };
        Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128)) return this[offset];
            return (255 - this[offset] + 1) * -1;
        };
        Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
        };
        Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
        };
        Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
        };
        Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
        };
        Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
        };
        Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
        }
        Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var mul = 1;
            var i2 = 0;
            this[offset] = value & 255;
            while(++i2 < byteLength2 && (mul *= 256)){
                this[offset + i2] = value / mul & 255;
            }
            return offset + byteLength2;
        };
        Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var i2 = byteLength2 - 1;
            var mul = 1;
            this[offset + i2] = value & 255;
            while(--i2 >= 0 && (mul *= 256)){
                this[offset + i2] = value / mul & 255;
            }
            return offset + byteLength2;
        };
        Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
            this[offset] = value & 255;
            return offset + 1;
        };
        Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
        };
        Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
        };
        Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 255;
            return offset + 4;
        };
        Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
        };
        Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i2 = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 255;
            while(++i2 < byteLength2 && (mul *= 256)){
                if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
                    sub = 1;
                }
                this[offset + i2] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
        };
        Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength2 - 1);
                checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i2 = byteLength2 - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i2] = value & 255;
            while(--i2 >= 0 && (mul *= 256)){
                if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
                    sub = 1;
                }
                this[offset + i2] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
        };
        Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
            if (value < 0) value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
        };
        Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
        };
        Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
        };
        Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
            return offset + 4;
        };
        Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0) value = 4294967295 + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
        };
        function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
            if (offset < 0) throw new RangeError("Index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
        }
        Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
        }
        Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
            if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;
            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0;
            if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
            if (end < 0) throw new RangeError("sourceEnd out of bounds");
            if (end > this.length) end = this.length;
            if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
            }
            var len = end - start;
            if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                this.copyWithin(targetStart, start, end);
            } else {
                Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
            }
            return len;
        };
        Buffer3.prototype.fill = function fill(val, start, end, encoding) {
            if (typeof val === "string") {
                if (typeof start === "string") {
                    encoding = start;
                    start = 0;
                    end = this.length;
                } else if (typeof end === "string") {
                    encoding = end;
                    end = this.length;
                }
                if (encoding !== void 0 && typeof encoding !== "string") {
                    throw new TypeError("encoding must be a string");
                }
                if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                }
                if (val.length === 1) {
                    var code = val.charCodeAt(0);
                    if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                        val = code;
                    }
                }
            } else if (typeof val === "number") {
                val = val & 255;
            } else if (typeof val === "boolean") {
                val = Number(val);
            }
            if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
            }
            if (end <= start) {
                return this;
            }
            start = start >>> 0;
            end = end === void 0 ? this.length : end >>> 0;
            if (!val) val = 0;
            var i2;
            if (typeof val === "number") {
                for(i2 = start; i2 < end; ++i2){
                    this[i2] = val;
                }
            } else {
                var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
                var len = bytes.length;
                if (len === 0) {
                    throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                }
                for(i2 = 0; i2 < end - start; ++i2){
                    this[i2 + start] = bytes[i2 % len];
                }
            }
            return this;
        };
        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
        function base64clean(str) {
            str = str.split("=")[0];
            str = str.trim().replace(INVALID_BASE64_RE, "");
            if (str.length < 2) return "";
            while(str.length % 4 !== 0){
                str = str + "=";
            }
            return str;
        }
        function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for(var i2 = 0; i2 < length; ++i2){
                codePoint = string.charCodeAt(i2);
                if (codePoint > 55295 && codePoint < 57344) {
                    if (!leadSurrogate) {
                        if (codePoint > 56319) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        } else if (i2 + 1 === length) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        }
                        leadSurrogate = codePoint;
                        continue;
                    }
                    if (codePoint < 56320) {
                        if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        leadSurrogate = codePoint;
                        continue;
                    }
                    codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                } else if (leadSurrogate) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                }
                leadSurrogate = null;
                if (codePoint < 128) {
                    if ((units -= 1) < 0) break;
                    bytes.push(codePoint);
                } else if (codePoint < 2048) {
                    if ((units -= 2) < 0) break;
                    bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                } else if (codePoint < 65536) {
                    if ((units -= 3) < 0) break;
                    bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else if (codePoint < 1114112) {
                    if ((units -= 4) < 0) break;
                    bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else {
                    throw new Error("Invalid code point");
                }
            }
            return bytes;
        }
        function asciiToBytes(str) {
            var byteArray = [];
            for(var i2 = 0; i2 < str.length; ++i2){
                byteArray.push(str.charCodeAt(i2) & 255);
            }
            return byteArray;
        }
        function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for(var i2 = 0; i2 < str.length; ++i2){
                if ((units -= 2) < 0) break;
                c = str.charCodeAt(i2);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
            }
            return byteArray;
        }
        function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
            for(var i2 = 0; i2 < length; ++i2){
                if (i2 + offset >= dst.length || i2 >= src.length) break;
                dst[i2 + offset] = src[i2];
            }
            return i2;
        }
        function isInstance(obj, type) {
            return _instanceof(obj, type) || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
        }
        function numberIsNaN(obj) {
            return obj !== obj;
        }
        var hexSliceLookupTable = function() {
            var alphabet = "0123456789abcdef";
            var table = new Array(256);
            for(var i2 = 0; i2 < 16; ++i2){
                var i16 = i2 * 16;
                for(var j = 0; j < 16; ++j){
                    table[i16 + j] = alphabet[i2] + alphabet[j];
                }
            }
            return table;
        }();
    }
});
// node_modules/process/browser.js
var require_browser = __commonJS({
    "node_modules/process/browser.js": function(exports, module2) {
        "use strict";
        init_shim();
        var process2 = module2.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        (function() {
            try {
                if (typeof setTimeout === "function") {
                    cachedSetTimeout = setTimeout;
                } else {
                    cachedSetTimeout = defaultSetTimout;
                }
            } catch (e2) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                if (typeof clearTimeout === "function") {
                    cachedClearTimeout = clearTimeout;
                } else {
                    cachedClearTimeout = defaultClearTimeout;
                }
            } catch (e2) {
                cachedClearTimeout = defaultClearTimeout;
            }
        })();
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
                return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
            }
            try {
                return cachedSetTimeout(fun, 0);
            } catch (e2) {
                try {
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e3) {
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
                return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
            }
            try {
                return cachedClearTimeout(marker);
            } catch (e2) {
                try {
                    return cachedClearTimeout.call(null, marker);
                } catch (e3) {
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
            if (!draining || !currentQueue) {
                return;
            }
            draining = false;
            if (currentQueue.length) {
                queue = currentQueue.concat(queue);
            } else {
                queueIndex = -1;
            }
            if (queue.length) {
                drainQueue();
            }
        }
        function drainQueue() {
            if (draining) {
                return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while(len){
                currentQueue = queue;
                queue = [];
                while(++queueIndex < len){
                    if (currentQueue) {
                        currentQueue[queueIndex].run();
                    }
                }
                queueIndex = -1;
                len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
        }
        process2.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for(var i2 = 1; i2 < arguments.length; i2++){
                    args[i2 - 1] = arguments[i2];
                }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
            }
        };
        function Item(fun, array) {
            this.fun = fun;
            this.array = array;
        }
        Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        };
        process2.title = "browser";
        process2.browser = true;
        process2.env = {};
        process2.argv = [];
        process2.version = "";
        process2.versions = {};
        function noop() {}
        process2.on = noop;
        process2.addListener = noop;
        process2.once = noop;
        process2.off = noop;
        process2.removeListener = noop;
        process2.removeAllListeners = noop;
        process2.emit = noop;
        process2.prependListener = noop;
        process2.prependOnceListener = noop;
        process2.listeners = function(name) {
            return [];
        };
        process2.binding = function(name) {
            throw new Error("process.binding is not supported");
        };
        process2.cwd = function() {
            return "/";
        };
        process2.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        };
        process2.umask = function() {
            return 0;
        };
    }
});
// node_modules/node-stdlib-browser/helpers/esbuild/shim.js
var import_buffer, import_process, _globalThis, _global;
var init_shim = __esm({
    "node_modules/node-stdlib-browser/helpers/esbuild/shim.js": function() {
        "use strict";
        import_buffer = __toESM(require_buffer());
        import_process = __toESM(require_browser());
        _globalThis = function(Object2) {
            function get() {
                var _global3 = this || self;
                delete Object2.prototype.__magic__;
                return _global3;
            }
            if (typeof globalThis === "object") {
                return globalThis;
            }
            if (this) {
                return get();
            } else {
                Object2.defineProperty(Object2.prototype, "__magic__", {
                    configurable: true,
                    get: get
                });
                var _global2 = __magic__;
                return _global2;
            }
        }(Object);
        _global = _globalThis;
    }
});
// node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
    "node_modules/picocolors/picocolors.browser.js": function(exports, module2) {
        "use strict";
        init_shim();
        var x = String;
        var create = function create() {
            return {
                isColorSupported: false,
                reset: x,
                bold: x,
                dim: x,
                italic: x,
                underline: x,
                inverse: x,
                hidden: x,
                strikethrough: x,
                black: x,
                red: x,
                green: x,
                yellow: x,
                blue: x,
                magenta: x,
                cyan: x,
                white: x,
                gray: x,
                bgBlack: x,
                bgRed: x,
                bgGreen: x,
                bgYellow: x,
                bgBlue: x,
                bgMagenta: x,
                bgCyan: x,
                bgWhite: x
            };
        };
        module2.exports = create();
        module2.exports.createColors = create;
    }
});
// (disabled):node_modules/postcss/lib/terminal-highlight
var require_terminal_highlight = __commonJS({
    "(disabled):node_modules/postcss/lib/terminal-highlight": function() {
        "use strict";
        init_shim();
    }
});
// node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS({
    "node_modules/postcss/lib/css-syntax-error.js": function(exports, module2) {
        "use strict";
        init_shim();
        var pico = require_picocolors_browser();
        var terminalHighlight = require_terminal_highlight();
        var CssSyntaxError2 = /*#__PURE__*/ function(Error1) {
            _inherits(_CssSyntaxError, Error1);
            var _super = _create_super(_CssSyntaxError);
            function _CssSyntaxError(message, line, column, source, file, plugin2) {
                _class_call_check(this, _CssSyntaxError);
                var _this;
                _this = _super.call(this, message);
                _this.name = "CssSyntaxError";
                _this.reason = message;
                if (file) {
                    _this.file = file;
                }
                if (source) {
                    _this.source = source;
                }
                if (plugin2) {
                    _this.plugin = plugin2;
                }
                if (typeof line !== "undefined" && typeof column !== "undefined") {
                    if (typeof line === "number") {
                        _this.line = line;
                        _this.column = column;
                    } else {
                        _this.line = line.line;
                        _this.column = line.column;
                        _this.endLine = column.line;
                        _this.endColumn = column.column;
                    }
                }
                _this.setMessage();
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(_assert_this_initialized(_this), _CssSyntaxError);
                }
                return _this;
            }
            _create_class(_CssSyntaxError, [
                {
                    key: "setMessage",
                    value: function setMessage() {
                        this.message = this.plugin ? this.plugin + ": " : "";
                        this.message += this.file ? this.file : "<css input>";
                        if (typeof this.line !== "undefined") {
                            this.message += ":" + this.line + ":" + this.column;
                        }
                        this.message += ": " + this.reason;
                    }
                },
                {
                    key: "showSourceCode",
                    value: function showSourceCode(color) {
                        var _this = this;
                        if (!this.source) return "";
                        var css = this.source;
                        if (color == null) color = pico.isColorSupported;
                        if (terminalHighlight) {
                            if (color) css = terminalHighlight(css);
                        }
                        var lines = css.split(/\r?\n/);
                        var start = Math.max(this.line - 3, 0);
                        var end = Math.min(this.line + 2, lines.length);
                        var maxWidth = String(end).length;
                        var mark, aside;
                        if (color) {
                            var _pico_createColors = pico.createColors(true), bold = _pico_createColors.bold, gray = _pico_createColors.gray, red = _pico_createColors.red;
                            mark = function(text) {
                                return bold(red(text));
                            };
                            aside = function(text) {
                                return gray(text);
                            };
                        } else {
                            mark = aside = function(str) {
                                return str;
                            };
                        }
                        return lines.slice(start, end).map(function(line, index) {
                            var number = start + 1 + index;
                            var gutter = " " + (" " + number).slice(-maxWidth) + " | ";
                            if (number === _this.line) {
                                var spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, _this.column - 1).replace(/[^\t]/g, " ");
                                return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
                            }
                            return " " + aside(gutter) + line;
                        }).join("\n");
                    }
                },
                {
                    key: "toString",
                    value: function toString() {
                        var code = this.showSourceCode();
                        if (code) {
                            code = "\n\n" + code + "\n";
                        }
                        return this.name + ": " + this.message + code;
                    }
                }
            ]);
            return _CssSyntaxError;
        }(_wrap_native_super(Error));
        module2.exports = CssSyntaxError2;
        CssSyntaxError2.default = CssSyntaxError2;
    }
});
// node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS({
    "node_modules/postcss/lib/symbols.js": function(exports, module2) {
        "use strict";
        init_shim();
        module2.exports.isClean = Symbol("isClean");
        module2.exports.my = Symbol("my");
    }
});
// node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS({
    "node_modules/postcss/lib/stringifier.js": function(exports, module2) {
        "use strict";
        init_shim();
        var DEFAULT_RAW = {
            after: "\n",
            beforeClose: "\n",
            beforeComment: "\n",
            beforeDecl: "\n",
            beforeOpen: " ",
            beforeRule: "\n",
            colon: ": ",
            commentLeft: " ",
            commentRight: " ",
            emptyBody: "",
            indent: "    ",
            semicolon: false
        };
        function capitalize(str) {
            return str[0].toUpperCase() + str.slice(1);
        }
        var Stringifier = /*#__PURE__*/ function() {
            function Stringifier(builder) {
                _class_call_check(this, Stringifier);
                this.builder = builder;
            }
            _create_class(Stringifier, [
                {
                    key: "atrule",
                    value: function atrule(node, semicolon) {
                        var name = "@" + node.name;
                        var params = node.params ? this.rawValue(node, "params") : "";
                        if (typeof node.raws.afterName !== "undefined") {
                            name += node.raws.afterName;
                        } else if (params) {
                            name += " ";
                        }
                        if (node.nodes) {
                            this.block(node, name + params);
                        } else {
                            var end = (node.raws.between || "") + (semicolon ? ";" : "");
                            this.builder(name + params + end, node);
                        }
                    }
                },
                {
                    key: "beforeAfter",
                    value: function beforeAfter(node, detect) {
                        var value;
                        if (node.type === "decl") {
                            value = this.raw(node, null, "beforeDecl");
                        } else if (node.type === "comment") {
                            value = this.raw(node, null, "beforeComment");
                        } else if (detect === "before") {
                            value = this.raw(node, null, "beforeRule");
                        } else {
                            value = this.raw(node, null, "beforeClose");
                        }
                        var buf = node.parent;
                        var depth = 0;
                        while(buf && buf.type !== "root"){
                            depth += 1;
                            buf = buf.parent;
                        }
                        if (value.includes("\n")) {
                            var indent = this.raw(node, null, "indent");
                            if (indent.length) {
                                for(var step = 0; step < depth; step++)value += indent;
                            }
                        }
                        return value;
                    }
                },
                {
                    key: "block",
                    value: function block(node, start) {
                        var between = this.raw(node, "between", "beforeOpen");
                        this.builder(start + between + "{", node, "start");
                        var after;
                        if (node.nodes && node.nodes.length) {
                            this.body(node);
                            after = this.raw(node, "after");
                        } else {
                            after = this.raw(node, "after", "emptyBody");
                        }
                        if (after) this.builder(after);
                        this.builder("}", node, "end");
                    }
                },
                {
                    key: "body",
                    value: function body(node) {
                        var last = node.nodes.length - 1;
                        while(last > 0){
                            if (node.nodes[last].type !== "comment") break;
                            last -= 1;
                        }
                        var semicolon = this.raw(node, "semicolon");
                        for(var i2 = 0; i2 < node.nodes.length; i2++){
                            var child = node.nodes[i2];
                            var before = this.raw(child, "before");
                            if (before) this.builder(before);
                            this.stringify(child, last !== i2 || semicolon);
                        }
                    }
                },
                {
                    key: "comment",
                    value: function comment(node) {
                        var left = this.raw(node, "left", "commentLeft");
                        var right = this.raw(node, "right", "commentRight");
                        this.builder("/*" + left + node.text + right + "*/", node);
                    }
                },
                {
                    key: "decl",
                    value: function decl(node, semicolon) {
                        var between = this.raw(node, "between", "colon");
                        var string = node.prop + between + this.rawValue(node, "value");
                        if (node.important) {
                            string += node.raws.important || " !important";
                        }
                        if (semicolon) string += ";";
                        this.builder(string, node);
                    }
                },
                {
                    key: "document",
                    value: function document(node) {
                        this.body(node);
                    }
                },
                {
                    key: "raw",
                    value: function raw(node, own, detect) {
                        var value;
                        if (!detect) detect = own;
                        if (own) {
                            value = node.raws[own];
                            if (typeof value !== "undefined") return value;
                        }
                        var parent = node.parent;
                        if (detect === "before") {
                            if (!parent || parent.type === "root" && parent.first === node) {
                                return "";
                            }
                            if (parent && parent.type === "document") {
                                return "";
                            }
                        }
                        if (!parent) return DEFAULT_RAW[detect];
                        var root2 = node.root();
                        if (!root2.rawCache) root2.rawCache = {};
                        if (typeof root2.rawCache[detect] !== "undefined") {
                            return root2.rawCache[detect];
                        }
                        if (detect === "before" || detect === "after") {
                            return this.beforeAfter(node, detect);
                        } else {
                            var method = "raw" + capitalize(detect);
                            if (this[method]) {
                                value = this[method](root2, node);
                            } else {
                                root2.walk(function(i2) {
                                    value = i2.raws[own];
                                    if (typeof value !== "undefined") return false;
                                });
                            }
                        }
                        if (typeof value === "undefined") value = DEFAULT_RAW[detect];
                        root2.rawCache[detect] = value;
                        return value;
                    }
                },
                {
                    key: "rawBeforeClose",
                    value: function rawBeforeClose(root2) {
                        var value;
                        root2.walk(function(i2) {
                            if (i2.nodes && i2.nodes.length > 0) {
                                if (typeof i2.raws.after !== "undefined") {
                                    value = i2.raws.after;
                                    if (value.includes("\n")) {
                                        value = value.replace(/[^\n]+$/, "");
                                    }
                                    return false;
                                }
                            }
                        });
                        if (value) value = value.replace(/\S/g, "");
                        return value;
                    }
                },
                {
                    key: "rawBeforeComment",
                    value: function rawBeforeComment(root2, node) {
                        var value;
                        root2.walkComments(function(i2) {
                            if (typeof i2.raws.before !== "undefined") {
                                value = i2.raws.before;
                                if (value.includes("\n")) {
                                    value = value.replace(/[^\n]+$/, "");
                                }
                                return false;
                            }
                        });
                        if (typeof value === "undefined") {
                            value = this.raw(node, null, "beforeDecl");
                        } else if (value) {
                            value = value.replace(/\S/g, "");
                        }
                        return value;
                    }
                },
                {
                    key: "rawBeforeDecl",
                    value: function rawBeforeDecl(root2, node) {
                        var value;
                        root2.walkDecls(function(i2) {
                            if (typeof i2.raws.before !== "undefined") {
                                value = i2.raws.before;
                                if (value.includes("\n")) {
                                    value = value.replace(/[^\n]+$/, "");
                                }
                                return false;
                            }
                        });
                        if (typeof value === "undefined") {
                            value = this.raw(node, null, "beforeRule");
                        } else if (value) {
                            value = value.replace(/\S/g, "");
                        }
                        return value;
                    }
                },
                {
                    key: "rawBeforeOpen",
                    value: function rawBeforeOpen(root2) {
                        var value;
                        root2.walk(function(i2) {
                            if (i2.type !== "decl") {
                                value = i2.raws.between;
                                if (typeof value !== "undefined") return false;
                            }
                        });
                        return value;
                    }
                },
                {
                    key: "rawBeforeRule",
                    value: function rawBeforeRule(root2) {
                        var value;
                        root2.walk(function(i2) {
                            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
                                if (typeof i2.raws.before !== "undefined") {
                                    value = i2.raws.before;
                                    if (value.includes("\n")) {
                                        value = value.replace(/[^\n]+$/, "");
                                    }
                                    return false;
                                }
                            }
                        });
                        if (value) value = value.replace(/\S/g, "");
                        return value;
                    }
                },
                {
                    key: "rawColon",
                    value: function rawColon(root2) {
                        var value;
                        root2.walkDecls(function(i2) {
                            if (typeof i2.raws.between !== "undefined") {
                                value = i2.raws.between.replace(/[^\s:]/g, "");
                                return false;
                            }
                        });
                        return value;
                    }
                },
                {
                    key: "rawEmptyBody",
                    value: function rawEmptyBody(root2) {
                        var value;
                        root2.walk(function(i2) {
                            if (i2.nodes && i2.nodes.length === 0) {
                                value = i2.raws.after;
                                if (typeof value !== "undefined") return false;
                            }
                        });
                        return value;
                    }
                },
                {
                    key: "rawIndent",
                    value: function rawIndent(root2) {
                        if (root2.raws.indent) return root2.raws.indent;
                        var value;
                        root2.walk(function(i2) {
                            var p = i2.parent;
                            if (p && p !== root2 && p.parent && p.parent === root2) {
                                if (typeof i2.raws.before !== "undefined") {
                                    var parts = i2.raws.before.split("\n");
                                    value = parts[parts.length - 1];
                                    value = value.replace(/\S/g, "");
                                    return false;
                                }
                            }
                        });
                        return value;
                    }
                },
                {
                    key: "rawSemicolon",
                    value: function rawSemicolon(root2) {
                        var value;
                        root2.walk(function(i2) {
                            if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
                                value = i2.raws.semicolon;
                                if (typeof value !== "undefined") return false;
                            }
                        });
                        return value;
                    }
                },
                {
                    key: "rawValue",
                    value: function rawValue(node, prop) {
                        var value = node[prop];
                        var raw = node.raws[prop];
                        if (raw && raw.value === value) {
                            return raw.raw;
                        }
                        return value;
                    }
                },
                {
                    key: "root",
                    value: function root(node) {
                        this.body(node);
                        if (node.raws.after) this.builder(node.raws.after);
                    }
                },
                {
                    key: "rule",
                    value: function rule(node) {
                        this.block(node, this.rawValue(node, "selector"));
                        if (node.raws.ownSemicolon) {
                            this.builder(node.raws.ownSemicolon, node, "end");
                        }
                    }
                },
                {
                    key: "stringify",
                    value: function stringify(node, semicolon) {
                        if (!this[node.type]) {
                            throw new Error("Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier.");
                        }
                        this[node.type](node, semicolon);
                    }
                }
            ]);
            return Stringifier;
        }();
        module2.exports = Stringifier;
        Stringifier.default = Stringifier;
    }
});
// node_modules/postcss/lib/stringify.js
var require_stringify = __commonJS({
    "node_modules/postcss/lib/stringify.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Stringifier = require_stringifier();
        function stringify4(node, builder) {
            var str = new Stringifier(builder);
            str.stringify(node);
        }
        module2.exports = stringify4;
        stringify4.default = stringify4;
    }
});
// node_modules/postcss/lib/node.js
var require_node = __commonJS({
    "node_modules/postcss/lib/node.js": function(exports, module2) {
        "use strict";
        init_shim();
        var _require_symbols = require_symbols(), isClean = _require_symbols.isClean, my = _require_symbols.my;
        var CssSyntaxError2 = require_css_syntax_error();
        var Stringifier = require_stringifier();
        var stringify4 = require_stringify();
        function cloneNode(obj, parent) {
            var cloned = new obj.constructor();
            for(var i2 in obj){
                if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
                    continue;
                }
                if (i2 === "proxyCache") continue;
                var value = obj[i2];
                var type = typeof value === "undefined" ? "undefined" : _type_of(value);
                if (i2 === "parent" && type === "object") {
                    if (parent) cloned[i2] = parent;
                } else if (i2 === "source") {
                    cloned[i2] = value;
                } else if (Array.isArray(value)) {
                    cloned[i2] = value.map(function(j) {
                        return cloneNode(j, cloned);
                    });
                } else {
                    if (type === "object" && value !== null) value = cloneNode(value);
                    cloned[i2] = value;
                }
            }
            return cloned;
        }
        var Node2 = /*#__PURE__*/ function() {
            function Node2() {
                var defaults = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                _class_call_check(this, Node2);
                this.raws = {};
                this[isClean] = false;
                this[my] = true;
                for(var name in defaults){
                    if (name === "nodes") {
                        this.nodes = [];
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = defaults[name][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var node = _step.value;
                                if (typeof node.clone === "function") {
                                    this.append(node.clone());
                                } else {
                                    this.append(node);
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    } else {
                        this[name] = defaults[name];
                    }
                }
            }
            _create_class(Node2, [
                {
                    key: "addToError",
                    value: function addToError(error) {
                        error.postcssNode = this;
                        if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
                            var s = this.source;
                            error.stack = error.stack.replace(/\n\s{4}at /, "$&".concat(s.input.from, ":").concat(s.start.line, ":").concat(s.start.column, "$&"));
                        }
                        return error;
                    }
                },
                {
                    key: "after",
                    value: function after(add) {
                        this.parent.insertAfter(this, add);
                        return this;
                    }
                },
                {
                    key: "assign",
                    value: function assign() {
                        var overrides = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                        for(var name in overrides){
                            this[name] = overrides[name];
                        }
                        return this;
                    }
                },
                {
                    key: "before",
                    value: function before(add) {
                        this.parent.insertBefore(this, add);
                        return this;
                    }
                },
                {
                    key: "cleanRaws",
                    value: function cleanRaws(keepBetween) {
                        delete this.raws.before;
                        delete this.raws.after;
                        if (!keepBetween) delete this.raws.between;
                    }
                },
                {
                    key: "clone",
                    value: function clone() {
                        var overrides = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                        var cloned = cloneNode(this);
                        for(var name in overrides){
                            cloned[name] = overrides[name];
                        }
                        return cloned;
                    }
                },
                {
                    key: "cloneAfter",
                    value: function cloneAfter() {
                        var overrides = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                        var cloned = this.clone(overrides);
                        this.parent.insertAfter(this, cloned);
                        return cloned;
                    }
                },
                {
                    key: "cloneBefore",
                    value: function cloneBefore() {
                        var overrides = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                        var cloned = this.clone(overrides);
                        this.parent.insertBefore(this, cloned);
                        return cloned;
                    }
                },
                {
                    key: "error",
                    value: function error(message) {
                        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                        if (this.source) {
                            var _this_rangeBy = this.rangeBy(opts), end = _this_rangeBy.end, start = _this_rangeBy.start;
                            return this.source.input.error(message, {
                                column: start.column,
                                line: start.line
                            }, {
                                column: end.column,
                                line: end.line
                            }, opts);
                        }
                        return new CssSyntaxError2(message);
                    }
                },
                {
                    key: "getProxyProcessor",
                    value: function getProxyProcessor() {
                        return {
                            get: function get(node, prop) {
                                if (prop === "proxyOf") {
                                    return node;
                                } else if (prop === "root") {
                                    return function() {
                                        return node.root().toProxy();
                                    };
                                } else {
                                    return node[prop];
                                }
                            },
                            set: function set(node, prop, value) {
                                if (node[prop] === value) return true;
                                node[prop] = value;
                                if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */ prop === "text") {
                                    node.markDirty();
                                }
                                return true;
                            }
                        };
                    }
                },
                {
                    key: "markDirty",
                    value: function markDirty() {
                        if (this[isClean]) {
                            this[isClean] = false;
                            var next = this;
                            while(next = next.parent){
                                next[isClean] = false;
                            }
                        }
                    }
                },
                {
                    key: "next",
                    value: function next() {
                        if (!this.parent) return void 0;
                        var index = this.parent.index(this);
                        return this.parent.nodes[index + 1];
                    }
                },
                {
                    key: "positionBy",
                    value: function positionBy(opts, stringRepresentation) {
                        var pos = this.source.start;
                        if (opts.index) {
                            pos = this.positionInside(opts.index, stringRepresentation);
                        } else if (opts.word) {
                            stringRepresentation = this.toString();
                            var index = stringRepresentation.indexOf(opts.word);
                            if (index !== -1) pos = this.positionInside(index, stringRepresentation);
                        }
                        return pos;
                    }
                },
                {
                    key: "positionInside",
                    value: function positionInside(index, stringRepresentation) {
                        var string = stringRepresentation || this.toString();
                        var column = this.source.start.column;
                        var line = this.source.start.line;
                        for(var i2 = 0; i2 < index; i2++){
                            if (string[i2] === "\n") {
                                column = 1;
                                line += 1;
                            } else {
                                column += 1;
                            }
                        }
                        return {
                            column: column,
                            line: line
                        };
                    }
                },
                {
                    key: "prev",
                    value: function prev() {
                        if (!this.parent) return void 0;
                        var index = this.parent.index(this);
                        return this.parent.nodes[index - 1];
                    }
                },
                {
                    key: "rangeBy",
                    value: function rangeBy(opts) {
                        var start = {
                            column: this.source.start.column,
                            line: this.source.start.line
                        };
                        var end = this.source.end ? {
                            column: this.source.end.column + 1,
                            line: this.source.end.line
                        } : {
                            column: start.column + 1,
                            line: start.line
                        };
                        if (opts.word) {
                            var stringRepresentation = this.toString();
                            var index = stringRepresentation.indexOf(opts.word);
                            if (index !== -1) {
                                start = this.positionInside(index, stringRepresentation);
                                end = this.positionInside(index + opts.word.length, stringRepresentation);
                            }
                        } else {
                            if (opts.start) {
                                start = {
                                    column: opts.start.column,
                                    line: opts.start.line
                                };
                            } else if (opts.index) {
                                start = this.positionInside(opts.index);
                            }
                            if (opts.end) {
                                end = {
                                    column: opts.end.column,
                                    line: opts.end.line
                                };
                            } else if (opts.endIndex) {
                                end = this.positionInside(opts.endIndex);
                            } else if (opts.index) {
                                end = this.positionInside(opts.index + 1);
                            }
                        }
                        if (end.line < start.line || end.line === start.line && end.column <= start.column) {
                            end = {
                                column: start.column + 1,
                                line: start.line
                            };
                        }
                        return {
                            end: end,
                            start: start
                        };
                    }
                },
                {
                    key: "raw",
                    value: function raw(prop, defaultType) {
                        var str = new Stringifier();
                        return str.raw(this, prop, defaultType);
                    }
                },
                {
                    key: "remove",
                    value: function remove() {
                        if (this.parent) {
                            this.parent.removeChild(this);
                        }
                        this.parent = void 0;
                        return this;
                    }
                },
                {
                    key: "replaceWith",
                    value: function replaceWith() {
                        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){
                            nodes[_key] = arguments[_key];
                        }
                        if (this.parent) {
                            var bookmark = this;
                            var foundSelf = false;
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var node = _step.value;
                                    if (node === this) {
                                        foundSelf = true;
                                    } else if (foundSelf) {
                                        this.parent.insertAfter(bookmark, node);
                                        bookmark = node;
                                    } else {
                                        this.parent.insertBefore(bookmark, node);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            if (!foundSelf) {
                                this.remove();
                            }
                        }
                        return this;
                    }
                },
                {
                    key: "root",
                    value: function root() {
                        var result = this;
                        while(result.parent && result.parent.type !== "document"){
                            result = result.parent;
                        }
                        return result;
                    }
                },
                {
                    key: "toJSON",
                    value: function toJSON(_, inputs) {
                        var fixed = {};
                        var emitInputs = inputs == null;
                        inputs = inputs || /* @__PURE__ */ new Map();
                        var inputsNextIndex = 0;
                        for(var name in this){
                            if (!Object.prototype.hasOwnProperty.call(this, name)) {
                                continue;
                            }
                            if (name === "parent" || name === "proxyCache") continue;
                            var value = this[name];
                            if (Array.isArray(value)) {
                                fixed[name] = value.map(function(i2) {
                                    if (typeof i2 === "object" && i2.toJSON) {
                                        return i2.toJSON(null, inputs);
                                    } else {
                                        return i2;
                                    }
                                });
                            } else if (typeof value === "object" && value.toJSON) {
                                fixed[name] = value.toJSON(null, inputs);
                            } else if (name === "source") {
                                var inputId = inputs.get(value.input);
                                if (inputId == null) {
                                    inputId = inputsNextIndex;
                                    inputs.set(value.input, inputsNextIndex);
                                    inputsNextIndex++;
                                }
                                fixed[name] = {
                                    end: value.end,
                                    inputId: inputId,
                                    start: value.start
                                };
                            } else {
                                fixed[name] = value;
                            }
                        }
                        if (emitInputs) {
                            fixed.inputs = _to_consumable_array(inputs.keys()).map(function(input) {
                                return input.toJSON();
                            });
                        }
                        return fixed;
                    }
                },
                {
                    key: "toProxy",
                    value: function toProxy() {
                        if (!this.proxyCache) {
                            this.proxyCache = new Proxy(this, this.getProxyProcessor());
                        }
                        return this.proxyCache;
                    }
                },
                {
                    key: "toString",
                    value: function toString() {
                        var stringifier = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : stringify4;
                        if (stringifier.stringify) stringifier = stringifier.stringify;
                        var result = "";
                        stringifier(this, function(i2) {
                            result += i2;
                        });
                        return result;
                    }
                },
                {
                    key: "warn",
                    value: function warn(result, text, opts) {
                        var data = {
                            node: this
                        };
                        for(var i2 in opts)data[i2] = opts[i2];
                        return result.warn(text, data);
                    }
                },
                {
                    key: "proxyOf",
                    get: function get() {
                        return this;
                    }
                }
            ]);
            return Node2;
        }();
        module2.exports = Node2;
        Node2.default = Node2;
    }
});
// node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS({
    "node_modules/postcss/lib/declaration.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Node2 = require_node();
        var Declaration2 = /*#__PURE__*/ function(Node2) {
            _inherits(Declaration2, Node2);
            var _super = _create_super(Declaration2);
            function Declaration2(defaults) {
                _class_call_check(this, Declaration2);
                var _this;
                if (defaults && typeof defaults.value !== "undefined" && typeof defaults.value !== "string") {
                    defaults = _object_spread_props(_object_spread({}, defaults), {
                        value: String(defaults.value)
                    });
                }
                _this = _super.call(this, defaults);
                _this.type = "decl";
                return _this;
            }
            _create_class(Declaration2, [
                {
                    key: "variable",
                    get: function get() {
                        return this.prop.startsWith("--") || this.prop[0] === "$";
                    }
                }
            ]);
            return Declaration2;
        }(Node2);
        module2.exports = Declaration2;
        Declaration2.default = Declaration2;
    }
});
// (disabled):node_modules/source-map-js/source-map.js
var require_source_map = __commonJS({
    "(disabled):node_modules/source-map-js/source-map.js": function() {
        "use strict";
        init_shim();
    }
});
// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
    "node_modules/path-browserify/index.js": function(exports, module2) {
        "use strict";
        init_shim();
        function assertPath(path) {
            if (typeof path !== "string") {
                throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
            }
        }
        function normalizeStringPosix(path, allowAboveRoot) {
            var res = "";
            var lastSegmentLength = 0;
            var lastSlash = -1;
            var dots = 0;
            var code;
            for(var i2 = 0; i2 <= path.length; ++i2){
                if (i2 < path.length) code = path.charCodeAt(i2);
                else if (code === 47) break;
                else code = 47;
                if (code === 47) {
                    if (lastSlash === i2 - 1 || dots === 1) {} else if (lastSlash !== i2 - 1 && dots === 2) {
                        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                            if (res.length > 2) {
                                var lastSlashIndex = res.lastIndexOf("/");
                                if (lastSlashIndex !== res.length - 1) {
                                    if (lastSlashIndex === -1) {
                                        res = "";
                                        lastSegmentLength = 0;
                                    } else {
                                        res = res.slice(0, lastSlashIndex);
                                        lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                                    }
                                    lastSlash = i2;
                                    dots = 0;
                                    continue;
                                }
                            } else if (res.length === 2 || res.length === 1) {
                                res = "";
                                lastSegmentLength = 0;
                                lastSlash = i2;
                                dots = 0;
                                continue;
                            }
                        }
                        if (allowAboveRoot) {
                            if (res.length > 0) res += "/..";
                            else res = "..";
                            lastSegmentLength = 2;
                        }
                    } else {
                        if (res.length > 0) res += "/" + path.slice(lastSlash + 1, i2);
                        else res = path.slice(lastSlash + 1, i2);
                        lastSegmentLength = i2 - lastSlash - 1;
                    }
                    lastSlash = i2;
                    dots = 0;
                } else if (code === 46 && dots !== -1) {
                    ++dots;
                } else {
                    dots = -1;
                }
            }
            return res;
        }
        function _format(sep, pathObject) {
            var dir = pathObject.dir || pathObject.root;
            var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
            if (!dir) {
                return base;
            }
            if (dir === pathObject.root) {
                return dir + base;
            }
            return dir + sep + base;
        }
        var posix = {
            // path.resolve([from ...], to)
            resolve: function resolve2() {
                var resolvedPath = "";
                var resolvedAbsolute = false;
                var cwd;
                for(var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--){
                    var path;
                    if (i2 >= 0) path = arguments[i2];
                    else {
                        if (cwd === void 0) cwd = import_process.default.cwd();
                        path = cwd;
                    }
                    assertPath(path);
                    if (path.length === 0) {
                        continue;
                    }
                    resolvedPath = path + "/" + resolvedPath;
                    resolvedAbsolute = path.charCodeAt(0) === 47;
                }
                resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
                if (resolvedAbsolute) {
                    if (resolvedPath.length > 0) return "/" + resolvedPath;
                    else return "/";
                } else if (resolvedPath.length > 0) {
                    return resolvedPath;
                } else {
                    return ".";
                }
            },
            normalize: function normalize(path) {
                assertPath(path);
                if (path.length === 0) return ".";
                var isAbsolute = path.charCodeAt(0) === 47;
                var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
                path = normalizeStringPosix(path, !isAbsolute);
                if (path.length === 0 && !isAbsolute) path = ".";
                if (path.length > 0 && trailingSeparator) path += "/";
                if (isAbsolute) return "/" + path;
                return path;
            },
            isAbsolute: function isAbsolute(path) {
                assertPath(path);
                return path.length > 0 && path.charCodeAt(0) === 47;
            },
            join: function join() {
                if (arguments.length === 0) return ".";
                var joined;
                for(var i2 = 0; i2 < arguments.length; ++i2){
                    var arg = arguments[i2];
                    assertPath(arg);
                    if (arg.length > 0) {
                        if (joined === void 0) joined = arg;
                        else joined += "/" + arg;
                    }
                }
                if (joined === void 0) return ".";
                return posix.normalize(joined);
            },
            relative: function relative(from, to) {
                assertPath(from);
                assertPath(to);
                if (from === to) return "";
                from = posix.resolve(from);
                to = posix.resolve(to);
                if (from === to) return "";
                var fromStart = 1;
                for(; fromStart < from.length; ++fromStart){
                    if (from.charCodeAt(fromStart) !== 47) break;
                }
                var fromEnd = from.length;
                var fromLen = fromEnd - fromStart;
                var toStart = 1;
                for(; toStart < to.length; ++toStart){
                    if (to.charCodeAt(toStart) !== 47) break;
                }
                var toEnd = to.length;
                var toLen = toEnd - toStart;
                var length = fromLen < toLen ? fromLen : toLen;
                var lastCommonSep = -1;
                var i2 = 0;
                for(; i2 <= length; ++i2){
                    if (i2 === length) {
                        if (toLen > length) {
                            if (to.charCodeAt(toStart + i2) === 47) {
                                return to.slice(toStart + i2 + 1);
                            } else if (i2 === 0) {
                                return to.slice(toStart + i2);
                            }
                        } else if (fromLen > length) {
                            if (from.charCodeAt(fromStart + i2) === 47) {
                                lastCommonSep = i2;
                            } else if (i2 === 0) {
                                lastCommonSep = 0;
                            }
                        }
                        break;
                    }
                    var fromCode = from.charCodeAt(fromStart + i2);
                    var toCode = to.charCodeAt(toStart + i2);
                    if (fromCode !== toCode) break;
                    else if (fromCode === 47) lastCommonSep = i2;
                }
                var out = "";
                for(i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2){
                    if (i2 === fromEnd || from.charCodeAt(i2) === 47) {
                        if (out.length === 0) out += "..";
                        else out += "/..";
                    }
                }
                if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
                else {
                    toStart += lastCommonSep;
                    if (to.charCodeAt(toStart) === 47) ++toStart;
                    return to.slice(toStart);
                }
            },
            _makeLong: function _makeLong(path) {
                return path;
            },
            dirname: function dirname(path) {
                assertPath(path);
                if (path.length === 0) return ".";
                var code = path.charCodeAt(0);
                var hasRoot = code === 47;
                var end = -1;
                var matchedSlash = true;
                for(var i2 = path.length - 1; i2 >= 1; --i2){
                    code = path.charCodeAt(i2);
                    if (code === 47) {
                        if (!matchedSlash) {
                            end = i2;
                            break;
                        }
                    } else {
                        matchedSlash = false;
                    }
                }
                if (end === -1) return hasRoot ? "/" : ".";
                if (hasRoot && end === 1) return "//";
                return path.slice(0, end);
            },
            basename: function basename(path, ext) {
                if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
                assertPath(path);
                var start = 0;
                var end = -1;
                var matchedSlash = true;
                var i2;
                if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
                    if (ext.length === path.length && ext === path) return "";
                    var extIdx = ext.length - 1;
                    var firstNonSlashEnd = -1;
                    for(i2 = path.length - 1; i2 >= 0; --i2){
                        var code = path.charCodeAt(i2);
                        if (code === 47) {
                            if (!matchedSlash) {
                                start = i2 + 1;
                                break;
                            }
                        } else {
                            if (firstNonSlashEnd === -1) {
                                matchedSlash = false;
                                firstNonSlashEnd = i2 + 1;
                            }
                            if (extIdx >= 0) {
                                if (code === ext.charCodeAt(extIdx)) {
                                    if (--extIdx === -1) {
                                        end = i2;
                                    }
                                } else {
                                    extIdx = -1;
                                    end = firstNonSlashEnd;
                                }
                            }
                        }
                    }
                    if (start === end) end = firstNonSlashEnd;
                    else if (end === -1) end = path.length;
                    return path.slice(start, end);
                } else {
                    for(i2 = path.length - 1; i2 >= 0; --i2){
                        if (path.charCodeAt(i2) === 47) {
                            if (!matchedSlash) {
                                start = i2 + 1;
                                break;
                            }
                        } else if (end === -1) {
                            matchedSlash = false;
                            end = i2 + 1;
                        }
                    }
                    if (end === -1) return "";
                    return path.slice(start, end);
                }
            },
            extname: function extname(path) {
                assertPath(path);
                var startDot = -1;
                var startPart = 0;
                var end = -1;
                var matchedSlash = true;
                var preDotState = 0;
                for(var i2 = path.length - 1; i2 >= 0; --i2){
                    var code = path.charCodeAt(i2);
                    if (code === 47) {
                        if (!matchedSlash) {
                            startPart = i2 + 1;
                            break;
                        }
                        continue;
                    }
                    if (end === -1) {
                        matchedSlash = false;
                        end = i2 + 1;
                    }
                    if (code === 46) {
                        if (startDot === -1) startDot = i2;
                        else if (preDotState !== 1) preDotState = 1;
                    } else if (startDot !== -1) {
                        preDotState = -1;
                    }
                }
                if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
                preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
                preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                    return "";
                }
                return path.slice(startDot, end);
            },
            format: function format2(pathObject) {
                if (pathObject === null || typeof pathObject !== "object") {
                    throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + (typeof pathObject === "undefined" ? "undefined" : _type_of(pathObject)));
                }
                return _format("/", pathObject);
            },
            parse: function parse5(path) {
                assertPath(path);
                var ret = {
                    root: "",
                    dir: "",
                    base: "",
                    ext: "",
                    name: ""
                };
                if (path.length === 0) return ret;
                var code = path.charCodeAt(0);
                var isAbsolute = code === 47;
                var start;
                if (isAbsolute) {
                    ret.root = "/";
                    start = 1;
                } else {
                    start = 0;
                }
                var startDot = -1;
                var startPart = 0;
                var end = -1;
                var matchedSlash = true;
                var i2 = path.length - 1;
                var preDotState = 0;
                for(; i2 >= start; --i2){
                    code = path.charCodeAt(i2);
                    if (code === 47) {
                        if (!matchedSlash) {
                            startPart = i2 + 1;
                            break;
                        }
                        continue;
                    }
                    if (end === -1) {
                        matchedSlash = false;
                        end = i2 + 1;
                    }
                    if (code === 46) {
                        if (startDot === -1) startDot = i2;
                        else if (preDotState !== 1) preDotState = 1;
                    } else if (startDot !== -1) {
                        preDotState = -1;
                    }
                }
                if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
                preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
                preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                    if (end !== -1) {
                        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
                        else ret.base = ret.name = path.slice(startPart, end);
                    }
                } else {
                    if (startPart === 0 && isAbsolute) {
                        ret.name = path.slice(1, startDot);
                        ret.base = path.slice(1, end);
                    } else {
                        ret.name = path.slice(startPart, startDot);
                        ret.base = path.slice(startPart, end);
                    }
                    ret.ext = path.slice(startDot, end);
                }
                if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
                else if (isAbsolute) ret.dir = "/";
                return ret;
            },
            sep: "/",
            delimiter: ":",
            win32: null,
            posix: null
        };
        posix.posix = posix;
        module2.exports = posix;
    }
});
// node_modules/node-stdlib-browser/node_modules/punycode/punycode.js
var require_punycode = __commonJS({
    "node_modules/node-stdlib-browser/node_modules/punycode/punycode.js": function(exports, module2) {
        "use strict";
        init_shim();
        (function(root2) {
            var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
            var freeModule = typeof module2 == "object" && module2 && !module2.nodeType && module2;
            var freeGlobal = typeof _global == "object" && _global;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                root2 = freeGlobal;
            }
            var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                "overflow": "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
            function error(type) {
                throw new RangeError(errors[type]);
            }
            function map(array, fn) {
                var length = array.length;
                var result = [];
                while(length--){
                    result[length] = fn(array[length]);
                }
                return result;
            }
            function mapDomain(string, fn) {
                var parts = string.split("@");
                var result = "";
                if (parts.length > 1) {
                    result = parts[0] + "@";
                    string = parts[1];
                }
                string = string.replace(regexSeparators, ".");
                var labels = string.split(".");
                var encoded = map(labels, fn).join(".");
                return result + encoded;
            }
            function ucs2decode(string) {
                var output = [], counter = 0, length = string.length, value, extra;
                while(counter < length){
                    value = string.charCodeAt(counter++);
                    if (value >= 55296 && value <= 56319 && counter < length) {
                        extra = string.charCodeAt(counter++);
                        if ((extra & 64512) == 56320) {
                            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                        } else {
                            output.push(value);
                            counter--;
                        }
                    } else {
                        output.push(value);
                    }
                }
                return output;
            }
            function ucs2encode(array) {
                return map(array, function(value) {
                    var output = "";
                    if (value > 65535) {
                        value -= 65536;
                        output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                        value = 56320 | value & 1023;
                    }
                    output += stringFromCharCode(value);
                    return output;
                }).join("");
            }
            function basicToDigit(codePoint) {
                if (codePoint - 48 < 10) {
                    return codePoint - 22;
                }
                if (codePoint - 65 < 26) {
                    return codePoint - 65;
                }
                if (codePoint - 97 < 26) {
                    return codePoint - 97;
                }
                return base;
            }
            function digitToBasic(digit, flag) {
                return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            }
            function adapt(delta, numPoints, firstTime) {
                var k = 0;
                delta = firstTime ? floor(delta / damp) : delta >> 1;
                delta += floor(delta / numPoints);
                for(; delta > baseMinusTMin * tMax >> 1; k += base){
                    delta = floor(delta / baseMinusTMin);
                }
                return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
            }
            function decode3(input) {
                var output = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t2, baseMinusT;
                basic = input.lastIndexOf(delimiter);
                if (basic < 0) {
                    basic = 0;
                }
                for(j = 0; j < basic; ++j){
                    if (input.charCodeAt(j) >= 128) {
                        error("not-basic");
                    }
                    output.push(input.charCodeAt(j));
                }
                for(index = basic > 0 ? basic + 1 : 0; index < inputLength;){
                    for(oldi = i2, w = 1, k = base;; k += base){
                        if (index >= inputLength) {
                            error("invalid-input");
                        }
                        digit = basicToDigit(input.charCodeAt(index++));
                        if (digit >= base || digit > floor((maxInt - i2) / w)) {
                            error("overflow");
                        }
                        i2 += digit * w;
                        t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (digit < t2) {
                            break;
                        }
                        baseMinusT = base - t2;
                        if (w > floor(maxInt / baseMinusT)) {
                            error("overflow");
                        }
                        w *= baseMinusT;
                    }
                    out = output.length + 1;
                    bias = adapt(i2 - oldi, out, oldi == 0);
                    if (floor(i2 / out) > maxInt - n2) {
                        error("overflow");
                    }
                    n2 += floor(i2 / out);
                    i2 %= out;
                    output.splice(i2++, 0, n2);
                }
                return ucs2encode(output);
            }
            function encode4(input) {
                var n2, delta, handledCPCount, basicLength, bias, j, m, q, k, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                input = ucs2decode(input);
                inputLength = input.length;
                n2 = initialN;
                delta = 0;
                bias = initialBias;
                for(j = 0; j < inputLength; ++j){
                    currentValue = input[j];
                    if (currentValue < 128) {
                        output.push(stringFromCharCode(currentValue));
                    }
                }
                handledCPCount = basicLength = output.length;
                if (basicLength) {
                    output.push(delimiter);
                }
                while(handledCPCount < inputLength){
                    for(m = maxInt, j = 0; j < inputLength; ++j){
                        currentValue = input[j];
                        if (currentValue >= n2 && currentValue < m) {
                            m = currentValue;
                        }
                    }
                    handledCPCountPlusOne = handledCPCount + 1;
                    if (m - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
                        error("overflow");
                    }
                    delta += (m - n2) * handledCPCountPlusOne;
                    n2 = m;
                    for(j = 0; j < inputLength; ++j){
                        currentValue = input[j];
                        if (currentValue < n2 && ++delta > maxInt) {
                            error("overflow");
                        }
                        if (currentValue == n2) {
                            for(q = delta, k = base;; k += base){
                                t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                if (q < t2) {
                                    break;
                                }
                                qMinusT = q - t2;
                                baseMinusT = base - t2;
                                output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                                q = floor(qMinusT / baseMinusT);
                            }
                            output.push(stringFromCharCode(digitToBasic(q, 0)));
                            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                            delta = 0;
                            ++handledCPCount;
                        }
                    }
                    ++delta;
                    ++n2;
                }
                return output.join("");
            }
            function toUnicode(input) {
                return mapDomain(input, function(string) {
                    return regexPunycode.test(string) ? decode3(string.slice(4).toLowerCase()) : string;
                });
            }
            function toASCII(input) {
                return mapDomain(input, function(string) {
                    return regexNonASCII.test(string) ? "xn--" + encode4(string) : string;
                });
            }
            punycode2 = {
                /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */ "version": "1.4.1",
                /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */ "ucs2": {
                    "decode": ucs2decode,
                    "encode": ucs2encode
                },
                "decode": decode3,
                "encode": encode4,
                "toASCII": toASCII,
                "toUnicode": toUnicode
            };
            if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                define("punycode", function() {
                    return punycode2;
                });
            } else if (freeExports && freeModule) {
                if (module2.exports == freeExports) {
                    freeModule.exports = punycode2;
                } else {
                    for(key in punycode2){
                        punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
                    }
                }
            } else {
                root2.punycode = punycode2;
            }
        })(exports);
    }
});
// node_modules/querystring-es3/decode.js
var require_decode = __commonJS({
    "node_modules/querystring-es3/decode.js": function(exports, module2) {
        "use strict";
        init_shim();
        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module2.exports = function(qs, sep, eq, options) {
            sep = sep || "&";
            eq = eq || "=";
            var obj = {};
            if (typeof qs !== "string" || qs.length === 0) {
                return obj;
            }
            var regexp = /\+/g;
            qs = qs.split(sep);
            var maxKeys = 1e3;
            if (options && typeof options.maxKeys === "number") {
                maxKeys = options.maxKeys;
            }
            var len = qs.length;
            if (maxKeys > 0 && len > maxKeys) {
                len = maxKeys;
            }
            for(var i2 = 0; i2 < len; ++i2){
                var x = qs[i2].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
                if (idx >= 0) {
                    kstr = x.substr(0, idx);
                    vstr = x.substr(idx + 1);
                } else {
                    kstr = x;
                    vstr = "";
                }
                k = decodeURIComponent(kstr);
                v = decodeURIComponent(vstr);
                if (!hasOwnProperty(obj, k)) {
                    obj[k] = v;
                } else if (isArray(obj[k])) {
                    obj[k].push(v);
                } else {
                    obj[k] = [
                        obj[k],
                        v
                    ];
                }
            }
            return obj;
        };
        var isArray = Array.isArray || function(xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
        };
    }
});
// node_modules/querystring-es3/encode.js
var require_encode = __commonJS({
    "node_modules/querystring-es3/encode.js": function(exports, module2) {
        "use strict";
        init_shim();
        var stringifyPrimitive = function stringifyPrimitive(v) {
            switch(typeof v === "undefined" ? "undefined" : _type_of(v)){
                case "string":
                    return v;
                case "boolean":
                    return v ? "true" : "false";
                case "number":
                    return isFinite(v) ? v : "";
                default:
                    return "";
            }
        };
        module2.exports = function(obj, sep, eq, name) {
            sep = sep || "&";
            eq = eq || "=";
            if (obj === null) {
                obj = void 0;
            }
            if (typeof obj === "object") {
                return map(objectKeys(obj), function(k) {
                    var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                    if (isArray(obj[k])) {
                        return map(obj[k], function(v) {
                            return ks + encodeURIComponent(stringifyPrimitive(v));
                        }).join(sep);
                    } else {
                        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                    }
                }).join(sep);
            }
            if (!name) return "";
            return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
        var isArray = Array.isArray || function(xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
        };
        function map(xs, f) {
            if (xs.map) return xs.map(f);
            var res = [];
            for(var i2 = 0; i2 < xs.length; i2++){
                res.push(f(xs[i2], i2));
            }
            return res;
        }
        var objectKeys = Object.keys || function(obj) {
            var res = [];
            for(var key in obj){
                if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
            }
            return res;
        };
    }
});
// node_modules/querystring-es3/index.js
var require_querystring_es3 = __commonJS({
    "node_modules/querystring-es3/index.js": function(exports) {
        "use strict";
        init_shim();
        exports.decode = exports.parse = require_decode();
        exports.encode = exports.stringify = require_encode();
    }
});
// node_modules/node-stdlib-browser/esm/proxy/querystring.js
function qsEscape(string) {
    return encodeURIComponent(string);
}
function qsUnescape(string) {
    return decodeURIComponent(string);
}
var import_querystring_es3, import_querystring_es32, api;
var init_querystring = __esm({
    "node_modules/node-stdlib-browser/esm/proxy/querystring.js": function() {
        "use strict";
        init_shim();
        import_querystring_es3 = __toESM(require_querystring_es3());
        import_querystring_es32 = __toESM(require_querystring_es3());
        api = {
            decode: import_querystring_es3.decode,
            encode: import_querystring_es3.encode,
            parse: import_querystring_es3.parse,
            stringify: import_querystring_es3.stringify,
            escape: qsEscape,
            unescape: qsUnescape
        };
    }
});
// node_modules/node-stdlib-browser/esm/proxy/url.js
var url_exports = {};
__export(url_exports, {
    URL: function() {
        return URL2;
    },
    URLSearchParams: function() {
        return URLSearchParams;
    },
    Url: function() {
        return UrlImport;
    },
    default: function() {
        return api2;
    },
    domainToASCII: function() {
        return domainToASCII;
    },
    domainToUnicode: function() {
        return domainToUnicode;
    },
    fileURLToPath: function() {
        return fileURLToPath;
    },
    format: function() {
        return formatImportWithOverloads;
    },
    parse: function() {
        return parseImport;
    },
    pathToFileURL: function() {
        return pathToFileURL;
    },
    resolve: function() {
        return resolveImport;
    },
    resolveObject: function() {
        return resolveObject;
    }
});
function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
}
function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && util.isObject(url) && _instanceof(url, Url)) return url;
    var u = new Url();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
}
function urlFormat(obj) {
    if (util.isString(obj)) obj = urlParse(obj);
    if (!_instanceof(obj, Url)) return Url.prototype.format.call(obj);
    return obj.format();
}
function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
}
function urlResolveObject(source, relative) {
    if (!source) return relative;
    return urlParse(source, false, true).resolveObject(relative);
}
function normalizeArray(parts, allowAboveRoot) {
    var up = 0;
    for(var i2 = parts.length - 1; i2 >= 0; i2--){
        var last = parts[i2];
        if (last === ".") {
            parts.splice(i2, 1);
        } else if (last === "..") {
            parts.splice(i2, 1);
            up++;
        } else if (up) {
            parts.splice(i2, 1);
            up--;
        }
    }
    if (allowAboveRoot) {
        for(; up--; up){
            parts.unshift("..");
        }
    }
    return parts;
}
function resolve() {
    var resolvedPath = "", resolvedAbsolute = false;
    for(var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--){
        var path = i2 >= 0 ? arguments[i2] : "/";
        if (typeof path !== "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
            continue;
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path.charAt(0) === "/";
    }
    resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
        return !!p;
    }), !resolvedAbsolute).join("/");
    return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function filter(xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for(var i2 = 0; i2 < xs.length; i2++){
        if (f(xs[i2], i2, xs)) res.push(xs[i2]);
    }
    return res;
}
function isURLInstance(instance) {
    var resolved = /** @type {URL|null} */ instance != null ? instance : null;
    return Boolean(resolved !== null && (resolved == null ? void 0 : resolved.href) && (resolved == null ? void 0 : resolved.origin));
}
function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
        throw new TypeError('File URL host must be "localhost" or empty on browser');
    }
    var pathname = url.pathname;
    for(var n2 = 0; n2 < pathname.length; n2++){
        if (pathname[n2] === "%") {
            var third = pathname.codePointAt(n2 + 2) | 32;
            if (pathname[n2 + 1] === "2" && third === 102) {
                throw new TypeError("File URL path must not include encoded / characters");
            }
        }
    }
    return decodeURIComponent(pathname);
}
function encodePathChars(filepath) {
    if (filepath.includes("%")) {
        filepath = filepath.replace(percentRegEx, "%25");
    }
    if (filepath.includes("\\")) {
        filepath = filepath.replace(backslashRegEx, "%5C");
    }
    if (filepath.includes("\n")) {
        filepath = filepath.replace(newlineRegEx, "%0A");
    }
    if (filepath.includes("\r")) {
        filepath = filepath.replace(carriageReturnRegEx, "%0D");
    }
    if (filepath.includes("	")) {
        filepath = filepath.replace(tabRegEx, "%09");
    }
    return filepath;
}
var import_punycode, util$1, punycode, util, parse3, resolve$1, resolveObject, format, Url_1, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol, querystring, _globalThis2, formatImport, parseImport, resolveImport, UrlImport, URL2, URLSearchParams, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx, CHAR_FORWARD_SLASH, domainToASCII, domainToUnicode, pathToFileURL, fileURLToPath, formatImportWithOverloads, api2;
var init_url = __esm({
    "node_modules/node-stdlib-browser/esm/proxy/url.js": function() {
        "use strict";
        init_shim();
        import_punycode = __toESM(require_punycode());
        init_querystring();
        util$1 = {
            isString: function isString(arg) {
                return typeof arg === "string";
            },
            isObject: function isObject(arg) {
                return typeof arg === "object" && arg !== null;
            },
            isNull: function isNull(arg) {
                return arg === null;
            },
            isNullOrUndefined: function isNullOrUndefined(arg) {
                return arg == null;
            }
        };
        punycode = import_punycode.default;
        util = util$1;
        parse3 = urlParse;
        resolve$1 = urlResolve;
        resolveObject = urlResolveObject;
        format = urlFormat;
        Url_1 = Url;
        protocolPattern = /^([a-z0-9.+-]+:)/i;
        portPattern = /:[0-9]*$/;
        simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
        delims = [
            "<",
            ">",
            '"',
            "`",
            " ",
            "\r",
            "\n",
            "	"
        ];
        unwise = [
            "{",
            "}",
            "|",
            "\\",
            "^",
            "`"
        ].concat(delims);
        autoEscape = [
            "'"
        ].concat(unwise);
        nonHostChars = [
            "%",
            "/",
            "?",
            ";",
            "#"
        ].concat(autoEscape);
        hostEndingChars = [
            "/",
            "?",
            "#"
        ];
        hostnameMaxLen = 255;
        hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
        hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
        unsafeProtocol = {
            "javascript": true,
            "javascript:": true
        };
        hostlessProtocol = {
            "javascript": true,
            "javascript:": true
        };
        slashedProtocol = {
            "http": true,
            "https": true,
            "ftp": true,
            "gopher": true,
            "file": true,
            "http:": true,
            "https:": true,
            "ftp:": true,
            "gopher:": true,
            "file:": true
        };
        querystring = api;
        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
            if (!util.isString(url)) {
                throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === "undefined" ? "undefined" : _type_of(url)));
            }
            var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
            uSplit[0] = uSplit[0].replace(slashRegex, "/");
            url = uSplit.join(splitter);
            var rest = url;
            rest = rest.trim();
            if (!slashesDenoteHost && url.split("#").length === 1) {
                var simplePath = simplePathPattern.exec(rest);
                if (simplePath) {
                    this.path = rest;
                    this.href = rest;
                    this.pathname = simplePath[1];
                    if (simplePath[2]) {
                        this.search = simplePath[2];
                        if (parseQueryString) {
                            this.query = querystring.parse(this.search.substr(1));
                        } else {
                            this.query = this.search.substr(1);
                        }
                    } else if (parseQueryString) {
                        this.search = "";
                        this.query = {};
                    }
                    return this;
                }
            }
            var proto = protocolPattern.exec(rest);
            if (proto) {
                proto = proto[0];
                var lowerProto = proto.toLowerCase();
                this.protocol = lowerProto;
                rest = rest.substr(proto.length);
            }
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                var slashes = rest.substr(0, 2) === "//";
                if (slashes && !(proto && hostlessProtocol[proto])) {
                    rest = rest.substr(2);
                    this.slashes = true;
                }
            }
            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                var hostEnd = -1;
                for(var i2 = 0; i2 < hostEndingChars.length; i2++){
                    var hec = rest.indexOf(hostEndingChars[i2]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
                }
                var auth, atSign;
                if (hostEnd === -1) {
                    atSign = rest.lastIndexOf("@");
                } else {
                    atSign = rest.lastIndexOf("@", hostEnd);
                }
                if (atSign !== -1) {
                    auth = rest.slice(0, atSign);
                    rest = rest.slice(atSign + 1);
                    this.auth = decodeURIComponent(auth);
                }
                hostEnd = -1;
                for(var i2 = 0; i2 < nonHostChars.length; i2++){
                    var hec = rest.indexOf(nonHostChars[i2]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
                }
                if (hostEnd === -1) hostEnd = rest.length;
                this.host = rest.slice(0, hostEnd);
                rest = rest.slice(hostEnd);
                this.parseHost();
                this.hostname = this.hostname || "";
                var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
                if (!ipv6Hostname) {
                    var hostparts = this.hostname.split(/\./);
                    for(var i2 = 0, l = hostparts.length; i2 < l; i2++){
                        var part = hostparts[i2];
                        if (!part) continue;
                        if (!part.match(hostnamePartPattern)) {
                            var newpart = "";
                            for(var j = 0, k = part.length; j < k; j++){
                                if (part.charCodeAt(j) > 127) {
                                    newpart += "x";
                                } else {
                                    newpart += part[j];
                                }
                            }
                            if (!newpart.match(hostnamePartPattern)) {
                                var validParts = hostparts.slice(0, i2);
                                var notHost = hostparts.slice(i2 + 1);
                                var bit = part.match(hostnamePartStart);
                                if (bit) {
                                    validParts.push(bit[1]);
                                    notHost.unshift(bit[2]);
                                }
                                if (notHost.length) {
                                    rest = "/" + notHost.join(".") + rest;
                                }
                                this.hostname = validParts.join(".");
                                break;
                            }
                        }
                    }
                }
                if (this.hostname.length > hostnameMaxLen) {
                    this.hostname = "";
                } else {
                    this.hostname = this.hostname.toLowerCase();
                }
                if (!ipv6Hostname) {
                    this.hostname = punycode.toASCII(this.hostname);
                }
                var p = this.port ? ":" + this.port : "";
                var h = this.hostname || "";
                this.host = h + p;
                this.href += this.host;
                if (ipv6Hostname) {
                    this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                    if (rest[0] !== "/") {
                        rest = "/" + rest;
                    }
                }
            }
            if (!unsafeProtocol[lowerProto]) {
                for(var i2 = 0, l = autoEscape.length; i2 < l; i2++){
                    var ae = autoEscape[i2];
                    if (rest.indexOf(ae) === -1) continue;
                    var esc = encodeURIComponent(ae);
                    if (esc === ae) {
                        esc = escape(ae);
                    }
                    rest = rest.split(ae).join(esc);
                }
            }
            var hash = rest.indexOf("#");
            if (hash !== -1) {
                this.hash = rest.substr(hash);
                rest = rest.slice(0, hash);
            }
            var qm = rest.indexOf("?");
            if (qm !== -1) {
                this.search = rest.substr(qm);
                this.query = rest.substr(qm + 1);
                if (parseQueryString) {
                    this.query = querystring.parse(this.query);
                }
                rest = rest.slice(0, qm);
            } else if (parseQueryString) {
                this.search = "";
                this.query = {};
            }
            if (rest) this.pathname = rest;
            if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
                this.pathname = "/";
            }
            if (this.pathname || this.search) {
                var p = this.pathname || "";
                var s = this.search || "";
                this.path = p + s;
            }
            this.href = this.format();
            return this;
        };
        Url.prototype.format = function() {
            var auth = this.auth || "";
            if (auth) {
                auth = encodeURIComponent(auth);
                auth = auth.replace(/%3A/i, ":");
                auth += "@";
            }
            var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
            if (this.host) {
                host = auth + this.host;
            } else if (this.hostname) {
                host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
                if (this.port) {
                    host += ":" + this.port;
                }
            }
            if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
                query = querystring.stringify(this.query);
            }
            var search = this.search || query && "?" + query || "";
            if (protocol && protocol.substr(-1) !== ":") protocol += ":";
            if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
                host = "//" + (host || "");
                if (pathname && pathname.charAt(0) !== "/") pathname = "/" + pathname;
            } else if (!host) {
                host = "";
            }
            if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
            if (search && search.charAt(0) !== "?") search = "?" + search;
            pathname = pathname.replace(/[?#]/g, function(match) {
                return encodeURIComponent(match);
            });
            search = search.replace("#", "%23");
            return protocol + host + pathname + search + hash;
        };
        Url.prototype.resolve = function(relative) {
            return this.resolveObject(urlParse(relative, false, true)).format();
        };
        Url.prototype.resolveObject = function(relative) {
            if (util.isString(relative)) {
                var rel = new Url();
                rel.parse(relative, false, true);
                relative = rel;
            }
            var result = new Url();
            var tkeys = Object.keys(this);
            for(var tk = 0; tk < tkeys.length; tk++){
                var tkey = tkeys[tk];
                result[tkey] = this[tkey];
            }
            result.hash = relative.hash;
            if (relative.href === "") {
                result.href = result.format();
                return result;
            }
            if (relative.slashes && !relative.protocol) {
                var rkeys = Object.keys(relative);
                for(var rk = 0; rk < rkeys.length; rk++){
                    var rkey = rkeys[rk];
                    if (rkey !== "protocol") result[rkey] = relative[rkey];
                }
                if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
                    result.path = result.pathname = "/";
                }
                result.href = result.format();
                return result;
            }
            if (relative.protocol && relative.protocol !== result.protocol) {
                if (!slashedProtocol[relative.protocol]) {
                    var keys = Object.keys(relative);
                    for(var v = 0; v < keys.length; v++){
                        var k = keys[v];
                        result[k] = relative[k];
                    }
                    result.href = result.format();
                    return result;
                }
                result.protocol = relative.protocol;
                if (!relative.host && !hostlessProtocol[relative.protocol]) {
                    var relPath = (relative.pathname || "").split("/");
                    while(relPath.length && !(relative.host = relPath.shift()));
                    if (!relative.host) relative.host = "";
                    if (!relative.hostname) relative.hostname = "";
                    if (relPath[0] !== "") relPath.unshift("");
                    if (relPath.length < 2) relPath.unshift("");
                    result.pathname = relPath.join("/");
                } else {
                    result.pathname = relative.pathname;
                }
                result.search = relative.search;
                result.query = relative.query;
                result.host = relative.host || "";
                result.auth = relative.auth;
                result.hostname = relative.hostname || relative.host;
                result.port = relative.port;
                if (result.pathname || result.search) {
                    var p = result.pathname || "";
                    var s = result.search || "";
                    result.path = p + s;
                }
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result;
            }
            var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
            if (psychotic) {
                result.hostname = "";
                result.port = null;
                if (result.host) {
                    if (srcPath[0] === "") srcPath[0] = result.host;
                    else srcPath.unshift(result.host);
                }
                result.host = "";
                if (relative.protocol) {
                    relative.hostname = null;
                    relative.port = null;
                    if (relative.host) {
                        if (relPath[0] === "") relPath[0] = relative.host;
                        else relPath.unshift(relative.host);
                    }
                    relative.host = null;
                }
                mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
            }
            if (isRelAbs) {
                result.host = relative.host || relative.host === "" ? relative.host : result.host;
                result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
                result.search = relative.search;
                result.query = relative.query;
                srcPath = relPath;
            } else if (relPath.length) {
                if (!srcPath) srcPath = [];
                srcPath.pop();
                srcPath = srcPath.concat(relPath);
                result.search = relative.search;
                result.query = relative.query;
            } else if (!util.isNullOrUndefined(relative.search)) {
                if (psychotic) {
                    result.hostname = result.host = srcPath.shift();
                    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                    if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift();
                    }
                }
                result.search = relative.search;
                result.query = relative.query;
                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
                }
                result.href = result.format();
                return result;
            }
            if (!srcPath.length) {
                result.pathname = null;
                if (result.search) {
                    result.path = "/" + result.search;
                } else {
                    result.path = null;
                }
                result.href = result.format();
                return result;
            }
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
            var up = 0;
            for(var i2 = srcPath.length; i2 >= 0; i2--){
                last = srcPath[i2];
                if (last === ".") {
                    srcPath.splice(i2, 1);
                } else if (last === "..") {
                    srcPath.splice(i2, 1);
                    up++;
                } else if (up) {
                    srcPath.splice(i2, 1);
                    up--;
                }
            }
            if (!mustEndAbs && !removeAllDots) {
                for(; up--; up){
                    srcPath.unshift("..");
                }
            }
            if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
                srcPath.unshift("");
            }
            if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
                srcPath.push("");
            }
            var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
            if (psychotic) {
                result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
                var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                }
            }
            mustEndAbs = mustEndAbs || result.host && srcPath.length;
            if (mustEndAbs && !isAbsolute) {
                srcPath.unshift("");
            }
            if (!srcPath.length) {
                result.pathname = null;
                result.path = null;
            } else {
                result.pathname = srcPath.join("/");
            }
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.auth = relative.auth || result.auth;
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
        };
        Url.prototype.parseHost = function() {
            var host = this.host;
            var port = portPattern.exec(host);
            if (port) {
                port = port[0];
                if (port !== ":") {
                    this.port = port.substr(1);
                }
                host = host.substr(0, host.length - port.length);
            }
            if (host) this.hostname = host;
        };
        _globalThis2 = function(Object2) {
            function get() {
                var _global3 = this || self;
                delete Object2.prototype.__magic__;
                return _global3;
            }
            if (typeof globalThis === "object") {
                return globalThis;
            }
            if (this) {
                return get();
            } else {
                Object2.defineProperty(Object2.prototype, "__magic__", {
                    configurable: true,
                    get: get
                });
                var _global2 = __magic__;
                return _global2;
            }
        }(Object);
        formatImport = /** @type {formatImport}*/ format;
        parseImport = /** @type {parseImport}*/ parse3;
        resolveImport = /** @type {resolveImport}*/ resolve$1;
        UrlImport = /** @type {UrlImport}*/ Url_1;
        URL2 = _globalThis2.URL;
        URLSearchParams = _globalThis2.URLSearchParams;
        percentRegEx = /%/g;
        backslashRegEx = /\\/g;
        newlineRegEx = /\n/g;
        carriageReturnRegEx = /\r/g;
        tabRegEx = /\t/g;
        CHAR_FORWARD_SLASH = 47;
        domainToASCII = /**
     * @type {domainToASCII}
     */ function domainToASCII2(domain) {
            if (typeof domain === "undefined") {
                throw new TypeError('The "domain" argument must be specified');
            }
            return new URL2("http://" + domain).hostname;
        };
        domainToUnicode = /**
     * @type {domainToUnicode}
     */ function domainToUnicode2(domain) {
            if (typeof domain === "undefined") {
                throw new TypeError('The "domain" argument must be specified');
            }
            return new URL2("http://" + domain).hostname;
        };
        pathToFileURL = /**
     * @type {(url: string) => URL}
     */ function pathToFileURL2(filepath) {
            var outURL = new URL2("file://");
            var resolved = resolve(filepath);
            var filePathLast = filepath.charCodeAt(filepath.length - 1);
            if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
                resolved += "/";
            }
            outURL.pathname = encodePathChars(resolved);
            return outURL;
        };
        fileURLToPath = /**
     * @type {fileURLToPath & ((path: string | URL) => string)}
     */ function fileURLToPath2(path) {
            if (!isURLInstance(path) && typeof path !== "string") {
                throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + (typeof path === "undefined" ? "undefined" : _type_of(path)) + " (" + path + ")");
            }
            var resolved = new URL2(path);
            if (resolved.protocol !== "file:") {
                throw new TypeError("The URL must be of scheme file");
            }
            return getPathFromURLPosix(resolved);
        };
        formatImportWithOverloads = /**
     * @type {(
     *   ((urlObject: URL, options?: URLFormatOptions) => string) &
     *   ((urlObject: UrlObject | string, options?: never) => string)
     * )}
     */ function formatImportWithOverloads2(urlObject, options) {
            var _options$auth, _options$fragment, _options$search;
            if (options === void 0) {
                options = {};
            }
            if (!_instanceof(urlObject, URL2)) {
                return formatImport(urlObject);
            }
            if (typeof options !== "object" || options === null) {
                throw new TypeError('The "options" argument must be of type object.');
            }
            var auth = (_options$auth = options.auth) != null ? _options$auth : true;
            var fragment = (_options$fragment = options.fragment) != null ? _options$fragment : true;
            var search = (_options$search = options.search) != null ? _options$search : true;
            var parsed = new URL2(urlObject.toString());
            if (!auth) {
                parsed.username = "";
                parsed.password = "";
            }
            if (!fragment) {
                parsed.hash = "";
            }
            if (!search) {
                parsed.search = "";
            }
            return parsed.toString();
        };
        api2 = {
            format: formatImportWithOverloads,
            parse: parseImport,
            resolve: resolveImport,
            resolveObject: resolveObject,
            Url: UrlImport,
            URL: URL2,
            URLSearchParams: URLSearchParams,
            domainToASCII: domainToASCII,
            domainToUnicode: domainToUnicode,
            pathToFileURL: pathToFileURL,
            fileURLToPath: fileURLToPath
        };
    }
});
// node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS({
    "node_modules/nanoid/non-secure/index.cjs": function(exports, module2) {
        "use strict";
        init_shim();
        var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
        var customAlphabet = function(alphabet) {
            var defaultSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 21;
            return function() {
                var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultSize;
                var id = "";
                var i2 = size;
                while(i2--){
                    id += alphabet[Math.random() * alphabet.length | 0];
                }
                return id;
            };
        };
        var nanoid = function() {
            var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 21;
            var id = "";
            var i2 = size;
            while(i2--){
                id += urlAlphabet[Math.random() * 64 | 0];
            }
            return id;
        };
        module2.exports = {
            nanoid: nanoid,
            customAlphabet: customAlphabet
        };
    }
});
// node_modules/node-stdlib-browser/esm/mock/empty.js
var empty_exports = {};
__export(empty_exports, {
    default: function() {
        return empty;
    }
});
var empty;
var init_empty = __esm({
    "node_modules/node-stdlib-browser/esm/mock/empty.js": function() {
        "use strict";
        init_shim();
        empty = null;
    }
});
// node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS({
    "node_modules/postcss/lib/previous-map.js": function(exports, module2) {
        "use strict";
        init_shim();
        var _require_source_map = require_source_map(), SourceMapConsumer = _require_source_map.SourceMapConsumer, SourceMapGenerator = _require_source_map.SourceMapGenerator;
        var _ref = (init_empty(), __toCommonJS(empty_exports)), existsSync = _ref.existsSync, readFileSync = _ref.readFileSync;
        var _require_path_browserify = require_path_browserify(), dirname = _require_path_browserify.dirname, join = _require_path_browserify.join;
        function fromBase64(str) {
            if (import_buffer.Buffer) {
                return import_buffer.Buffer.from(str, "base64").toString();
            } else {
                return window.atob(str);
            }
        }
        var PreviousMap = /*#__PURE__*/ function() {
            function PreviousMap(css, opts) {
                _class_call_check(this, PreviousMap);
                if (opts.map === false) return;
                this.loadAnnotation(css);
                this.inline = this.startWith(this.annotation, "data:");
                var prev = opts.map ? opts.map.prev : void 0;
                var text = this.loadMap(opts.from, prev);
                if (!this.mapFile && opts.from) {
                    this.mapFile = opts.from;
                }
                if (this.mapFile) this.root = dirname(this.mapFile);
                if (text) this.text = text;
            }
            _create_class(PreviousMap, [
                {
                    key: "consumer",
                    value: function consumer() {
                        if (!this.consumerCache) {
                            this.consumerCache = new SourceMapConsumer(this.text);
                        }
                        return this.consumerCache;
                    }
                },
                {
                    key: "decodeInline",
                    value: function decodeInline(text) {
                        var baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
                        var baseUri = /^data:application\/json;base64,/;
                        var charsetUri = /^data:application\/json;charset=utf-?8,/;
                        var uri = /^data:application\/json,/;
                        if (charsetUri.test(text) || uri.test(text)) {
                            return decodeURIComponent(text.substr(RegExp.lastMatch.length));
                        }
                        if (baseCharsetUri.test(text) || baseUri.test(text)) {
                            return fromBase64(text.substr(RegExp.lastMatch.length));
                        }
                        var encoding = text.match(/data:application\/json;([^,]+),/)[1];
                        throw new Error("Unsupported source map encoding " + encoding);
                    }
                },
                {
                    key: "getAnnotationURL",
                    value: function getAnnotationURL(sourceMapString) {
                        return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
                    }
                },
                {
                    key: "isMap",
                    value: function isMap(map) {
                        if (typeof map !== "object") return false;
                        return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
                    }
                },
                {
                    key: "loadAnnotation",
                    value: function loadAnnotation(css) {
                        var comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
                        if (!comments) return;
                        var start = css.lastIndexOf(comments.pop());
                        var end = css.indexOf("*/", start);
                        if (start > -1 && end > -1) {
                            this.annotation = this.getAnnotationURL(css.substring(start, end));
                        }
                    }
                },
                {
                    key: "loadFile",
                    value: function loadFile(path) {
                        this.root = dirname(path);
                        if (existsSync(path)) {
                            this.mapFile = path;
                            return readFileSync(path, "utf-8").toString().trim();
                        }
                    }
                },
                {
                    key: "loadMap",
                    value: function loadMap(file, prev) {
                        if (prev === false) return false;
                        if (prev) {
                            if (typeof prev === "string") {
                                return prev;
                            } else if (typeof prev === "function") {
                                var prevPath = prev(file);
                                if (prevPath) {
                                    var map = this.loadFile(prevPath);
                                    if (!map) {
                                        throw new Error("Unable to load previous source map: " + prevPath.toString());
                                    }
                                    return map;
                                }
                            } else if (_instanceof(prev, SourceMapConsumer)) {
                                return SourceMapGenerator.fromSourceMap(prev).toString();
                            } else if (_instanceof(prev, SourceMapGenerator)) {
                                return prev.toString();
                            } else if (this.isMap(prev)) {
                                return JSON.stringify(prev);
                            } else {
                                throw new Error("Unsupported previous source map format: " + prev.toString());
                            }
                        } else if (this.inline) {
                            return this.decodeInline(this.annotation);
                        } else if (this.annotation) {
                            var map1 = this.annotation;
                            if (file) map1 = join(dirname(file), map1);
                            return this.loadFile(map1);
                        }
                    }
                },
                {
                    key: "startWith",
                    value: function startWith(string, start) {
                        if (!string) return false;
                        return string.substr(0, start.length) === start;
                    }
                },
                {
                    key: "withContent",
                    value: function withContent() {
                        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
                    }
                }
            ]);
            return PreviousMap;
        }();
        module2.exports = PreviousMap;
        PreviousMap.default = PreviousMap;
    }
});
// node_modules/postcss/lib/input.js
var require_input = __commonJS({
    "node_modules/postcss/lib/input.js": function(exports, module2) {
        "use strict";
        init_shim();
        var _require_source_map = require_source_map(), SourceMapConsumer = _require_source_map.SourceMapConsumer, SourceMapGenerator = _require_source_map.SourceMapGenerator;
        var _ref = (init_url(), __toCommonJS(url_exports)), fileURLToPath3 = _ref.fileURLToPath, pathToFileURL3 = _ref.pathToFileURL;
        var _require_path_browserify = require_path_browserify(), isAbsolute = _require_path_browserify.isAbsolute, resolve2 = _require_path_browserify.resolve;
        var nanoid = require_non_secure().nanoid;
        var terminalHighlight = require_terminal_highlight();
        var CssSyntaxError2 = require_css_syntax_error();
        var PreviousMap = require_previous_map();
        var fromOffsetCache = Symbol("fromOffsetCache");
        var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
        var pathAvailable = Boolean(resolve2 && isAbsolute);
        var Input2 = /*#__PURE__*/ function() {
            function Input2(css) {
                var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                _class_call_check(this, Input2);
                if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
                    throw new Error("PostCSS received ".concat(css, " instead of CSS string"));
                }
                this.css = css.toString();
                if (this.css[0] === "\uFEFF" || this.css[0] === "￾") {
                    this.hasBOM = true;
                    this.css = this.css.slice(1);
                } else {
                    this.hasBOM = false;
                }
                if (opts.from) {
                    if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
                        this.file = opts.from;
                    } else {
                        this.file = resolve2(opts.from);
                    }
                }
                if (pathAvailable && sourceMapAvailable) {
                    var map = new PreviousMap(this.css, opts);
                    if (map.text) {
                        this.map = map;
                        var file = map.consumer().file;
                        if (!this.file && file) this.file = this.mapResolve(file);
                    }
                }
                if (!this.file) {
                    this.id = "<input css " + nanoid(6) + ">";
                }
                if (this.map) this.map.file = this.from;
            }
            _create_class(Input2, [
                {
                    key: "error",
                    value: function error(message, line, column) {
                        var opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                        var result, endLine, endColumn;
                        if (line && typeof line === "object") {
                            var start = line;
                            var end = column;
                            if (typeof start.offset === "number") {
                                var pos = this.fromOffset(start.offset);
                                line = pos.line;
                                column = pos.col;
                            } else {
                                line = start.line;
                                column = start.column;
                            }
                            if (typeof end.offset === "number") {
                                var pos1 = this.fromOffset(end.offset);
                                endLine = pos1.line;
                                endColumn = pos1.col;
                            } else {
                                endLine = end.line;
                                endColumn = end.column;
                            }
                        } else if (!column) {
                            var pos2 = this.fromOffset(line);
                            line = pos2.line;
                            column = pos2.col;
                        }
                        var origin = this.origin(line, column, endLine, endColumn);
                        if (origin) {
                            result = new CssSyntaxError2(message, origin.endLine === void 0 ? origin.line : {
                                column: origin.column,
                                line: origin.line
                            }, origin.endLine === void 0 ? origin.column : {
                                column: origin.endColumn,
                                line: origin.endLine
                            }, origin.source, origin.file, opts.plugin);
                        } else {
                            result = new CssSyntaxError2(message, endLine === void 0 ? line : {
                                column: column,
                                line: line
                            }, endLine === void 0 ? column : {
                                column: endColumn,
                                line: endLine
                            }, this.css, this.file, opts.plugin);
                        }
                        result.input = {
                            column: column,
                            endColumn: endColumn,
                            endLine: endLine,
                            line: line,
                            source: this.css
                        };
                        if (this.file) {
                            if (pathToFileURL3) {
                                result.input.url = pathToFileURL3(this.file).toString();
                            }
                            result.input.file = this.file;
                        }
                        return result;
                    }
                },
                {
                    key: "fromOffset",
                    value: function fromOffset(offset) {
                        var lastLine, lineToIndex;
                        if (!this[fromOffsetCache]) {
                            var lines = this.css.split("\n");
                            lineToIndex = new Array(lines.length);
                            var prevIndex = 0;
                            for(var i2 = 0, l = lines.length; i2 < l; i2++){
                                lineToIndex[i2] = prevIndex;
                                prevIndex += lines[i2].length + 1;
                            }
                            this[fromOffsetCache] = lineToIndex;
                        } else {
                            lineToIndex = this[fromOffsetCache];
                        }
                        lastLine = lineToIndex[lineToIndex.length - 1];
                        var min = 0;
                        if (offset >= lastLine) {
                            min = lineToIndex.length - 1;
                        } else {
                            var max = lineToIndex.length - 2;
                            var mid;
                            while(min < max){
                                mid = min + (max - min >> 1);
                                if (offset < lineToIndex[mid]) {
                                    max = mid - 1;
                                } else if (offset >= lineToIndex[mid + 1]) {
                                    min = mid + 1;
                                } else {
                                    min = mid;
                                    break;
                                }
                            }
                        }
                        return {
                            col: offset - lineToIndex[min] + 1,
                            line: min + 1
                        };
                    }
                },
                {
                    key: "mapResolve",
                    value: function mapResolve(file) {
                        if (/^\w+:\/\//.test(file)) {
                            return file;
                        }
                        return resolve2(this.map.consumer().sourceRoot || this.map.root || ".", file);
                    }
                },
                {
                    key: "origin",
                    value: function origin(line, column, endLine, endColumn) {
                        if (!this.map) return false;
                        var consumer = this.map.consumer();
                        var from = consumer.originalPositionFor({
                            column: column,
                            line: line
                        });
                        if (!from.source) return false;
                        var to;
                        if (typeof endLine === "number") {
                            to = consumer.originalPositionFor({
                                column: endColumn,
                                line: endLine
                            });
                        }
                        var fromUrl;
                        if (isAbsolute(from.source)) {
                            fromUrl = pathToFileURL3(from.source);
                        } else {
                            fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL3(this.map.mapFile));
                        }
                        var result = {
                            column: from.column,
                            endColumn: to && to.column,
                            endLine: to && to.line,
                            line: from.line,
                            url: fromUrl.toString()
                        };
                        if (fromUrl.protocol === "file:") {
                            if (fileURLToPath3) {
                                result.file = fileURLToPath3(fromUrl);
                            } else {
                                throw new Error("file: protocol is not available in this PostCSS build");
                            }
                        }
                        var source = consumer.sourceContentFor(from.source);
                        if (source) result.source = source;
                        return result;
                    }
                },
                {
                    key: "toJSON",
                    value: function toJSON() {
                        var json = {};
                        for(var _i = 0, _iter = [
                            "hasBOM",
                            "css",
                            "file",
                            "id"
                        ]; _i < _iter.length; _i++){
                            var name = _iter[_i];
                            if (this[name] != null) {
                                json[name] = this[name];
                            }
                        }
                        if (this.map) {
                            json.map = _object_spread({}, this.map);
                            if (json.map.consumerCache) {
                                json.map.consumerCache = void 0;
                            }
                        }
                        return json;
                    }
                },
                {
                    key: "from",
                    get: function get() {
                        return this.file || this.id;
                    }
                }
            ]);
            return Input2;
        }();
        module2.exports = Input2;
        Input2.default = Input2;
        if (terminalHighlight && terminalHighlight.registerInput) {
            terminalHighlight.registerInput(Input2);
        }
    }
});
// node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS({
    "node_modules/postcss/lib/map-generator.js": function(exports, module2) {
        "use strict";
        init_shim();
        var _require_source_map = require_source_map(), SourceMapConsumer = _require_source_map.SourceMapConsumer, SourceMapGenerator = _require_source_map.SourceMapGenerator;
        var _require_path_browserify = require_path_browserify(), dirname = _require_path_browserify.dirname, relative = _require_path_browserify.relative, resolve2 = _require_path_browserify.resolve, sep = _require_path_browserify.sep;
        var _ref = (init_url(), __toCommonJS(url_exports)), pathToFileURL3 = _ref.pathToFileURL;
        var Input2 = require_input();
        var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
        var pathAvailable = Boolean(dirname && resolve2 && relative && sep);
        var MapGenerator = /*#__PURE__*/ function() {
            function MapGenerator(stringify4, root2, opts, cssString) {
                _class_call_check(this, MapGenerator);
                this.stringify = stringify4;
                this.mapOpts = opts.map || {};
                this.root = root2;
                this.opts = opts;
                this.css = cssString;
                this.originalCSS = cssString;
                this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
                this.memoizedFileURLs = /* @__PURE__ */ new Map();
                this.memoizedPaths = /* @__PURE__ */ new Map();
                this.memoizedURLs = /* @__PURE__ */ new Map();
            }
            _create_class(MapGenerator, [
                {
                    key: "addAnnotation",
                    value: function addAnnotation() {
                        var content;
                        if (this.isInline()) {
                            content = "data:application/json;base64," + this.toBase64(this.map.toString());
                        } else if (typeof this.mapOpts.annotation === "string") {
                            content = this.mapOpts.annotation;
                        } else if (typeof this.mapOpts.annotation === "function") {
                            content = this.mapOpts.annotation(this.opts.to, this.root);
                        } else {
                            content = this.outputFile() + ".map";
                        }
                        var eol = "\n";
                        if (this.css.includes("\r\n")) eol = "\r\n";
                        this.css += eol + "/*# sourceMappingURL=" + content + " */";
                    }
                },
                {
                    key: "applyPrevMaps",
                    value: function applyPrevMaps() {
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = this.previous()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var prev = _step.value;
                                var from = this.toUrl(this.path(prev.file));
                                var root2 = prev.root || dirname(prev.file);
                                var map = void 0;
                                if (this.mapOpts.sourcesContent === false) {
                                    map = new SourceMapConsumer(prev.text);
                                    if (map.sourcesContent) {
                                        map.sourcesContent = null;
                                    }
                                } else {
                                    map = prev.consumer();
                                }
                                this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                },
                {
                    key: "clearAnnotation",
                    value: function clearAnnotation() {
                        if (this.mapOpts.annotation === false) return;
                        if (this.root) {
                            var node;
                            for(var i2 = this.root.nodes.length - 1; i2 >= 0; i2--){
                                node = this.root.nodes[i2];
                                if (node.type !== "comment") continue;
                                if (node.text.indexOf("# sourceMappingURL=") === 0) {
                                    this.root.removeChild(i2);
                                }
                            }
                        } else if (this.css) {
                            this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
                        }
                    }
                },
                {
                    key: "generate",
                    value: function generate() {
                        this.clearAnnotation();
                        if (pathAvailable && sourceMapAvailable && this.isMap()) {
                            return this.generateMap();
                        } else {
                            var result = "";
                            this.stringify(this.root, function(i2) {
                                result += i2;
                            });
                            return [
                                result
                            ];
                        }
                    }
                },
                {
                    key: "generateMap",
                    value: function generateMap() {
                        if (this.root) {
                            this.generateString();
                        } else if (this.previous().length === 1) {
                            var prev = this.previous()[0].consumer();
                            prev.file = this.outputFile();
                            this.map = SourceMapGenerator.fromSourceMap(prev);
                        } else {
                            this.map = new SourceMapGenerator({
                                file: this.outputFile()
                            });
                            this.map.addMapping({
                                generated: {
                                    column: 0,
                                    line: 1
                                },
                                original: {
                                    column: 0,
                                    line: 1
                                },
                                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
                            });
                        }
                        if (this.isSourcesContent()) this.setSourcesContent();
                        if (this.root && this.previous().length > 0) this.applyPrevMaps();
                        if (this.isAnnotation()) this.addAnnotation();
                        if (this.isInline()) {
                            return [
                                this.css
                            ];
                        } else {
                            return [
                                this.css,
                                this.map
                            ];
                        }
                    }
                },
                {
                    key: "generateString",
                    value: function generateString() {
                        var _this = this;
                        this.css = "";
                        this.map = new SourceMapGenerator({
                            file: this.outputFile()
                        });
                        var line = 1;
                        var column = 1;
                        var noSource = "<no source>";
                        var mapping = {
                            generated: {
                                column: 0,
                                line: 0
                            },
                            original: {
                                column: 0,
                                line: 0
                            },
                            source: ""
                        };
                        var lines, last;
                        this.stringify(this.root, function(str, node, type) {
                            _this.css += str;
                            if (node && type !== "end") {
                                mapping.generated.line = line;
                                mapping.generated.column = column - 1;
                                if (node.source && node.source.start) {
                                    mapping.source = _this.sourcePath(node);
                                    mapping.original.line = node.source.start.line;
                                    mapping.original.column = node.source.start.column - 1;
                                    _this.map.addMapping(mapping);
                                } else {
                                    mapping.source = noSource;
                                    mapping.original.line = 1;
                                    mapping.original.column = 0;
                                    _this.map.addMapping(mapping);
                                }
                            }
                            lines = str.match(/\n/g);
                            if (lines) {
                                line += lines.length;
                                last = str.lastIndexOf("\n");
                                column = str.length - last;
                            } else {
                                column += str.length;
                            }
                            if (node && type !== "start") {
                                var p = node.parent || {
                                    raws: {}
                                };
                                var childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
                                if (!childless || node !== p.last || p.raws.semicolon) {
                                    if (node.source && node.source.end) {
                                        mapping.source = _this.sourcePath(node);
                                        mapping.original.line = node.source.end.line;
                                        mapping.original.column = node.source.end.column - 1;
                                        mapping.generated.line = line;
                                        mapping.generated.column = column - 2;
                                        _this.map.addMapping(mapping);
                                    } else {
                                        mapping.source = noSource;
                                        mapping.original.line = 1;
                                        mapping.original.column = 0;
                                        mapping.generated.line = line;
                                        mapping.generated.column = column - 1;
                                        _this.map.addMapping(mapping);
                                    }
                                }
                            }
                        });
                    }
                },
                {
                    key: "isAnnotation",
                    value: function isAnnotation() {
                        if (this.isInline()) {
                            return true;
                        }
                        if (typeof this.mapOpts.annotation !== "undefined") {
                            return this.mapOpts.annotation;
                        }
                        if (this.previous().length) {
                            return this.previous().some(function(i2) {
                                return i2.annotation;
                            });
                        }
                        return true;
                    }
                },
                {
                    key: "isInline",
                    value: function isInline() {
                        if (typeof this.mapOpts.inline !== "undefined") {
                            return this.mapOpts.inline;
                        }
                        var annotation = this.mapOpts.annotation;
                        if (typeof annotation !== "undefined" && annotation !== true) {
                            return false;
                        }
                        if (this.previous().length) {
                            return this.previous().some(function(i2) {
                                return i2.inline;
                            });
                        }
                        return true;
                    }
                },
                {
                    key: "isMap",
                    value: function isMap() {
                        if (typeof this.opts.map !== "undefined") {
                            return !!this.opts.map;
                        }
                        return this.previous().length > 0;
                    }
                },
                {
                    key: "isSourcesContent",
                    value: function isSourcesContent() {
                        if (typeof this.mapOpts.sourcesContent !== "undefined") {
                            return this.mapOpts.sourcesContent;
                        }
                        if (this.previous().length) {
                            return this.previous().some(function(i2) {
                                return i2.withContent();
                            });
                        }
                        return true;
                    }
                },
                {
                    key: "outputFile",
                    value: function outputFile() {
                        if (this.opts.to) {
                            return this.path(this.opts.to);
                        } else if (this.opts.from) {
                            return this.path(this.opts.from);
                        } else {
                            return "to.css";
                        }
                    }
                },
                {
                    key: "path",
                    value: function path(file) {
                        if (this.mapOpts.absolute) return file;
                        if (file.charCodeAt(0) === 60) return file;
                        if (/^\w+:\/\//.test(file)) return file;
                        var cached = this.memoizedPaths.get(file);
                        if (cached) return cached;
                        var from = this.opts.to ? dirname(this.opts.to) : ".";
                        if (typeof this.mapOpts.annotation === "string") {
                            from = dirname(resolve2(from, this.mapOpts.annotation));
                        }
                        var path = relative(from, file);
                        this.memoizedPaths.set(file, path);
                        return path;
                    }
                },
                {
                    key: "previous",
                    value: function previous() {
                        var _this = this;
                        if (!this.previousMaps) {
                            this.previousMaps = [];
                            if (this.root) {
                                this.root.walk(function(node) {
                                    if (node.source && node.source.input.map) {
                                        var map = node.source.input.map;
                                        if (!_this.previousMaps.includes(map)) {
                                            _this.previousMaps.push(map);
                                        }
                                    }
                                });
                            } else {
                                var input = new Input2(this.originalCSS, this.opts);
                                if (input.map) this.previousMaps.push(input.map);
                            }
                        }
                        return this.previousMaps;
                    }
                },
                {
                    key: "setSourcesContent",
                    value: function setSourcesContent() {
                        var _this = this;
                        var already = {};
                        if (this.root) {
                            this.root.walk(function(node) {
                                if (node.source) {
                                    var from = node.source.input.from;
                                    if (from && !already[from]) {
                                        already[from] = true;
                                        var fromUrl = _this.usesFileUrls ? _this.toFileUrl(from) : _this.toUrl(_this.path(from));
                                        _this.map.setSourceContent(fromUrl, node.source.input.css);
                                    }
                                }
                            });
                        } else if (this.css) {
                            var from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
                            this.map.setSourceContent(from, this.css);
                        }
                    }
                },
                {
                    key: "sourcePath",
                    value: function sourcePath(node) {
                        if (this.mapOpts.from) {
                            return this.toUrl(this.mapOpts.from);
                        } else if (this.usesFileUrls) {
                            return this.toFileUrl(node.source.input.from);
                        } else {
                            return this.toUrl(this.path(node.source.input.from));
                        }
                    }
                },
                {
                    key: "toBase64",
                    value: function toBase64(str) {
                        if (import_buffer.Buffer) {
                            return import_buffer.Buffer.from(str).toString("base64");
                        } else {
                            return window.btoa(unescape(encodeURIComponent(str)));
                        }
                    }
                },
                {
                    key: "toFileUrl",
                    value: function toFileUrl(path) {
                        var cached = this.memoizedFileURLs.get(path);
                        if (cached) return cached;
                        if (pathToFileURL3) {
                            var fileURL = pathToFileURL3(path).toString();
                            this.memoizedFileURLs.set(path, fileURL);
                            return fileURL;
                        } else {
                            throw new Error("`map.absolute` option is not available in this PostCSS build");
                        }
                    }
                },
                {
                    key: "toUrl",
                    value: function toUrl(path) {
                        var cached = this.memoizedURLs.get(path);
                        if (cached) return cached;
                        if (sep === "\\") {
                            path = path.replace(/\\/g, "/");
                        }
                        var url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
                        this.memoizedURLs.set(path, url);
                        return url;
                    }
                }
            ]);
            return MapGenerator;
        }();
        module2.exports = MapGenerator;
    }
});
// node_modules/postcss/lib/comment.js
var require_comment = __commonJS({
    "node_modules/postcss/lib/comment.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Node2 = require_node();
        var Comment2 = /*#__PURE__*/ function(Node2) {
            _inherits(Comment2, Node2);
            var _super = _create_super(Comment2);
            function Comment2(defaults) {
                _class_call_check(this, Comment2);
                var _this;
                _this = _super.call(this, defaults);
                _this.type = "comment";
                return _this;
            }
            return Comment2;
        }(Node2);
        module2.exports = Comment2;
        Comment2.default = Comment2;
    }
});
// node_modules/postcss/lib/container.js
var require_container = __commonJS({
    "node_modules/postcss/lib/container.js": function(exports, module2) {
        "use strict";
        init_shim();
        var _require_symbols = require_symbols(), isClean = _require_symbols.isClean, my = _require_symbols.my;
        var Declaration2 = require_declaration();
        var Comment2 = require_comment();
        var Node2 = require_node();
        var parse5;
        var Rule2;
        var AtRule2;
        var Root2;
        function cleanSource(nodes) {
            return nodes.map(function(i2) {
                if (i2.nodes) i2.nodes = cleanSource(i2.nodes);
                delete i2.source;
                return i2;
            });
        }
        function markDirtyUp(node) {
            node[isClean] = false;
            if (node.proxyOf.nodes) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = node.proxyOf.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var i2 = _step.value;
                        markDirtyUp(i2);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        }
        var Container2 = /*#__PURE__*/ function(Node2) {
            _inherits(_Container, Node2);
            var _super = _create_super(_Container);
            function _Container() {
                _class_call_check(this, _Container);
                return _super.apply(this, arguments);
            }
            _create_class(_Container, [
                {
                    key: "append",
                    value: function append() {
                        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){
                            children[_key] = arguments[_key];
                        }
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var child = _step.value;
                                var nodes = this.normalize(child, this.last);
                                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                try {
                                    for(var _iterator1 = nodes[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                        var node = _step1.value;
                                        this.proxyOf.nodes.push(node);
                                    }
                                } catch (err) {
                                    _didIteratorError1 = true;
                                    _iteratorError1 = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                            _iterator1.return();
                                        }
                                    } finally{
                                        if (_didIteratorError1) {
                                            throw _iteratorError1;
                                        }
                                    }
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        this.markDirty();
                        return this;
                    }
                },
                {
                    key: "cleanRaws",
                    value: function cleanRaws(keepBetween) {
                        _get(_get_prototype_of(_Container.prototype), "cleanRaws", this).call(this, keepBetween);
                        if (this.nodes) {
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = this.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var node = _step.value;
                                    node.cleanRaws(keepBetween);
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    }
                },
                {
                    key: "each",
                    value: function each(callback) {
                        if (!this.proxyOf.nodes) return void 0;
                        var iterator = this.getIterator();
                        var index, result;
                        while(this.indexes[iterator] < this.proxyOf.nodes.length){
                            index = this.indexes[iterator];
                            result = callback(this.proxyOf.nodes[index], index);
                            if (result === false) break;
                            this.indexes[iterator] += 1;
                        }
                        delete this.indexes[iterator];
                        return result;
                    }
                },
                {
                    key: "every",
                    value: function every(condition) {
                        return this.nodes.every(condition);
                    }
                },
                {
                    key: "getIterator",
                    value: function getIterator() {
                        if (!this.lastEach) this.lastEach = 0;
                        if (!this.indexes) this.indexes = {};
                        this.lastEach += 1;
                        var iterator = this.lastEach;
                        this.indexes[iterator] = 0;
                        return iterator;
                    }
                },
                {
                    key: "getProxyProcessor",
                    value: function getProxyProcessor() {
                        return {
                            get: function get(node, prop) {
                                if (prop === "proxyOf") {
                                    return node;
                                } else if (!node[prop]) {
                                    return node[prop];
                                } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
                                    return function() {
                                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                            args[_key] = arguments[_key];
                                        }
                                        var _node;
                                        return (_node = node)[prop].apply(_node, _to_consumable_array(args.map(function(i2) {
                                            if (typeof i2 === "function") {
                                                return function(child, index) {
                                                    return i2(child.toProxy(), index);
                                                };
                                            } else {
                                                return i2;
                                            }
                                        })));
                                    };
                                } else if (prop === "every" || prop === "some") {
                                    return function(cb) {
                                        return node[prop](function(child) {
                                            for(var _len = arguments.length, other = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                                                other[_key - 1] = arguments[_key];
                                            }
                                            return cb.apply(void 0, [
                                                child.toProxy()
                                            ].concat(_to_consumable_array(other)));
                                        });
                                    };
                                } else if (prop === "root") {
                                    return function() {
                                        return node.root().toProxy();
                                    };
                                } else if (prop === "nodes") {
                                    return node.nodes.map(function(i2) {
                                        return i2.toProxy();
                                    });
                                } else if (prop === "first" || prop === "last") {
                                    return node[prop].toProxy();
                                } else {
                                    return node[prop];
                                }
                            },
                            set: function set(node, prop, value) {
                                if (node[prop] === value) return true;
                                node[prop] = value;
                                if (prop === "name" || prop === "params" || prop === "selector") {
                                    node.markDirty();
                                }
                                return true;
                            }
                        };
                    }
                },
                {
                    key: "index",
                    value: function index(child) {
                        if (typeof child === "number") return child;
                        if (child.proxyOf) child = child.proxyOf;
                        return this.proxyOf.nodes.indexOf(child);
                    }
                },
                {
                    key: "insertAfter",
                    value: function insertAfter(exist, add) {
                        var existIndex = this.index(exist);
                        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
                        existIndex = this.index(exist);
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var node = _step.value;
                                this.proxyOf.nodes.splice(existIndex + 1, 0, node);
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        var index;
                        for(var id in this.indexes){
                            index = this.indexes[id];
                            if (existIndex < index) {
                                this.indexes[id] = index + nodes.length;
                            }
                        }
                        this.markDirty();
                        return this;
                    }
                },
                {
                    key: "insertBefore",
                    value: function insertBefore(exist, add) {
                        var existIndex = this.index(exist);
                        var type = existIndex === 0 ? "prepend" : false;
                        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
                        existIndex = this.index(exist);
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var node = _step.value;
                                this.proxyOf.nodes.splice(existIndex, 0, node);
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        var index;
                        for(var id in this.indexes){
                            index = this.indexes[id];
                            if (existIndex <= index) {
                                this.indexes[id] = index + nodes.length;
                            }
                        }
                        this.markDirty();
                        return this;
                    }
                },
                {
                    key: "normalize",
                    value: function normalize(nodes, sample) {
                        var _this = this;
                        if (typeof nodes === "string") {
                            nodes = cleanSource(parse5(nodes).nodes);
                        } else if (typeof nodes === "undefined") {
                            nodes = [];
                        } else if (Array.isArray(nodes)) {
                            nodes = nodes.slice(0);
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var i2 = _step.value;
                                    if (i2.parent) i2.parent.removeChild(i2, "ignore");
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        } else if (nodes.type === "root" && this.type !== "document") {
                            nodes = nodes.nodes.slice(0);
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = nodes[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var i21 = _step1.value;
                                    if (i21.parent) i21.parent.removeChild(i21, "ignore");
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                        } else if (nodes.type) {
                            nodes = [
                                nodes
                            ];
                        } else if (nodes.prop) {
                            if (typeof nodes.value === "undefined") {
                                throw new Error("Value field is missed in node creation");
                            } else if (typeof nodes.value !== "string") {
                                nodes.value = String(nodes.value);
                            }
                            nodes = [
                                new Declaration2(nodes)
                            ];
                        } else if (nodes.selector) {
                            nodes = [
                                new Rule2(nodes)
                            ];
                        } else if (nodes.name) {
                            nodes = [
                                new AtRule2(nodes)
                            ];
                        } else if (nodes.text) {
                            nodes = [
                                new Comment2(nodes)
                            ];
                        } else {
                            throw new Error("Unknown node type in node creation");
                        }
                        var processed = nodes.map(function(i2) {
                            if (!i2[my]) _Container.rebuild(i2);
                            i2 = i2.proxyOf;
                            if (i2.parent) i2.parent.removeChild(i2);
                            if (i2[isClean]) markDirtyUp(i2);
                            if (typeof i2.raws.before === "undefined") {
                                if (sample && typeof sample.raws.before !== "undefined") {
                                    i2.raws.before = sample.raws.before.replace(/\S/g, "");
                                }
                            }
                            i2.parent = _this.proxyOf;
                            return i2;
                        });
                        return processed;
                    }
                },
                {
                    key: "prepend",
                    value: function prepend() {
                        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){
                            children[_key] = arguments[_key];
                        }
                        children = children.reverse();
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var child = _step.value;
                                var nodes = this.normalize(child, this.first, "prepend").reverse();
                                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                try {
                                    for(var _iterator1 = nodes[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                        var node = _step1.value;
                                        this.proxyOf.nodes.unshift(node);
                                    }
                                } catch (err) {
                                    _didIteratorError1 = true;
                                    _iteratorError1 = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                            _iterator1.return();
                                        }
                                    } finally{
                                        if (_didIteratorError1) {
                                            throw _iteratorError1;
                                        }
                                    }
                                }
                                for(var id in this.indexes){
                                    this.indexes[id] = this.indexes[id] + nodes.length;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        this.markDirty();
                        return this;
                    }
                },
                {
                    key: "push",
                    value: function push(child) {
                        child.parent = this;
                        this.proxyOf.nodes.push(child);
                        return this;
                    }
                },
                {
                    key: "removeAll",
                    value: function removeAll() {
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = this.proxyOf.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var node = _step.value;
                                node.parent = void 0;
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        this.proxyOf.nodes = [];
                        this.markDirty();
                        return this;
                    }
                },
                {
                    key: "removeChild",
                    value: function removeChild(child) {
                        child = this.index(child);
                        this.proxyOf.nodes[child].parent = void 0;
                        this.proxyOf.nodes.splice(child, 1);
                        var index;
                        for(var id in this.indexes){
                            index = this.indexes[id];
                            if (index >= child) {
                                this.indexes[id] = index - 1;
                            }
                        }
                        this.markDirty();
                        return this;
                    }
                },
                {
                    key: "replaceValues",
                    value: function replaceValues(pattern, opts, callback) {
                        if (!callback) {
                            callback = opts;
                            opts = {};
                        }
                        this.walkDecls(function(decl2) {
                            if (opts.props && !opts.props.includes(decl2.prop)) return;
                            if (opts.fast && !decl2.value.includes(opts.fast)) return;
                            decl2.value = decl2.value.replace(pattern, callback);
                        });
                        this.markDirty();
                        return this;
                    }
                },
                {
                    key: "some",
                    value: function some(condition) {
                        return this.nodes.some(condition);
                    }
                },
                {
                    key: "walk",
                    value: function walk(callback) {
                        return this.each(function(child, i2) {
                            var result;
                            try {
                                result = callback(child, i2);
                            } catch (e2) {
                                throw child.addToError(e2);
                            }
                            if (result !== false && child.walk) {
                                result = child.walk(callback);
                            }
                            return result;
                        });
                    }
                },
                {
                    key: "walkAtRules",
                    value: function walkAtRules(name, callback) {
                        if (!callback) {
                            callback = name;
                            return this.walk(function(child, i2) {
                                if (child.type === "atrule") {
                                    return callback(child, i2);
                                }
                            });
                        }
                        if (_instanceof(name, RegExp)) {
                            return this.walk(function(child, i2) {
                                if (child.type === "atrule" && name.test(child.name)) {
                                    return callback(child, i2);
                                }
                            });
                        }
                        return this.walk(function(child, i2) {
                            if (child.type === "atrule" && child.name === name) {
                                return callback(child, i2);
                            }
                        });
                    }
                },
                {
                    key: "walkComments",
                    value: function walkComments(callback) {
                        return this.walk(function(child, i2) {
                            if (child.type === "comment") {
                                return callback(child, i2);
                            }
                        });
                    }
                },
                {
                    key: "walkDecls",
                    value: function walkDecls(prop, callback) {
                        if (!callback) {
                            callback = prop;
                            return this.walk(function(child, i2) {
                                if (child.type === "decl") {
                                    return callback(child, i2);
                                }
                            });
                        }
                        if (_instanceof(prop, RegExp)) {
                            return this.walk(function(child, i2) {
                                if (child.type === "decl" && prop.test(child.prop)) {
                                    return callback(child, i2);
                                }
                            });
                        }
                        return this.walk(function(child, i2) {
                            if (child.type === "decl" && child.prop === prop) {
                                return callback(child, i2);
                            }
                        });
                    }
                },
                {
                    key: "walkRules",
                    value: function walkRules(selector, callback) {
                        if (!callback) {
                            callback = selector;
                            return this.walk(function(child, i2) {
                                if (child.type === "rule") {
                                    return callback(child, i2);
                                }
                            });
                        }
                        if (_instanceof(selector, RegExp)) {
                            return this.walk(function(child, i2) {
                                if (child.type === "rule" && selector.test(child.selector)) {
                                    return callback(child, i2);
                                }
                            });
                        }
                        return this.walk(function(child, i2) {
                            if (child.type === "rule" && child.selector === selector) {
                                return callback(child, i2);
                            }
                        });
                    }
                },
                {
                    key: "first",
                    get: function get() {
                        if (!this.proxyOf.nodes) return void 0;
                        return this.proxyOf.nodes[0];
                    }
                },
                {
                    key: "last",
                    get: function get() {
                        if (!this.proxyOf.nodes) return void 0;
                        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
                    }
                }
            ]);
            return _Container;
        }(Node2);
        Container2.registerParse = function(dependant) {
            parse5 = dependant;
        };
        Container2.registerRule = function(dependant) {
            Rule2 = dependant;
        };
        Container2.registerAtRule = function(dependant) {
            AtRule2 = dependant;
        };
        Container2.registerRoot = function(dependant) {
            Root2 = dependant;
        };
        module2.exports = Container2;
        Container2.default = Container2;
        Container2.rebuild = function(node) {
            if (node.type === "atrule") {
                Object.setPrototypeOf(node, AtRule2.prototype);
            } else if (node.type === "rule") {
                Object.setPrototypeOf(node, Rule2.prototype);
            } else if (node.type === "decl") {
                Object.setPrototypeOf(node, Declaration2.prototype);
            } else if (node.type === "comment") {
                Object.setPrototypeOf(node, Comment2.prototype);
            } else if (node.type === "root") {
                Object.setPrototypeOf(node, Root2.prototype);
            }
            node[my] = true;
            if (node.nodes) {
                node.nodes.forEach(function(child) {
                    Container2.rebuild(child);
                });
            }
        };
    }
});
// node_modules/postcss/lib/document.js
var require_document = __commonJS({
    "node_modules/postcss/lib/document.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Container2 = require_container();
        var LazyResult;
        var Processor2;
        var Document2 = /*#__PURE__*/ function(Container2) {
            _inherits(Document2, Container2);
            var _super = _create_super(Document2);
            function Document2(defaults) {
                _class_call_check(this, Document2);
                var _this;
                _this = _super.call(this, _object_spread({
                    type: "document"
                }, defaults));
                if (!_this.nodes) {
                    _this.nodes = [];
                }
                return _this;
            }
            _create_class(Document2, [
                {
                    key: "toResult",
                    value: function toResult() {
                        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                        var lazy = new LazyResult(new Processor2(), this, opts);
                        return lazy.stringify();
                    }
                }
            ]);
            return Document2;
        }(Container2);
        Document2.registerLazyResult = function(dependant) {
            LazyResult = dependant;
        };
        Document2.registerProcessor = function(dependant) {
            Processor2 = dependant;
        };
        module2.exports = Document2;
        Document2.default = Document2;
    }
});
// node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS({
    "node_modules/postcss/lib/warn-once.js": function(exports, module2) {
        "use strict";
        init_shim();
        var printed = {};
        module2.exports = function warnOnce(message) {
            if (printed[message]) return;
            printed[message] = true;
            if (typeof console !== "undefined" && console.warn) {
                console.warn(message);
            }
        };
    }
});
// node_modules/postcss/lib/warning.js
var require_warning = __commonJS({
    "node_modules/postcss/lib/warning.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Warning2 = /*#__PURE__*/ function() {
            function Warning2(text) {
                var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                _class_call_check(this, Warning2);
                this.type = "warning";
                this.text = text;
                if (opts.node && opts.node.source) {
                    var range = opts.node.rangeBy(opts);
                    this.line = range.start.line;
                    this.column = range.start.column;
                    this.endLine = range.end.line;
                    this.endColumn = range.end.column;
                }
                for(var opt in opts)this[opt] = opts[opt];
            }
            _create_class(Warning2, [
                {
                    key: "toString",
                    value: function toString() {
                        if (this.node) {
                            return this.node.error(this.text, {
                                index: this.index,
                                plugin: this.plugin,
                                word: this.word
                            }).message;
                        }
                        if (this.plugin) {
                            return this.plugin + ": " + this.text;
                        }
                        return this.text;
                    }
                }
            ]);
            return Warning2;
        }();
        module2.exports = Warning2;
        Warning2.default = Warning2;
    }
});
// node_modules/postcss/lib/result.js
var require_result = __commonJS({
    "node_modules/postcss/lib/result.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Warning2 = require_warning();
        var Result2 = /*#__PURE__*/ function() {
            function Result2(processor, root2, opts) {
                _class_call_check(this, Result2);
                this.processor = processor;
                this.messages = [];
                this.root = root2;
                this.opts = opts;
                this.css = void 0;
                this.map = void 0;
            }
            _create_class(Result2, [
                {
                    key: "toString",
                    value: function toString() {
                        return this.css;
                    }
                },
                {
                    key: "warn",
                    value: function warn(text) {
                        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                        if (!opts.plugin) {
                            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
                                opts.plugin = this.lastPlugin.postcssPlugin;
                            }
                        }
                        var warning = new Warning2(text, opts);
                        this.messages.push(warning);
                        return warning;
                    }
                },
                {
                    key: "warnings",
                    value: function warnings() {
                        return this.messages.filter(function(i2) {
                            return i2.type === "warning";
                        });
                    }
                },
                {
                    key: "content",
                    get: function get() {
                        return this.css;
                    }
                }
            ]);
            return Result2;
        }();
        module2.exports = Result2;
        Result2.default = Result2;
    }
});
// node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS({
    "node_modules/postcss/lib/tokenize.js": function(exports, module2) {
        "use strict";
        init_shim();
        var SINGLE_QUOTE = "'".charCodeAt(0);
        var DOUBLE_QUOTE = '"'.charCodeAt(0);
        var BACKSLASH = "\\".charCodeAt(0);
        var SLASH = "/".charCodeAt(0);
        var NEWLINE = "\n".charCodeAt(0);
        var SPACE = " ".charCodeAt(0);
        var FEED = "\f".charCodeAt(0);
        var TAB = "	".charCodeAt(0);
        var CR = "\r".charCodeAt(0);
        var OPEN_SQUARE = "[".charCodeAt(0);
        var CLOSE_SQUARE = "]".charCodeAt(0);
        var OPEN_PARENTHESES = "(".charCodeAt(0);
        var CLOSE_PARENTHESES = ")".charCodeAt(0);
        var OPEN_CURLY = "{".charCodeAt(0);
        var CLOSE_CURLY = "}".charCodeAt(0);
        var SEMICOLON = ";".charCodeAt(0);
        var ASTERISK = "*".charCodeAt(0);
        var COLON = ":".charCodeAt(0);
        var AT = "@".charCodeAt(0);
        var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
        var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
        var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
        var RE_HEX_ESCAPE = /[\da-f]/i;
        module2.exports = function tokenizer(input) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var css = input.css.valueOf();
            var ignore = options.ignoreErrors;
            var code, next, quote, content, escape2;
            var escaped, escapePos, prev, n2, currentToken;
            var length = css.length;
            var pos = 0;
            var buffer = [];
            var returned = [];
            function position() {
                return pos;
            }
            function unclosed(what) {
                throw input.error("Unclosed " + what, pos);
            }
            function endOfFile() {
                return returned.length === 0 && pos >= length;
            }
            function nextToken(opts) {
                if (returned.length) return returned.pop();
                if (pos >= length) return;
                var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
                code = css.charCodeAt(pos);
                switch(code){
                    case NEWLINE:
                    case SPACE:
                    case TAB:
                    case CR:
                    case FEED:
                        {
                            next = pos;
                            do {
                                next += 1;
                                code = css.charCodeAt(next);
                            }while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
                            currentToken = [
                                "space",
                                css.slice(pos, next)
                            ];
                            pos = next - 1;
                            break;
                        }
                    case OPEN_SQUARE:
                    case CLOSE_SQUARE:
                    case OPEN_CURLY:
                    case CLOSE_CURLY:
                    case COLON:
                    case SEMICOLON:
                    case CLOSE_PARENTHESES:
                        {
                            var controlChar = String.fromCharCode(code);
                            currentToken = [
                                controlChar,
                                controlChar,
                                pos
                            ];
                            break;
                        }
                    case OPEN_PARENTHESES:
                        {
                            prev = buffer.length ? buffer.pop()[1] : "";
                            n2 = css.charCodeAt(pos + 1);
                            if (prev === "url" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {
                                next = pos;
                                do {
                                    escaped = false;
                                    next = css.indexOf(")", next + 1);
                                    if (next === -1) {
                                        if (ignore || ignoreUnclosed) {
                                            next = pos;
                                            break;
                                        } else {
                                            unclosed("bracket");
                                        }
                                    }
                                    escapePos = next;
                                    while(css.charCodeAt(escapePos - 1) === BACKSLASH){
                                        escapePos -= 1;
                                        escaped = !escaped;
                                    }
                                }while (escaped);
                                currentToken = [
                                    "brackets",
                                    css.slice(pos, next + 1),
                                    pos,
                                    next
                                ];
                                pos = next;
                            } else {
                                next = css.indexOf(")", pos + 1);
                                content = css.slice(pos, next + 1);
                                if (next === -1 || RE_BAD_BRACKET.test(content)) {
                                    currentToken = [
                                        "(",
                                        "(",
                                        pos
                                    ];
                                } else {
                                    currentToken = [
                                        "brackets",
                                        content,
                                        pos,
                                        next
                                    ];
                                    pos = next;
                                }
                            }
                            break;
                        }
                    case SINGLE_QUOTE:
                    case DOUBLE_QUOTE:
                        {
                            quote = code === SINGLE_QUOTE ? "'" : '"';
                            next = pos;
                            do {
                                escaped = false;
                                next = css.indexOf(quote, next + 1);
                                if (next === -1) {
                                    if (ignore || ignoreUnclosed) {
                                        next = pos + 1;
                                        break;
                                    } else {
                                        unclosed("string");
                                    }
                                }
                                escapePos = next;
                                while(css.charCodeAt(escapePos - 1) === BACKSLASH){
                                    escapePos -= 1;
                                    escaped = !escaped;
                                }
                            }while (escaped);
                            currentToken = [
                                "string",
                                css.slice(pos, next + 1),
                                pos,
                                next
                            ];
                            pos = next;
                            break;
                        }
                    case AT:
                        {
                            RE_AT_END.lastIndex = pos + 1;
                            RE_AT_END.test(css);
                            if (RE_AT_END.lastIndex === 0) {
                                next = css.length - 1;
                            } else {
                                next = RE_AT_END.lastIndex - 2;
                            }
                            currentToken = [
                                "at-word",
                                css.slice(pos, next + 1),
                                pos,
                                next
                            ];
                            pos = next;
                            break;
                        }
                    case BACKSLASH:
                        {
                            next = pos;
                            escape2 = true;
                            while(css.charCodeAt(next + 1) === BACKSLASH){
                                next += 1;
                                escape2 = !escape2;
                            }
                            code = css.charCodeAt(next + 1);
                            if (escape2 && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
                                next += 1;
                                if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                                    while(RE_HEX_ESCAPE.test(css.charAt(next + 1))){
                                        next += 1;
                                    }
                                    if (css.charCodeAt(next + 1) === SPACE) {
                                        next += 1;
                                    }
                                }
                            }
                            currentToken = [
                                "word",
                                css.slice(pos, next + 1),
                                pos,
                                next
                            ];
                            pos = next;
                            break;
                        }
                    default:
                        {
                            if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
                                next = css.indexOf("*/", pos + 2) + 1;
                                if (next === 0) {
                                    if (ignore || ignoreUnclosed) {
                                        next = css.length;
                                    } else {
                                        unclosed("comment");
                                    }
                                }
                                currentToken = [
                                    "comment",
                                    css.slice(pos, next + 1),
                                    pos,
                                    next
                                ];
                                pos = next;
                            } else {
                                RE_WORD_END.lastIndex = pos + 1;
                                RE_WORD_END.test(css);
                                if (RE_WORD_END.lastIndex === 0) {
                                    next = css.length - 1;
                                } else {
                                    next = RE_WORD_END.lastIndex - 2;
                                }
                                currentToken = [
                                    "word",
                                    css.slice(pos, next + 1),
                                    pos,
                                    next
                                ];
                                buffer.push(currentToken);
                                pos = next;
                            }
                            break;
                        }
                }
                pos++;
                return currentToken;
            }
            function back(token) {
                returned.push(token);
            }
            return {
                back: back,
                endOfFile: endOfFile,
                nextToken: nextToken,
                position: position
            };
        };
    }
});
// node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS({
    "node_modules/postcss/lib/at-rule.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Container2 = require_container();
        var AtRule2 = /*#__PURE__*/ function(Container2) {
            _inherits(AtRule2, Container2);
            var _super = _create_super(AtRule2);
            function AtRule2(defaults) {
                _class_call_check(this, AtRule2);
                var _this;
                _this = _super.call(this, defaults);
                _this.type = "atrule";
                return _this;
            }
            _create_class(AtRule2, [
                {
                    key: "append",
                    value: function append() {
                        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){
                            children[_key] = arguments[_key];
                        }
                        var _$_get;
                        if (!this.proxyOf.nodes) this.nodes = [];
                        return (_$_get = _get(_get_prototype_of(AtRule2.prototype), "append", this)).call.apply(_$_get, [
                            this
                        ].concat(_to_consumable_array(children)));
                    }
                },
                {
                    key: "prepend",
                    value: function prepend() {
                        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){
                            children[_key] = arguments[_key];
                        }
                        var _$_get;
                        if (!this.proxyOf.nodes) this.nodes = [];
                        return (_$_get = _get(_get_prototype_of(AtRule2.prototype), "prepend", this)).call.apply(_$_get, [
                            this
                        ].concat(_to_consumable_array(children)));
                    }
                }
            ]);
            return AtRule2;
        }(Container2);
        module2.exports = AtRule2;
        AtRule2.default = AtRule2;
        Container2.registerAtRule(AtRule2);
    }
});
// node_modules/postcss/lib/root.js
var require_root = __commonJS({
    "node_modules/postcss/lib/root.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Container2 = require_container();
        var LazyResult;
        var Processor2;
        var Root2 = /*#__PURE__*/ function(Container2) {
            _inherits(Root2, Container2);
            var _super = _create_super(Root2);
            function Root2(defaults) {
                _class_call_check(this, Root2);
                var _this;
                _this = _super.call(this, defaults);
                _this.type = "root";
                if (!_this.nodes) _this.nodes = [];
                return _this;
            }
            _create_class(Root2, [
                {
                    key: "normalize",
                    value: function normalize(child, sample, type) {
                        var nodes = _get(_get_prototype_of(Root2.prototype), "normalize", this).call(this, child);
                        if (sample) {
                            if (type === "prepend") {
                                if (this.nodes.length > 1) {
                                    sample.raws.before = this.nodes[1].raws.before;
                                } else {
                                    delete sample.raws.before;
                                }
                            } else if (this.first !== sample) {
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var node = _step.value;
                                        node.raws.before = sample.raws.before;
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            }
                        }
                        return nodes;
                    }
                },
                {
                    key: "removeChild",
                    value: function removeChild(child, ignore) {
                        var index = this.index(child);
                        if (!ignore && index === 0 && this.nodes.length > 1) {
                            this.nodes[1].raws.before = this.nodes[index].raws.before;
                        }
                        return _get(_get_prototype_of(Root2.prototype), "removeChild", this).call(this, child);
                    }
                },
                {
                    key: "toResult",
                    value: function toResult() {
                        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                        var lazy = new LazyResult(new Processor2(), this, opts);
                        return lazy.stringify();
                    }
                }
            ]);
            return Root2;
        }(Container2);
        Root2.registerLazyResult = function(dependant) {
            LazyResult = dependant;
        };
        Root2.registerProcessor = function(dependant) {
            Processor2 = dependant;
        };
        module2.exports = Root2;
        Root2.default = Root2;
        Container2.registerRoot(Root2);
    }
});
// node_modules/postcss/lib/list.js
var require_list = __commonJS({
    "node_modules/postcss/lib/list.js": function(exports, module2) {
        "use strict";
        init_shim();
        var list2 = {
            comma: function comma(string) {
                return list2.split(string, [
                    ","
                ], true);
            },
            space: function space(string) {
                var spaces = [
                    " ",
                    "\n",
                    "	"
                ];
                return list2.split(string, spaces);
            },
            split: function split(string, separators, last) {
                var array = [];
                var current = "";
                var split = false;
                var func = 0;
                var inQuote = false;
                var prevQuote = "";
                var escape2 = false;
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = string[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var letter = _step.value;
                        if (escape2) {
                            escape2 = false;
                        } else if (letter === "\\") {
                            escape2 = true;
                        } else if (inQuote) {
                            if (letter === prevQuote) {
                                inQuote = false;
                            }
                        } else if (letter === '"' || letter === "'") {
                            inQuote = true;
                            prevQuote = letter;
                        } else if (letter === "(") {
                            func += 1;
                        } else if (letter === ")") {
                            if (func > 0) func -= 1;
                        } else if (func === 0) {
                            if (separators.includes(letter)) split = true;
                        }
                        if (split) {
                            if (current !== "") array.push(current.trim());
                            current = "";
                            split = false;
                        } else {
                            current += letter;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                if (last || current !== "") array.push(current.trim());
                return array;
            }
        };
        module2.exports = list2;
        list2.default = list2;
    }
});
// node_modules/postcss/lib/rule.js
var require_rule = __commonJS({
    "node_modules/postcss/lib/rule.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Container2 = require_container();
        var list2 = require_list();
        var Rule2 = /*#__PURE__*/ function(Container2) {
            _inherits(Rule2, Container2);
            var _super = _create_super(Rule2);
            function Rule2(defaults) {
                _class_call_check(this, Rule2);
                var _this;
                _this = _super.call(this, defaults);
                _this.type = "rule";
                if (!_this.nodes) _this.nodes = [];
                return _this;
            }
            _create_class(Rule2, [
                {
                    key: "selectors",
                    get: function get() {
                        return list2.comma(this.selector);
                    },
                    set: function set(values) {
                        var match = this.selector ? this.selector.match(/,\s*/) : null;
                        var sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
                        this.selector = values.join(sep);
                    }
                }
            ]);
            return Rule2;
        }(Container2);
        module2.exports = Rule2;
        Rule2.default = Rule2;
        Container2.registerRule(Rule2);
    }
});
// node_modules/postcss/lib/parser.js
var require_parser = __commonJS({
    "node_modules/postcss/lib/parser.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Declaration2 = require_declaration();
        var tokenizer = require_tokenize();
        var Comment2 = require_comment();
        var AtRule2 = require_at_rule();
        var Root2 = require_root();
        var Rule2 = require_rule();
        var SAFE_COMMENT_NEIGHBOR = {
            empty: true,
            space: true
        };
        function findLastWithPosition(tokens) {
            for(var i2 = tokens.length - 1; i2 >= 0; i2--){
                var token = tokens[i2];
                var pos = token[3] || token[2];
                if (pos) return pos;
            }
        }
        var Parser = /*#__PURE__*/ function() {
            function Parser(input) {
                _class_call_check(this, Parser);
                this.input = input;
                this.root = new Root2();
                this.current = this.root;
                this.spaces = "";
                this.semicolon = false;
                this.createTokenizer();
                this.root.source = {
                    input: input,
                    start: {
                        column: 1,
                        line: 1,
                        offset: 0
                    }
                };
            }
            _create_class(Parser, [
                {
                    key: "atrule",
                    value: function atrule(token) {
                        var node = new AtRule2();
                        node.name = token[1].slice(1);
                        if (node.name === "") {
                            this.unnamedAtrule(node, token);
                        }
                        this.init(node, token[2]);
                        var type;
                        var prev;
                        var shift;
                        var last = false;
                        var open = false;
                        var params = [];
                        var brackets = [];
                        while(!this.tokenizer.endOfFile()){
                            token = this.tokenizer.nextToken();
                            type = token[0];
                            if (type === "(" || type === "[") {
                                brackets.push(type === "(" ? ")" : "]");
                            } else if (type === "{" && brackets.length > 0) {
                                brackets.push("}");
                            } else if (type === brackets[brackets.length - 1]) {
                                brackets.pop();
                            }
                            if (brackets.length === 0) {
                                if (type === ";") {
                                    node.source.end = this.getPosition(token[2]);
                                    node.source.end.offset++;
                                    this.semicolon = true;
                                    break;
                                } else if (type === "{") {
                                    open = true;
                                    break;
                                } else if (type === "}") {
                                    if (params.length > 0) {
                                        shift = params.length - 1;
                                        prev = params[shift];
                                        while(prev && prev[0] === "space"){
                                            prev = params[--shift];
                                        }
                                        if (prev) {
                                            node.source.end = this.getPosition(prev[3] || prev[2]);
                                            node.source.end.offset++;
                                        }
                                    }
                                    this.end(token);
                                    break;
                                } else {
                                    params.push(token);
                                }
                            } else {
                                params.push(token);
                            }
                            if (this.tokenizer.endOfFile()) {
                                last = true;
                                break;
                            }
                        }
                        node.raws.between = this.spacesAndCommentsFromEnd(params);
                        if (params.length) {
                            node.raws.afterName = this.spacesAndCommentsFromStart(params);
                            this.raw(node, "params", params);
                            if (last) {
                                token = params[params.length - 1];
                                node.source.end = this.getPosition(token[3] || token[2]);
                                node.source.end.offset++;
                                this.spaces = node.raws.between;
                                node.raws.between = "";
                            }
                        } else {
                            node.raws.afterName = "";
                            node.params = "";
                        }
                        if (open) {
                            node.nodes = [];
                            this.current = node;
                        }
                    }
                },
                {
                    key: "checkMissedSemicolon",
                    value: function checkMissedSemicolon(tokens) {
                        var colon = this.colon(tokens);
                        if (colon === false) return;
                        var founded = 0;
                        var token;
                        for(var j = colon - 1; j >= 0; j--){
                            token = tokens[j];
                            if (token[0] !== "space") {
                                founded += 1;
                                if (founded === 2) break;
                            }
                        }
                        throw this.input.error("Missed semicolon", token[0] === "word" ? token[3] + 1 : token[2]);
                    }
                },
                {
                    key: "colon",
                    value: function colon(tokens) {
                        var brackets = 0;
                        var token, type, prev;
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = tokens.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var _step_value = _sliced_to_array(_step.value, 2), i2 = _step_value[0], element = _step_value[1];
                                token = element;
                                type = token[0];
                                if (type === "(") {
                                    brackets += 1;
                                }
                                if (type === ")") {
                                    brackets -= 1;
                                }
                                if (brackets === 0 && type === ":") {
                                    if (!prev) {
                                        this.doubleColon(token);
                                    } else if (prev[0] === "word" && prev[1] === "progid") {
                                        continue;
                                    } else {
                                        return i2;
                                    }
                                }
                                prev = token;
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        return false;
                    }
                },
                {
                    key: "comment",
                    value: function comment(token) {
                        var node = new Comment2();
                        this.init(node, token[2]);
                        node.source.end = this.getPosition(token[3] || token[2]);
                        node.source.end.offset++;
                        var text = token[1].slice(2, -2);
                        if (/^\s*$/.test(text)) {
                            node.text = "";
                            node.raws.left = text;
                            node.raws.right = "";
                        } else {
                            var match = text.match(/^(\s*)([^]*\S)(\s*)$/);
                            node.text = match[2];
                            node.raws.left = match[1];
                            node.raws.right = match[3];
                        }
                    }
                },
                {
                    key: "createTokenizer",
                    value: function createTokenizer() {
                        this.tokenizer = tokenizer(this.input);
                    }
                },
                {
                    key: "decl",
                    value: function decl(tokens, customProperty) {
                        var node = new Declaration2();
                        this.init(node, tokens[0][2]);
                        var last = tokens[tokens.length - 1];
                        if (last[0] === ";") {
                            this.semicolon = true;
                            tokens.pop();
                        }
                        node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));
                        node.source.end.offset++;
                        while(tokens[0][0] !== "word"){
                            if (tokens.length === 1) this.unknownWord(tokens);
                            node.raws.before += tokens.shift()[1];
                        }
                        node.source.start = this.getPosition(tokens[0][2]);
                        node.prop = "";
                        while(tokens.length){
                            var type = tokens[0][0];
                            if (type === ":" || type === "space" || type === "comment") {
                                break;
                            }
                            node.prop += tokens.shift()[1];
                        }
                        node.raws.between = "";
                        var token;
                        while(tokens.length){
                            token = tokens.shift();
                            if (token[0] === ":") {
                                node.raws.between += token[1];
                                break;
                            } else {
                                if (token[0] === "word" && /\w/.test(token[1])) {
                                    this.unknownWord([
                                        token
                                    ]);
                                }
                                node.raws.between += token[1];
                            }
                        }
                        if (node.prop[0] === "_" || node.prop[0] === "*") {
                            node.raws.before += node.prop[0];
                            node.prop = node.prop.slice(1);
                        }
                        var firstSpaces = [];
                        var next;
                        while(tokens.length){
                            next = tokens[0][0];
                            if (next !== "space" && next !== "comment") break;
                            firstSpaces.push(tokens.shift());
                        }
                        this.precheckMissedSemicolon(tokens);
                        for(var i2 = tokens.length - 1; i2 >= 0; i2--){
                            token = tokens[i2];
                            if (token[1].toLowerCase() === "!important") {
                                node.important = true;
                                var string = this.stringFrom(tokens, i2);
                                string = this.spacesFromEnd(tokens) + string;
                                if (string !== " !important") node.raws.important = string;
                                break;
                            } else if (token[1].toLowerCase() === "important") {
                                var cache = tokens.slice(0);
                                var str = "";
                                for(var j = i2; j > 0; j--){
                                    var type1 = cache[j][0];
                                    if (str.trim().indexOf("!") === 0 && type1 !== "space") {
                                        break;
                                    }
                                    str = cache.pop()[1] + str;
                                }
                                if (str.trim().indexOf("!") === 0) {
                                    node.important = true;
                                    node.raws.important = str;
                                    tokens = cache;
                                }
                            }
                            if (token[0] !== "space" && token[0] !== "comment") {
                                break;
                            }
                        }
                        var hasWord = tokens.some(function(i2) {
                            return i2[0] !== "space" && i2[0] !== "comment";
                        });
                        if (hasWord) {
                            node.raws.between += firstSpaces.map(function(i2) {
                                return i2[1];
                            }).join("");
                            firstSpaces = [];
                        }
                        this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
                        if (node.value.includes(":") && !customProperty) {
                            this.checkMissedSemicolon(tokens);
                        }
                    }
                },
                {
                    key: "doubleColon",
                    value: function doubleColon(token) {
                        throw this.input.error("Double colon", {
                            offset: token[2]
                        }, {
                            offset: token[2] + token[1].length
                        });
                    }
                },
                {
                    key: "emptyRule",
                    value: function emptyRule(token) {
                        var node = new Rule2();
                        this.init(node, token[2]);
                        node.selector = "";
                        node.raws.between = "";
                        this.current = node;
                    }
                },
                {
                    key: "end",
                    value: function end(token) {
                        if (this.current.nodes && this.current.nodes.length) {
                            this.current.raws.semicolon = this.semicolon;
                        }
                        this.semicolon = false;
                        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
                        this.spaces = "";
                        if (this.current.parent) {
                            this.current.source.end = this.getPosition(token[2]);
                            this.current.source.end.offset++;
                            this.current = this.current.parent;
                        } else {
                            this.unexpectedClose(token);
                        }
                    }
                },
                {
                    key: "endFile",
                    value: function endFile() {
                        if (this.current.parent) this.unclosedBlock();
                        if (this.current.nodes && this.current.nodes.length) {
                            this.current.raws.semicolon = this.semicolon;
                        }
                        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
                        this.root.source.end = this.getPosition(this.tokenizer.position());
                    }
                },
                {
                    key: "freeSemicolon",
                    value: function freeSemicolon(token) {
                        this.spaces += token[1];
                        if (this.current.nodes) {
                            var prev = this.current.nodes[this.current.nodes.length - 1];
                            if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
                                prev.raws.ownSemicolon = this.spaces;
                                this.spaces = "";
                            }
                        }
                    }
                },
                {
                    // Helpers
                    key: "getPosition",
                    value: function getPosition(offset) {
                        var pos = this.input.fromOffset(offset);
                        return {
                            column: pos.col,
                            line: pos.line,
                            offset: offset
                        };
                    }
                },
                {
                    key: "init",
                    value: function init(node, offset) {
                        this.current.push(node);
                        node.source = {
                            input: this.input,
                            start: this.getPosition(offset)
                        };
                        node.raws.before = this.spaces;
                        this.spaces = "";
                        if (node.type !== "comment") this.semicolon = false;
                    }
                },
                {
                    key: "other",
                    value: function other(start) {
                        var end = false;
                        var type = null;
                        var colon = false;
                        var bracket = null;
                        var brackets = [];
                        var customProperty = start[1].startsWith("--");
                        var tokens = [];
                        var token = start;
                        while(token){
                            type = token[0];
                            tokens.push(token);
                            if (type === "(" || type === "[") {
                                if (!bracket) bracket = token;
                                brackets.push(type === "(" ? ")" : "]");
                            } else if (customProperty && colon && type === "{") {
                                if (!bracket) bracket = token;
                                brackets.push("}");
                            } else if (brackets.length === 0) {
                                if (type === ";") {
                                    if (colon) {
                                        this.decl(tokens, customProperty);
                                        return;
                                    } else {
                                        break;
                                    }
                                } else if (type === "{") {
                                    this.rule(tokens);
                                    return;
                                } else if (type === "}") {
                                    this.tokenizer.back(tokens.pop());
                                    end = true;
                                    break;
                                } else if (type === ":") {
                                    colon = true;
                                }
                            } else if (type === brackets[brackets.length - 1]) {
                                brackets.pop();
                                if (brackets.length === 0) bracket = null;
                            }
                            token = this.tokenizer.nextToken();
                        }
                        if (this.tokenizer.endOfFile()) end = true;
                        if (brackets.length > 0) this.unclosedBracket(bracket);
                        if (end && colon) {
                            if (!customProperty) {
                                while(tokens.length){
                                    token = tokens[tokens.length - 1][0];
                                    if (token !== "space" && token !== "comment") break;
                                    this.tokenizer.back(tokens.pop());
                                }
                            }
                            this.decl(tokens, customProperty);
                        } else {
                            this.unknownWord(tokens);
                        }
                    }
                },
                {
                    key: "parse",
                    value: function parse() {
                        var token;
                        while(!this.tokenizer.endOfFile()){
                            token = this.tokenizer.nextToken();
                            switch(token[0]){
                                case "space":
                                    this.spaces += token[1];
                                    break;
                                case ";":
                                    this.freeSemicolon(token);
                                    break;
                                case "}":
                                    this.end(token);
                                    break;
                                case "comment":
                                    this.comment(token);
                                    break;
                                case "at-word":
                                    this.atrule(token);
                                    break;
                                case "{":
                                    this.emptyRule(token);
                                    break;
                                default:
                                    this.other(token);
                                    break;
                            }
                        }
                        this.endFile();
                    }
                },
                {
                    key: "precheckMissedSemicolon",
                    value: function precheckMissedSemicolon() {}
                },
                {
                    key: "raw",
                    value: function raw(node, prop, tokens, customProperty) {
                        var token, type;
                        var length = tokens.length;
                        var value = "";
                        var clean = true;
                        var next, prev;
                        for(var i2 = 0; i2 < length; i2 += 1){
                            token = tokens[i2];
                            type = token[0];
                            if (type === "space" && i2 === length - 1 && !customProperty) {
                                clean = false;
                            } else if (type === "comment") {
                                prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : "empty";
                                next = tokens[i2 + 1] ? tokens[i2 + 1][0] : "empty";
                                if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
                                    if (value.slice(-1) === ",") {
                                        clean = false;
                                    } else {
                                        value += token[1];
                                    }
                                } else {
                                    clean = false;
                                }
                            } else {
                                value += token[1];
                            }
                        }
                        if (!clean) {
                            var raw = tokens.reduce(function(all, i2) {
                                return all + i2[1];
                            }, "");
                            node.raws[prop] = {
                                raw: raw,
                                value: value
                            };
                        }
                        node[prop] = value;
                    }
                },
                {
                    key: "rule",
                    value: function rule(tokens) {
                        tokens.pop();
                        var node = new Rule2();
                        this.init(node, tokens[0][2]);
                        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
                        this.raw(node, "selector", tokens);
                        this.current = node;
                    }
                },
                {
                    key: "spacesAndCommentsFromEnd",
                    value: function spacesAndCommentsFromEnd(tokens) {
                        var lastTokenType;
                        var spaces = "";
                        while(tokens.length){
                            lastTokenType = tokens[tokens.length - 1][0];
                            if (lastTokenType !== "space" && lastTokenType !== "comment") break;
                            spaces = tokens.pop()[1] + spaces;
                        }
                        return spaces;
                    }
                },
                {
                    // Errors
                    key: "spacesAndCommentsFromStart",
                    value: function spacesAndCommentsFromStart(tokens) {
                        var next;
                        var spaces = "";
                        while(tokens.length){
                            next = tokens[0][0];
                            if (next !== "space" && next !== "comment") break;
                            spaces += tokens.shift()[1];
                        }
                        return spaces;
                    }
                },
                {
                    key: "spacesFromEnd",
                    value: function spacesFromEnd(tokens) {
                        var lastTokenType;
                        var spaces = "";
                        while(tokens.length){
                            lastTokenType = tokens[tokens.length - 1][0];
                            if (lastTokenType !== "space") break;
                            spaces = tokens.pop()[1] + spaces;
                        }
                        return spaces;
                    }
                },
                {
                    key: "stringFrom",
                    value: function stringFrom(tokens, from) {
                        var result = "";
                        for(var i2 = from; i2 < tokens.length; i2++){
                            result += tokens[i2][1];
                        }
                        tokens.splice(from, tokens.length - from);
                        return result;
                    }
                },
                {
                    key: "unclosedBlock",
                    value: function unclosedBlock() {
                        var pos = this.current.source.start;
                        throw this.input.error("Unclosed block", pos.line, pos.column);
                    }
                },
                {
                    key: "unclosedBracket",
                    value: function unclosedBracket(bracket) {
                        throw this.input.error("Unclosed bracket", {
                            offset: bracket[2]
                        }, {
                            offset: bracket[2] + 1
                        });
                    }
                },
                {
                    key: "unexpectedClose",
                    value: function unexpectedClose(token) {
                        throw this.input.error("Unexpected }", {
                            offset: token[2]
                        }, {
                            offset: token[2] + 1
                        });
                    }
                },
                {
                    key: "unknownWord",
                    value: function unknownWord(tokens) {
                        throw this.input.error("Unknown word", {
                            offset: tokens[0][2]
                        }, {
                            offset: tokens[0][2] + tokens[0][1].length
                        });
                    }
                },
                {
                    key: "unnamedAtrule",
                    value: function unnamedAtrule(node, token) {
                        throw this.input.error("At-rule without name", {
                            offset: token[2]
                        }, {
                            offset: token[2] + token[1].length
                        });
                    }
                }
            ]);
            return Parser;
        }();
        module2.exports = Parser;
    }
});
// node_modules/postcss/lib/parse.js
var require_parse = __commonJS({
    "node_modules/postcss/lib/parse.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Container2 = require_container();
        var Parser = require_parser();
        var Input2 = require_input();
        function parse5(css, opts) {
            var input = new Input2(css, opts);
            var parser = new Parser(input);
            try {
                parser.parse();
            } catch (e2) {
                if (import_process.default.env.NODE_ENV !== "production") {
                    if (e2.name === "CssSyntaxError" && opts && opts.from) {
                        if (/\.scss$/i.test(opts.from)) {
                            e2.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
                        } else if (/\.sass/i.test(opts.from)) {
                            e2.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
                        } else if (/\.less$/i.test(opts.from)) {
                            e2.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
                        }
                    }
                }
                throw e2;
            }
            return parser.root;
        }
        module2.exports = parse5;
        parse5.default = parse5;
        Container2.registerParse(parse5);
    }
});
// node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS({
    "node_modules/postcss/lib/lazy-result.js": function(exports, module2) {
        "use strict";
        init_shim();
        var _require_symbols = require_symbols(), isClean = _require_symbols.isClean, my = _require_symbols.my;
        var MapGenerator = require_map_generator();
        var stringify4 = require_stringify();
        var Container2 = require_container();
        var Document2 = require_document();
        var warnOnce = require_warn_once();
        var Result2 = require_result();
        var parse5 = require_parse();
        var Root2 = require_root();
        var TYPE_TO_CLASS_NAME = {
            atrule: "AtRule",
            comment: "Comment",
            decl: "Declaration",
            document: "Document",
            root: "Root",
            rule: "Rule"
        };
        var PLUGIN_PROPS = {
            AtRule: true,
            AtRuleExit: true,
            Comment: true,
            CommentExit: true,
            Declaration: true,
            DeclarationExit: true,
            Document: true,
            DocumentExit: true,
            Once: true,
            OnceExit: true,
            postcssPlugin: true,
            prepare: true,
            Root: true,
            RootExit: true,
            Rule: true,
            RuleExit: true
        };
        var NOT_VISITORS = {
            Once: true,
            postcssPlugin: true,
            prepare: true
        };
        var CHILDREN = 0;
        function isPromise(obj) {
            return typeof obj === "object" && typeof obj.then === "function";
        }
        function getEvents(node) {
            var key = false;
            var type = TYPE_TO_CLASS_NAME[node.type];
            if (node.type === "decl") {
                key = node.prop.toLowerCase();
            } else if (node.type === "atrule") {
                key = node.name.toLowerCase();
            }
            if (key && node.append) {
                return [
                    type,
                    type + "-" + key,
                    CHILDREN,
                    type + "Exit",
                    type + "Exit-" + key
                ];
            } else if (key) {
                return [
                    type,
                    type + "-" + key,
                    type + "Exit",
                    type + "Exit-" + key
                ];
            } else if (node.append) {
                return [
                    type,
                    CHILDREN,
                    type + "Exit"
                ];
            } else {
                return [
                    type,
                    type + "Exit"
                ];
            }
        }
        function toStack(node) {
            var events;
            if (node.type === "document") {
                events = [
                    "Document",
                    CHILDREN,
                    "DocumentExit"
                ];
            } else if (node.type === "root") {
                events = [
                    "Root",
                    CHILDREN,
                    "RootExit"
                ];
            } else {
                events = getEvents(node);
            }
            return {
                eventIndex: 0,
                events: events,
                iterator: 0,
                node: node,
                visitorIndex: 0,
                visitors: []
            };
        }
        function cleanMarks(node) {
            node[isClean] = false;
            if (node.nodes) node.nodes.forEach(function(i2) {
                return cleanMarks(i2);
            });
            return node;
        }
        var postcss2 = {};
        var LazyResult = /*#__PURE__*/ function() {
            function _LazyResult(processor, css, opts) {
                var _this = this;
                _class_call_check(this, _LazyResult);
                this.stringified = false;
                this.processed = false;
                var root2;
                if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
                    root2 = cleanMarks(css);
                } else if (_instanceof(css, _LazyResult) || _instanceof(css, Result2)) {
                    root2 = cleanMarks(css.root);
                    if (css.map) {
                        if (typeof opts.map === "undefined") opts.map = {};
                        if (!opts.map.inline) opts.map.inline = false;
                        opts.map.prev = css.map;
                    }
                } else {
                    var parser = parse5;
                    if (opts.syntax) parser = opts.syntax.parse;
                    if (opts.parser) parser = opts.parser;
                    if (parser.parse) parser = parser.parse;
                    try {
                        root2 = parser(css, opts);
                    } catch (error) {
                        this.processed = true;
                        this.error = error;
                    }
                    if (root2 && !root2[my]) {
                        Container2.rebuild(root2);
                    }
                }
                this.result = new Result2(processor, root2, opts);
                this.helpers = _object_spread_props(_object_spread({}, postcss2), {
                    postcss: postcss2,
                    result: this.result
                });
                this.plugins = this.processor.plugins.map(function(plugin2) {
                    if (typeof plugin2 === "object" && plugin2.prepare) {
                        return _object_spread({}, plugin2, plugin2.prepare(_this.result));
                    } else {
                        return plugin2;
                    }
                });
            }
            _create_class(_LazyResult, [
                {
                    key: "async",
                    value: function async() {
                        if (this.error) return Promise.reject(this.error);
                        if (this.processed) return Promise.resolve(this.result);
                        if (!this.processing) {
                            this.processing = this.runAsync();
                        }
                        return this.processing;
                    }
                },
                {
                    key: "catch",
                    value: function _catch(onRejected) {
                        return this.async().catch(onRejected);
                    }
                },
                {
                    key: "finally",
                    value: function _finally(onFinally) {
                        return this.async().then(onFinally, onFinally);
                    }
                },
                {
                    key: "getAsyncError",
                    value: function getAsyncError() {
                        throw new Error("Use process(css).then(cb) to work with async plugins");
                    }
                },
                {
                    key: "handleError",
                    value: function handleError(error, node) {
                        var plugin2 = this.result.lastPlugin;
                        try {
                            if (node) node.addToError(error);
                            this.error = error;
                            if (error.name === "CssSyntaxError" && !error.plugin) {
                                error.plugin = plugin2.postcssPlugin;
                                error.setMessage();
                            } else if (plugin2.postcssVersion) {
                                if (import_process.default.env.NODE_ENV !== "production") {
                                    var pluginName = plugin2.postcssPlugin;
                                    var pluginVer = plugin2.postcssVersion;
                                    var runtimeVer = this.result.processor.version;
                                    var a = pluginVer.split(".");
                                    var b = runtimeVer.split(".");
                                    if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                                        console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
                                    }
                                }
                            }
                        } catch (err) {
                            if (console && console.error) console.error(err);
                        }
                        return error;
                    }
                },
                {
                    key: "prepareVisitors",
                    value: function prepareVisitors() {
                        var _this = this;
                        this.listeners = {};
                        var add = function(plugin2, type, cb) {
                            if (!_this.listeners[type]) _this.listeners[type] = [];
                            _this.listeners[type].push([
                                plugin2,
                                cb
                            ]);
                        };
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = this.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var plugin2 = _step.value;
                                if (typeof plugin2 === "object") {
                                    for(var event in plugin2){
                                        if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                                            throw new Error("Unknown event ".concat(event, " in ").concat(plugin2.postcssPlugin, ". Try to update PostCSS (").concat(this.processor.version, " now)."));
                                        }
                                        if (!NOT_VISITORS[event]) {
                                            if (typeof plugin2[event] === "object") {
                                                for(var filter2 in plugin2[event]){
                                                    if (filter2 === "*") {
                                                        add(plugin2, event, plugin2[event][filter2]);
                                                    } else {
                                                        add(plugin2, event + "-" + filter2.toLowerCase(), plugin2[event][filter2]);
                                                    }
                                                }
                                            } else if (typeof plugin2[event] === "function") {
                                                add(plugin2, event, plugin2[event]);
                                            }
                                        }
                                    }
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        this.hasListener = Object.keys(this.listeners).length > 0;
                    }
                },
                {
                    key: "runAsync",
                    value: function runAsync() {
                        var _this = this;
                        return _async_to_generator(function() {
                            var i2, plugin2, promise, error, root2, stack, promise1, e2, node, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step, err;
                            return _ts_generator(this, function(_state) {
                                switch(_state.label){
                                    case 0:
                                        _this.plugin = 0;
                                        i2 = 0;
                                        _state.label = 1;
                                    case 1:
                                        if (!(i2 < _this.plugins.length)) return [
                                            3,
                                            6
                                        ];
                                        plugin2 = _this.plugins[i2];
                                        promise = _this.runOnRoot(plugin2);
                                        if (!isPromise(promise)) return [
                                            3,
                                            5
                                        ];
                                        _state.label = 2;
                                    case 2:
                                        _state.trys.push([
                                            2,
                                            4,
                                            ,
                                            5
                                        ]);
                                        return [
                                            4,
                                            promise
                                        ];
                                    case 3:
                                        _state.sent();
                                        return [
                                            3,
                                            5
                                        ];
                                    case 4:
                                        error = _state.sent();
                                        throw _this.handleError(error);
                                    case 5:
                                        i2++;
                                        return [
                                            3,
                                            1
                                        ];
                                    case 6:
                                        _this.prepareVisitors();
                                        if (!_this.hasListener) return [
                                            3,
                                            22
                                        ];
                                        root2 = _this.result.root;
                                        _state.label = 7;
                                    case 7:
                                        if (!!root2[isClean]) return [
                                            3,
                                            14
                                        ];
                                        root2[isClean] = true;
                                        stack = [
                                            toStack(root2)
                                        ];
                                        _state.label = 8;
                                    case 8:
                                        if (!(stack.length > 0)) return [
                                            3,
                                            13
                                        ];
                                        promise1 = _this.visitTick(stack);
                                        if (!isPromise(promise1)) return [
                                            3,
                                            12
                                        ];
                                        _state.label = 9;
                                    case 9:
                                        _state.trys.push([
                                            9,
                                            11,
                                            ,
                                            12
                                        ]);
                                        return [
                                            4,
                                            promise1
                                        ];
                                    case 10:
                                        _state.sent();
                                        return [
                                            3,
                                            12
                                        ];
                                    case 11:
                                        e2 = _state.sent();
                                        node = stack[stack.length - 1].node;
                                        throw _this.handleError(e2, node);
                                    case 12:
                                        return [
                                            3,
                                            8
                                        ];
                                    case 13:
                                        return [
                                            3,
                                            7
                                        ];
                                    case 14:
                                        if (!_this.listeners.OnceExit) return [
                                            3,
                                            22
                                        ];
                                        _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                        _state.label = 15;
                                    case 15:
                                        _state.trys.push([
                                            15,
                                            20,
                                            21,
                                            22
                                        ]);
                                        _loop = function() {
                                            var _step_value, plugin2, visitor, roots, e2;
                                            return _ts_generator(this, function(_state) {
                                                switch(_state.label){
                                                    case 0:
                                                        _step_value = _sliced_to_array(_step.value, 2), plugin2 = _step_value[0], visitor = _step_value[1];
                                                        _this.result.lastPlugin = plugin2;
                                                        _state.label = 1;
                                                    case 1:
                                                        _state.trys.push([
                                                            1,
                                                            6,
                                                            ,
                                                            7
                                                        ]);
                                                        if (!(root2.type === "document")) return [
                                                            3,
                                                            3
                                                        ];
                                                        roots = root2.nodes.map(function(subRoot) {
                                                            return visitor(subRoot, _this.helpers);
                                                        });
                                                        return [
                                                            4,
                                                            Promise.all(roots)
                                                        ];
                                                    case 2:
                                                        _state.sent();
                                                        return [
                                                            3,
                                                            5
                                                        ];
                                                    case 3:
                                                        return [
                                                            4,
                                                            visitor(root2, _this.helpers)
                                                        ];
                                                    case 4:
                                                        _state.sent();
                                                        _state.label = 5;
                                                    case 5:
                                                        return [
                                                            3,
                                                            7
                                                        ];
                                                    case 6:
                                                        e2 = _state.sent();
                                                        throw _this.handleError(e2);
                                                    case 7:
                                                        return [
                                                            2
                                                        ];
                                                }
                                            });
                                        };
                                        _iterator = _this.listeners.OnceExit[Symbol.iterator]();
                                        _state.label = 16;
                                    case 16:
                                        if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [
                                            3,
                                            19
                                        ];
                                        return [
                                            5,
                                            _ts_values(_loop())
                                        ];
                                    case 17:
                                        _state.sent();
                                        _state.label = 18;
                                    case 18:
                                        _iteratorNormalCompletion = true;
                                        return [
                                            3,
                                            16
                                        ];
                                    case 19:
                                        return [
                                            3,
                                            22
                                        ];
                                    case 20:
                                        err = _state.sent();
                                        _didIteratorError = true;
                                        _iteratorError = err;
                                        return [
                                            3,
                                            22
                                        ];
                                    case 21:
                                        try {
                                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                                _iterator.return();
                                            }
                                        } finally{
                                            if (_didIteratorError) {
                                                throw _iteratorError;
                                            }
                                        }
                                        return [
                                            7
                                        ];
                                    case 22:
                                        _this.processed = true;
                                        return [
                                            2,
                                            _this.stringify()
                                        ];
                                }
                            });
                        })();
                    }
                },
                {
                    key: "runOnRoot",
                    value: function runOnRoot(plugin2) {
                        var _this = this;
                        this.result.lastPlugin = plugin2;
                        try {
                            if (typeof plugin2 === "object" && plugin2.Once) {
                                if (this.result.root.type === "document") {
                                    var roots = this.result.root.nodes.map(function(root2) {
                                        return plugin2.Once(root2, _this.helpers);
                                    });
                                    if (isPromise(roots[0])) {
                                        return Promise.all(roots);
                                    }
                                    return roots;
                                }
                                return plugin2.Once(this.result.root, this.helpers);
                            } else if (typeof plugin2 === "function") {
                                return plugin2(this.result.root, this.result);
                            }
                        } catch (error) {
                            throw this.handleError(error);
                        }
                    }
                },
                {
                    key: "stringify",
                    value: function stringify() {
                        if (this.error) throw this.error;
                        if (this.stringified) return this.result;
                        this.stringified = true;
                        this.sync();
                        var opts = this.result.opts;
                        var str = stringify4;
                        if (opts.syntax) str = opts.syntax.stringify;
                        if (opts.stringifier) str = opts.stringifier;
                        if (str.stringify) str = str.stringify;
                        var map = new MapGenerator(str, this.result.root, this.result.opts);
                        var data = map.generate();
                        this.result.css = data[0];
                        this.result.map = data[1];
                        return this.result;
                    }
                },
                {
                    key: "sync",
                    value: function sync() {
                        if (this.error) throw this.error;
                        if (this.processed) return this.result;
                        this.processed = true;
                        if (this.processing) {
                            throw this.getAsyncError();
                        }
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = this.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var plugin2 = _step.value;
                                var promise = this.runOnRoot(plugin2);
                                if (isPromise(promise)) {
                                    throw this.getAsyncError();
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        this.prepareVisitors();
                        if (this.hasListener) {
                            var root2 = this.result.root;
                            while(!root2[isClean]){
                                root2[isClean] = true;
                                this.walkSync(root2);
                            }
                            if (this.listeners.OnceExit) {
                                if (root2.type === "document") {
                                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                    try {
                                        for(var _iterator1 = root2.nodes[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                            var subRoot = _step1.value;
                                            this.visitSync(this.listeners.OnceExit, subRoot);
                                        }
                                    } catch (err) {
                                        _didIteratorError1 = true;
                                        _iteratorError1 = err;
                                    } finally{
                                        try {
                                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                                _iterator1.return();
                                            }
                                        } finally{
                                            if (_didIteratorError1) {
                                                throw _iteratorError1;
                                            }
                                        }
                                    }
                                } else {
                                    this.visitSync(this.listeners.OnceExit, root2);
                                }
                            }
                        }
                        return this.result;
                    }
                },
                {
                    key: "then",
                    value: function then(onFulfilled, onRejected) {
                        if (import_process.default.env.NODE_ENV !== "production") {
                            if (!("from" in this.opts)) {
                                warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
                            }
                        }
                        return this.async().then(onFulfilled, onRejected);
                    }
                },
                {
                    key: "toString",
                    value: function toString() {
                        return this.css;
                    }
                },
                {
                    key: "visitSync",
                    value: function visitSync(visitors, node) {
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = visitors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var _step_value = _sliced_to_array(_step.value, 2), plugin2 = _step_value[0], visitor = _step_value[1];
                                this.result.lastPlugin = plugin2;
                                var promise = void 0;
                                try {
                                    promise = visitor(node, this.helpers);
                                } catch (e2) {
                                    throw this.handleError(e2, node.proxyOf);
                                }
                                if (node.type !== "root" && node.type !== "document" && !node.parent) {
                                    return true;
                                }
                                if (isPromise(promise)) {
                                    throw this.getAsyncError();
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                },
                {
                    key: "visitTick",
                    value: function visitTick(stack) {
                        var visit = stack[stack.length - 1];
                        var node = visit.node, visitors = visit.visitors;
                        if (node.type !== "root" && node.type !== "document" && !node.parent) {
                            stack.pop();
                            return;
                        }
                        if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
                            var _visitors_visit_visitorIndex = _sliced_to_array(visitors[visit.visitorIndex], 2), plugin2 = _visitors_visit_visitorIndex[0], visitor = _visitors_visit_visitorIndex[1];
                            visit.visitorIndex += 1;
                            if (visit.visitorIndex === visitors.length) {
                                visit.visitors = [];
                                visit.visitorIndex = 0;
                            }
                            this.result.lastPlugin = plugin2;
                            try {
                                return visitor(node.toProxy(), this.helpers);
                            } catch (e2) {
                                throw this.handleError(e2, node);
                            }
                        }
                        if (visit.iterator !== 0) {
                            var iterator = visit.iterator;
                            var child;
                            while(child = node.nodes[node.indexes[iterator]]){
                                node.indexes[iterator] += 1;
                                if (!child[isClean]) {
                                    child[isClean] = true;
                                    stack.push(toStack(child));
                                    return;
                                }
                            }
                            visit.iterator = 0;
                            delete node.indexes[iterator];
                        }
                        var events = visit.events;
                        while(visit.eventIndex < events.length){
                            var event = events[visit.eventIndex];
                            visit.eventIndex += 1;
                            if (event === CHILDREN) {
                                if (node.nodes && node.nodes.length) {
                                    node[isClean] = true;
                                    visit.iterator = node.getIterator();
                                }
                                return;
                            } else if (this.listeners[event]) {
                                visit.visitors = this.listeners[event];
                                return;
                            }
                        }
                        stack.pop();
                    }
                },
                {
                    key: "walkSync",
                    value: function walkSync(node) {
                        var _this = this;
                        node[isClean] = true;
                        var events = getEvents(node);
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var event = _step.value;
                                if (event === CHILDREN) {
                                    if (node.nodes) {
                                        node.each(function(child) {
                                            if (!child[isClean]) _this.walkSync(child);
                                        });
                                    }
                                } else {
                                    var visitors = this.listeners[event];
                                    if (visitors) {
                                        if (this.visitSync(visitors, node.toProxy())) return;
                                    }
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                },
                {
                    key: "warnings",
                    value: function warnings() {
                        return this.sync().warnings();
                    }
                },
                {
                    key: "content",
                    get: function get() {
                        return this.stringify().content;
                    }
                },
                {
                    key: "css",
                    get: function get() {
                        return this.stringify().css;
                    }
                },
                {
                    key: "map",
                    get: function get() {
                        return this.stringify().map;
                    }
                },
                {
                    key: "messages",
                    get: function get() {
                        return this.sync().messages;
                    }
                },
                {
                    key: "opts",
                    get: function get() {
                        return this.result.opts;
                    }
                },
                {
                    key: "processor",
                    get: function get() {
                        return this.result.processor;
                    }
                },
                {
                    key: "root",
                    get: function get() {
                        return this.sync().root;
                    }
                },
                {
                    key: Symbol.toStringTag,
                    get: function get() {
                        return "LazyResult";
                    }
                }
            ]);
            return _LazyResult;
        }();
        LazyResult.registerPostcss = function(dependant) {
            postcss2 = dependant;
        };
        module2.exports = LazyResult;
        LazyResult.default = LazyResult;
        Root2.registerLazyResult(LazyResult);
        Document2.registerLazyResult(LazyResult);
    }
});
// node_modules/postcss/lib/no-work-result.js
var require_no_work_result = __commonJS({
    "node_modules/postcss/lib/no-work-result.js": function(exports, module2) {
        "use strict";
        init_shim();
        var MapGenerator = require_map_generator();
        var stringify4 = require_stringify();
        var warnOnce = require_warn_once();
        var parse5 = require_parse();
        var Result2 = require_result();
        var NoWorkResult = /*#__PURE__*/ function() {
            function NoWorkResult(processor, css, opts) {
                _class_call_check(this, NoWorkResult);
                css = css.toString();
                this.stringified = false;
                this._processor = processor;
                this._css = css;
                this._opts = opts;
                this._map = void 0;
                var root2;
                var str = stringify4;
                this.result = new Result2(this._processor, root2, this._opts);
                this.result.css = css;
                var self2 = this;
                Object.defineProperty(this.result, "root", {
                    get: function get() {
                        return self2.root;
                    }
                });
                var map = new MapGenerator(str, root2, this._opts, css);
                if (map.isMap()) {
                    var _map_generate = _sliced_to_array(map.generate(), 2), generatedCSS = _map_generate[0], generatedMap = _map_generate[1];
                    if (generatedCSS) {
                        this.result.css = generatedCSS;
                    }
                    if (generatedMap) {
                        this.result.map = generatedMap;
                    }
                } else {
                    map.clearAnnotation();
                    this.result.css = map.css;
                }
            }
            _create_class(NoWorkResult, [
                {
                    key: "async",
                    value: function async() {
                        if (this.error) return Promise.reject(this.error);
                        return Promise.resolve(this.result);
                    }
                },
                {
                    key: "catch",
                    value: function _catch(onRejected) {
                        return this.async().catch(onRejected);
                    }
                },
                {
                    key: "finally",
                    value: function _finally(onFinally) {
                        return this.async().then(onFinally, onFinally);
                    }
                },
                {
                    key: "sync",
                    value: function sync() {
                        if (this.error) throw this.error;
                        return this.result;
                    }
                },
                {
                    key: "then",
                    value: function then(onFulfilled, onRejected) {
                        if (import_process.default.env.NODE_ENV !== "production") {
                            if (!("from" in this._opts)) {
                                warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
                            }
                        }
                        return this.async().then(onFulfilled, onRejected);
                    }
                },
                {
                    key: "toString",
                    value: function toString() {
                        return this._css;
                    }
                },
                {
                    key: "warnings",
                    value: function warnings() {
                        return [];
                    }
                },
                {
                    key: "content",
                    get: function get() {
                        return this.result.css;
                    }
                },
                {
                    key: "css",
                    get: function get() {
                        return this.result.css;
                    }
                },
                {
                    key: "map",
                    get: function get() {
                        return this.result.map;
                    }
                },
                {
                    key: "messages",
                    get: function get() {
                        return [];
                    }
                },
                {
                    key: "opts",
                    get: function get() {
                        return this.result.opts;
                    }
                },
                {
                    key: "processor",
                    get: function get() {
                        return this.result.processor;
                    }
                },
                {
                    key: "root",
                    get: function get() {
                        if (this._root) {
                            return this._root;
                        }
                        var root2;
                        var parser = parse5;
                        try {
                            root2 = parser(this._css, this._opts);
                        } catch (error) {
                            this.error = error;
                        }
                        if (this.error) {
                            throw this.error;
                        } else {
                            this._root = root2;
                            return root2;
                        }
                    }
                },
                {
                    key: Symbol.toStringTag,
                    get: function get() {
                        return "NoWorkResult";
                    }
                }
            ]);
            return NoWorkResult;
        }();
        module2.exports = NoWorkResult;
        NoWorkResult.default = NoWorkResult;
    }
});
// node_modules/postcss/lib/processor.js
var require_processor = __commonJS({
    "node_modules/postcss/lib/processor.js": function(exports, module2) {
        "use strict";
        init_shim();
        var NoWorkResult = require_no_work_result();
        var LazyResult = require_lazy_result();
        var Document2 = require_document();
        var Root2 = require_root();
        var Processor2 = /*#__PURE__*/ function() {
            function Processor2() {
                var plugins = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                _class_call_check(this, Processor2);
                this.version = "8.4.35";
                this.plugins = this.normalize(plugins);
            }
            _create_class(Processor2, [
                {
                    key: "normalize",
                    value: function normalize(plugins) {
                        var normalized = [];
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var i2 = _step.value;
                                if (i2.postcss === true) {
                                    i2 = i2();
                                } else if (i2.postcss) {
                                    i2 = i2.postcss;
                                }
                                if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
                                    normalized = normalized.concat(i2.plugins);
                                } else if (typeof i2 === "object" && i2.postcssPlugin) {
                                    normalized.push(i2);
                                } else if (typeof i2 === "function") {
                                    normalized.push(i2);
                                } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
                                    if (import_process.default.env.NODE_ENV !== "production") {
                                        throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
                                    }
                                } else {
                                    throw new Error(i2 + " is not a PostCSS plugin");
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        return normalized;
                    }
                },
                {
                    key: "process",
                    value: function process(css) {
                        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
                            return new NoWorkResult(this, css, opts);
                        } else {
                            return new LazyResult(this, css, opts);
                        }
                    }
                },
                {
                    key: "use",
                    value: function use(plugin2) {
                        this.plugins = this.plugins.concat(this.normalize([
                            plugin2
                        ]));
                        return this;
                    }
                }
            ]);
            return Processor2;
        }();
        module2.exports = Processor2;
        Processor2.default = Processor2;
        Root2.registerProcessor(Processor2);
        Document2.registerProcessor(Processor2);
    }
});
// node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS({
    "node_modules/postcss/lib/fromJSON.js": function(exports, module2) {
        "use strict";
        init_shim();
        var Declaration2 = require_declaration();
        var PreviousMap = require_previous_map();
        var Comment2 = require_comment();
        var AtRule2 = require_at_rule();
        var Input2 = require_input();
        var Root2 = require_root();
        var Rule2 = require_rule();
        function fromJSON2(json, inputs) {
            if (Array.isArray(json)) return json.map(function(n2) {
                return fromJSON2(n2);
            });
            var ownInputs = json.inputs, defaults = _object_without_properties(json, [
                "inputs"
            ]);
            if (ownInputs) {
                inputs = [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = ownInputs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var input = _step.value;
                        var inputHydrated = _object_spread_props(_object_spread({}, input), {
                            __proto__: Input2.prototype
                        });
                        if (inputHydrated.map) {
                            inputHydrated.map = _object_spread_props(_object_spread({}, inputHydrated.map), {
                                __proto__: PreviousMap.prototype
                            });
                        }
                        inputs.push(inputHydrated);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            if (defaults.nodes) {
                defaults.nodes = json.nodes.map(function(n2) {
                    return fromJSON2(n2, inputs);
                });
            }
            if (defaults.source) {
                var _defaults_source = defaults.source, inputId = _defaults_source.inputId, source = _object_without_properties(_defaults_source, [
                    "inputId"
                ]);
                defaults.source = source;
                if (inputId != null) {
                    defaults.source.input = inputs[inputId];
                }
            }
            if (defaults.type === "root") {
                return new Root2(defaults);
            } else if (defaults.type === "decl") {
                return new Declaration2(defaults);
            } else if (defaults.type === "rule") {
                return new Rule2(defaults);
            } else if (defaults.type === "comment") {
                return new Comment2(defaults);
            } else if (defaults.type === "atrule") {
                return new AtRule2(defaults);
            } else {
                throw new Error("Unknown node type: " + json.type);
            }
        }
        module2.exports = fromJSON2;
        fromJSON2.default = fromJSON2;
    }
});
// node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS({
    "node_modules/postcss/lib/postcss.js": function(exports, module2) {
        "use strict";
        init_shim();
        var CssSyntaxError2 = require_css_syntax_error();
        var Declaration2 = require_declaration();
        var LazyResult = require_lazy_result();
        var Container2 = require_container();
        var Processor2 = require_processor();
        var stringify4 = require_stringify();
        var fromJSON2 = require_fromJSON();
        var Document2 = require_document();
        var Warning2 = require_warning();
        var Comment2 = require_comment();
        var AtRule2 = require_at_rule();
        var Result2 = require_result();
        var Input2 = require_input();
        var parse5 = require_parse();
        var list2 = require_list();
        var Rule2 = require_rule();
        var Root2 = require_root();
        var Node2 = require_node();
        function postcss2() {
            for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++){
                plugins[_key] = arguments[_key];
            }
            if (plugins.length === 1 && Array.isArray(plugins[0])) {
                plugins = plugins[0];
            }
            return new Processor2(plugins);
        }
        postcss2.plugin = function plugin2(name, initializer) {
            var warningPrinted = false;
            function creator2() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                if (console && console.warn && !warningPrinted) {
                    warningPrinted = true;
                    console.warn(name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration");
                    if (import_process.default.env.LANG && import_process.default.env.LANG.startsWith("cn")) {
                        console.warn(name + ": 里面 postcss.plugin 被弃用. 迁移指南:\nhttps://www.w3ctech.com/topic/2226");
                    }
                }
                var transformer = initializer.apply(void 0, _to_consumable_array(args));
                transformer.postcssPlugin = name;
                transformer.postcssVersion = new Processor2().version;
                return transformer;
            }
            var cache;
            Object.defineProperty(creator2, "postcss", {
                get: function get() {
                    if (!cache) cache = creator2();
                    return cache;
                }
            });
            creator2.process = function(css, processOpts, pluginOpts) {
                return postcss2([
                    creator2(pluginOpts)
                ]).process(css, processOpts);
            };
            return creator2;
        };
        postcss2.stringify = stringify4;
        postcss2.parse = parse5;
        postcss2.fromJSON = fromJSON2;
        postcss2.list = list2;
        postcss2.comment = function(defaults) {
            return new Comment2(defaults);
        };
        postcss2.atRule = function(defaults) {
            return new AtRule2(defaults);
        };
        postcss2.decl = function(defaults) {
            return new Declaration2(defaults);
        };
        postcss2.rule = function(defaults) {
            return new Rule2(defaults);
        };
        postcss2.root = function(defaults) {
            return new Root2(defaults);
        };
        postcss2.document = function(defaults) {
            return new Document2(defaults);
        };
        postcss2.CssSyntaxError = CssSyntaxError2;
        postcss2.Declaration = Declaration2;
        postcss2.Container = Container2;
        postcss2.Processor = Processor2;
        postcss2.Document = Document2;
        postcss2.Comment = Comment2;
        postcss2.Warning = Warning2;
        postcss2.AtRule = AtRule2;
        postcss2.Result = Result2;
        postcss2.Input = Input2;
        postcss2.Rule = Rule2;
        postcss2.Root = Root2;
        postcss2.Node = Node2;
        LazyResult.registerPostcss(postcss2);
        module2.exports = postcss2;
        postcss2.default = postcss2;
    }
});
// node_modules/postcss/lib/postcss.mjs
var postcss_exports = {};
__export(postcss_exports, {
    AtRule: function() {
        return AtRule;
    },
    Comment: function() {
        return Comment;
    },
    Container: function() {
        return Container;
    },
    CssSyntaxError: function() {
        return CssSyntaxError;
    },
    Declaration: function() {
        return Declaration;
    },
    Document: function() {
        return Document;
    },
    Input: function() {
        return Input;
    },
    Node: function() {
        return Node;
    },
    Processor: function() {
        return Processor;
    },
    Result: function() {
        return Result;
    },
    Root: function() {
        return Root;
    },
    Rule: function() {
        return Rule;
    },
    Warning: function() {
        return Warning;
    },
    atRule: function() {
        return atRule;
    },
    comment: function() {
        return comment;
    },
    decl: function() {
        return decl;
    },
    default: function() {
        return postcss_default;
    },
    document: function() {
        return document;
    },
    fromJSON: function() {
        return fromJSON;
    },
    list: function() {
        return list;
    },
    parse: function() {
        return parse4;
    },
    plugin: function() {
        return plugin;
    },
    root: function() {
        return root;
    },
    rule: function() {
        return rule;
    },
    stringify: function() {
        return stringify3;
    }
});
var import_postcss, postcss_default, stringify3, fromJSON, plugin, parse4, list, document, comment, atRule, rule, decl, root, CssSyntaxError, Declaration, Container, Processor, Document, Comment, Warning, AtRule, Result, Input, Rule, Root, Node;
var init_postcss = __esm({
    "node_modules/postcss/lib/postcss.mjs": function() {
        "use strict";
        init_shim();
        import_postcss = __toESM(require_postcss(), 1);
        postcss_default = import_postcss.default;
        stringify3 = import_postcss.default.stringify;
        fromJSON = import_postcss.default.fromJSON;
        plugin = import_postcss.default.plugin;
        parse4 = import_postcss.default.parse;
        list = import_postcss.default.list;
        document = import_postcss.default.document;
        comment = import_postcss.default.comment;
        atRule = import_postcss.default.atRule;
        rule = import_postcss.default.rule;
        decl = import_postcss.default.decl;
        root = import_postcss.default.root;
        CssSyntaxError = import_postcss.default.CssSyntaxError;
        Declaration = import_postcss.default.Declaration;
        Container = import_postcss.default.Container;
        Processor = import_postcss.default.Processor;
        Document = import_postcss.default.Document;
        Comment = import_postcss.default.Comment;
        Warning = import_postcss.default.Warning;
        AtRule = import_postcss.default.AtRule;
        Result = import_postcss.default.Result;
        Input = import_postcss.default.Input;
        Rule = import_postcss.default.Rule;
        Root = import_postcss.default.Root;
        Node = import_postcss.default.Node;
    }
});
// node_modules/extend/index.js
var require_extend = __commonJS({
    "node_modules/extend/index.js": function(exports, module2) {
        "use strict";
        init_shim();
        var hasOwn = Object.prototype.hasOwnProperty;
        var toStr = Object.prototype.toString;
        var defineProperty = Object.defineProperty;
        var gOPD = Object.getOwnPropertyDescriptor;
        var isArray = function isArray2(arr) {
            if (typeof Array.isArray === "function") {
                return Array.isArray(arr);
            }
            return toStr.call(arr) === "[object Array]";
        };
        var isPlainObject = function isPlainObject2(obj) {
            if (!obj || toStr.call(obj) !== "[object Object]") {
                return false;
            }
            var hasOwnConstructor = hasOwn.call(obj, "constructor");
            var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
            if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
                return false;
            }
            var key;
            for(key in obj){}
            return typeof key === "undefined" || hasOwn.call(obj, key);
        };
        var setProperty = function setProperty2(target, options) {
            if (defineProperty && options.name === "__proto__") {
                defineProperty(target, options.name, {
                    enumerable: true,
                    configurable: true,
                    value: options.newValue,
                    writable: true
                });
            } else {
                target[options.name] = options.newValue;
            }
        };
        var getProperty = function getProperty2(obj, name) {
            if (name === "__proto__") {
                if (!hasOwn.call(obj, name)) {
                    return void 0;
                } else if (gOPD) {
                    return gOPD(obj, name).value;
                }
            }
            return obj[name];
        };
        module2.exports = function extend() {
            var options, name, src, copy, copyIsArray, clone;
            var target = arguments[0];
            var i2 = 1;
            var length = arguments.length;
            var deep = false;
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                i2 = 2;
            }
            if (target == null || typeof target !== "object" && typeof target !== "function") {
                target = {};
            }
            for(; i2 < length; ++i2){
                options = arguments[i2];
                if (options != null) {
                    for(name in options){
                        src = getProperty(target, name);
                        copy = getProperty(options, name);
                        if (target !== copy) {
                            if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && isArray(src) ? src : [];
                                } else {
                                    clone = src && isPlainObject(src) ? src : {};
                                }
                                setProperty(target, {
                                    name: name,
                                    newValue: extend(deep, clone, copy)
                                });
                            } else if (typeof copy !== "undefined") {
                                setProperty(target, {
                                    name: name,
                                    newValue: copy
                                });
                            }
                        }
                    }
                }
            }
            return target;
        };
    }
});
// node_modules/postcss-css-variables/lib/shallow-clone-node.js
var require_shallow_clone_node = __commonJS({
    "node_modules/postcss-css-variables/lib/shallow-clone-node.js": function(exports, module2) {
        "use strict";
        init_shim();
        var shallowCloneNode = function shallowCloneNode1(obj, parent) {
            var cloned = new obj.constructor();
            Object.keys(obj).forEach(function(i2) {
                if (!obj.hasOwnProperty(i2)) {
                    return;
                }
                var value = obj[i2];
                var type = typeof value === "undefined" ? "undefined" : _type_of(value);
                if (i2 === "parent" && type === "object") {
                    if (parent) {
                        cloned[i2] = parent;
                    }
                } else if (i2 === "source") {
                    cloned[i2] = value;
                } else if (_instanceof(value, Array)) {
                    if (i2 === "nodes") {
                        cloned[i2] = [];
                    } else {
                        cloned[i2] = value.map(function(j) {
                            shallowCloneNode(j, cloned);
                        });
                    }
                } else if (i2 !== "before" && i2 !== "after" && i2 !== "between" && i2 !== "semicolon") {
                    if (type === "object") {
                        value = shallowCloneNode(value);
                    }
                    cloned[i2] = value;
                }
            });
            return cloned;
        };
        module2.exports = shallowCloneNode;
    }
});
// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
    "node_modules/balanced-match/index.js": function(exports, module2) {
        "use strict";
        init_shim();
        module2.exports = balanced;
        function balanced(a, b, str) {
            if (_instanceof(a, RegExp)) a = maybeMatch(a, str);
            if (_instanceof(b, RegExp)) b = maybeMatch(b, str);
            var r2 = range(a, b, str);
            return r2 && {
                start: r2[0],
                end: r2[1],
                pre: str.slice(0, r2[0]),
                body: str.slice(r2[0] + a.length, r2[1]),
                post: str.slice(r2[1] + b.length)
            };
        }
        function maybeMatch(reg, str) {
            var m = str.match(reg);
            return m ? m[0] : null;
        }
        balanced.range = range;
        function range(a, b, str) {
            var begs, beg, left, right, result;
            var ai = str.indexOf(a);
            var bi = str.indexOf(b, ai + 1);
            var i2 = ai;
            if (ai >= 0 && bi > 0) {
                if (a === b) {
                    return [
                        ai,
                        bi
                    ];
                }
                begs = [];
                left = str.length;
                while(i2 >= 0 && !result){
                    if (i2 == ai) {
                        begs.push(i2);
                        ai = str.indexOf(a, i2 + 1);
                    } else if (begs.length == 1) {
                        result = [
                            begs.pop(),
                            bi
                        ];
                    } else {
                        beg = begs.pop();
                        if (beg < left) {
                            left = beg;
                            right = bi;
                        }
                        bi = str.indexOf(b, i2 + 1);
                    }
                    i2 = ai < bi && ai >= 0 ? ai : bi;
                }
                if (begs.length) {
                    result = [
                        left,
                        right
                    ];
                }
            }
            return result;
        }
    }
});
// node_modules/postcss-css-variables/lib/generate-descendant-pieces-from-selector.js
var require_generate_descendant_pieces_from_selector = __commonJS({
    "node_modules/postcss-css-variables/lib/generate-descendant-pieces-from-selector.js": function(exports, module2) {
        "use strict";
        init_shim();
        var RE_SELECTOR_DESCENDANT_SPLIT = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/;
        var generateDescendantPiecesFromSelector = function generateDescendantPiecesFromSelector(selector) {
            return selector.split(RE_SELECTOR_DESCENDANT_SPLIT).filter(function(piece) {
                if (piece.length > 0) {
                    return true;
                }
                return false;
            }).map(function(piece) {
                return piece.trim().replace(/\s*?>>\s*?/g, "");
            });
        };
        module2.exports = generateDescendantPiecesFromSelector;
    }
});
// node_modules/postcss-css-variables/lib/generate-scope-list.js
var require_generate_scope_list = __commonJS({
    "node_modules/postcss-css-variables/lib/generate-scope-list.js": function(exports, module2) {
        "use strict";
        init_shim();
        var generateDescendantPiecesFromSelector = require_generate_descendant_pieces_from_selector();
        var generateScopeList = function generateScopeList(node, includeSelf) {
            includeSelf = includeSelf || false;
            var selectorScopeList = [
                // Start off with one branch
                []
            ];
            var currentNodeParent = includeSelf ? node : node.parent;
            while(currentNodeParent){
                var scopePieces = (currentNodeParent.selectors || []).map(function(selectorPiece) {
                    return {
                        value: selectorPiece,
                        type: "selector"
                    };
                });
                if (currentNodeParent.type === "atrule") {
                    scopePieces = [].concat(currentNodeParent.params).map(function(param) {
                        return {
                            value: "@" + currentNodeParent.name + " " + param,
                            type: "atrule"
                        };
                    });
                }
                var branches = (scopePieces.length > 0 ? scopePieces : [
                    1
                ]).map(function() {
                    return selectorScopeList.map(function(scopePieces2) {
                        return scopePieces2.slice(0);
                    });
                });
                scopePieces.forEach(function(scopeObject, index) {
                    branches[index] = branches[index].map(function(scopeStringPieces) {
                        var descendantPieces = [
                            scopeObject.value
                        ];
                        if (scopeObject.type === "selector") {
                            descendantPieces = generateDescendantPiecesFromSelector(scopeObject.value);
                        }
                        scopeStringPieces.unshift.apply(scopeStringPieces, descendantPieces);
                        return scopeStringPieces;
                    });
                });
                selectorScopeList = [];
                branches.forEach(function(branch) {
                    selectorScopeList = selectorScopeList.concat(branch);
                });
                currentNodeParent = currentNodeParent.parent;
            }
            return selectorScopeList;
        };
        module2.exports = generateScopeList;
    }
});
// node_modules/postcss-css-variables/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
    "node_modules/postcss-css-variables/node_modules/escape-string-regexp/index.js": function(exports, module2) {
        "use strict";
        init_shim();
        var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
        module2.exports = function(str) {
            if (typeof str !== "string") {
                throw new TypeError("Expected a string");
            }
            return str.replace(matchOperatorsRe, "\\$&");
        };
    }
});
// node_modules/postcss-css-variables/lib/is-piece-always-ancestor-selector.js
var require_is_piece_always_ancestor_selector = __commonJS({
    "node_modules/postcss-css-variables/lib/is-piece-always-ancestor-selector.js": function(exports, module2) {
        "use strict";
        init_shim();
        var alwaysAncestorSelector = {
            "*": true,
            ":root": true,
            "html": true
        };
        var isPieceIsAlwaysAncestorSelector = function isPieceIsAlwaysAncestorSelector(piece) {
            return !!alwaysAncestorSelector[piece];
        };
        module2.exports = isPieceIsAlwaysAncestorSelector;
    }
});
// node_modules/postcss-css-variables/lib/generate-direct-descendant-pieces-from-selector.js
var require_generate_direct_descendant_pieces_from_selector = __commonJS({
    "node_modules/postcss-css-variables/lib/generate-direct-descendant-pieces-from-selector.js": function(exports, module2) {
        "use strict";
        init_shim();
        var RE_SELECTOR_DIRECT_DESCENDANT_SPLIT = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/;
        var generateDirectDescendantPiecesFromSelector = function generateDirectDescendantPiecesFromSelector(selector) {
            return selector.split(RE_SELECTOR_DIRECT_DESCENDANT_SPLIT).filter(function(piece) {
                if (piece.length > 0) {
                    return true;
                }
                return false;
            }).map(function(piece) {
                return piece.trim().replace(/\s*?>\s*?/g, "");
            });
        };
        module2.exports = generateDirectDescendantPiecesFromSelector;
    }
});
// node_modules/postcss-css-variables/lib/is-under-scope.js
var require_is_under_scope = __commonJS({
    "node_modules/postcss-css-variables/lib/is-under-scope.js": function(exports, module2) {
        "use strict";
        init_shim();
        var escapeStringRegexp = require_escape_string_regexp();
        var isPieceAlwaysAncestorSelector = require_is_piece_always_ancestor_selector();
        var generateDirectDescendantPiecesFromSelector = require_generate_direct_descendant_pieces_from_selector();
        var RE_AT_RULE_SCOPE_PIECE = /^@.*/;
        var RE_PSEUDO_SELECTOR = /([^\s:]+)((?::|::)[^\s]*?)(\s+|$)/;
        function getScopeMatchResults(nodeScopeList, scopeNodeScopeList) {
            var currentPieceOffset;
            var scopePieceIndex;
            var doesMatchScope = scopeNodeScopeList.some(function(scopeNodeScopePieces) {
                return nodeScopeList.some(function(nodeScopePieces) {
                    currentPieceOffset = null;
                    var wasEveryPieceFound = true;
                    for(scopePieceIndex = 0; scopePieceIndex < scopeNodeScopePieces.length; scopePieceIndex++){
                        var scopePiece = scopeNodeScopePieces[scopePieceIndex];
                        var pieceOffset = currentPieceOffset || 0;
                        var foundIndex = -1;
                        var piecesWeCanMatch = nodeScopePieces.slice(pieceOffset);
                        for(var nodeScopePieceIndex = 0; nodeScopePieceIndex < piecesWeCanMatch.length; nodeScopePieceIndex++){
                            var nodeScopePiece = piecesWeCanMatch[nodeScopePieceIndex];
                            var overallIndex = pieceOffset + nodeScopePieceIndex;
                            if (// If the part on the end of the piece itself matches:
                            //		scopePiece `.bar` matches node `.bar`
                            //		scopePiece `.bar` matches node `.foo + .bar`
                            new RegExp(escapeStringRegexp(scopePiece) + "$").test(nodeScopePiece)) {
                                foundIndex = overallIndex;
                                break;
                            }
                            if (isPieceAlwaysAncestorSelector(scopePiece) || isPieceAlwaysAncestorSelector(nodeScopePiece)) {
                                foundIndex = overallIndex;
                                break;
                            }
                            var directDescendantPieces = generateDirectDescendantPiecesFromSelector(nodeScopePiece);
                            if (directDescendantPieces.length > 1) {
                                var ddNodeScopeList = [].concat([
                                    directDescendantPieces
                                ]);
                                var ddScopeList = [].concat([
                                    scopeNodeScopePieces.slice(scopePieceIndex).reduce(function(prevScopePieces, scopePiece2) {
                                        return prevScopePieces.concat(generateDirectDescendantPiecesFromSelector(scopePiece2));
                                    }, [])
                                ]);
                                var result = getScopeMatchResults(ddNodeScopeList, ddScopeList);
                                if (result.doesMatchScope || scopePieceIndex + 1 < scopeNodeScopePieces.length) {
                                    foundIndex = overallIndex;
                                    scopePieceIndex += result.scopePieceIndex - 1;
                                }
                                break;
                            }
                        }
                        var isFurther = foundIndex >= pieceOffset;
                        currentPieceOffset = foundIndex + 1;
                        wasEveryPieceFound = wasEveryPieceFound && isFurther;
                        if (!wasEveryPieceFound) {
                            break;
                        }
                    }
                    return wasEveryPieceFound;
                });
            });
            return {
                doesMatchScope: doesMatchScope,
                nodeScopePieceIndex: currentPieceOffset - 1,
                scopePieceIndex: scopePieceIndex
            };
        }
        var stripPseudoSelectorsFromScopeList = function stripPseudoSelectorsFromScopeList(scopeList) {
            return scopeList.map(function(scopePieces) {
                return scopePieces.map(function(descendantPiece) {
                    if (!RE_AT_RULE_SCOPE_PIECE.test(descendantPiece)) {
                        return descendantPiece.replace(new RegExp(RE_PSEUDO_SELECTOR.source, "g"), function(whole, baseSelector, pseudo, trailingWhitespace) {
                            return baseSelector + trailingWhitespace;
                        });
                    }
                    return descendantPiece;
                });
            });
        };
        var isUnderScope = function isUnderScope(nodeScopeList, scopeNodeScopeList, ignorePseudo) {
            nodeScopeList = stripPseudoSelectorsFromScopeList(nodeScopeList);
            if (ignorePseudo) {
                scopeNodeScopeList = stripPseudoSelectorsFromScopeList(scopeNodeScopeList);
            }
            return getScopeMatchResults(nodeScopeList, scopeNodeScopeList).doesMatchScope;
        };
        isUnderScope.RE_PSEUDO_SELECTOR = RE_PSEUDO_SELECTOR;
        module2.exports = isUnderScope;
    }
});
// node_modules/postcss-css-variables/lib/is-node-under-scope.js
var require_is_node_under_scope = __commonJS({
    "node_modules/postcss-css-variables/lib/is-node-under-scope.js": function(exports, module2) {
        "use strict";
        init_shim();
        var isUnderScope = require_is_under_scope();
        var generateScopeList = require_generate_scope_list();
        var isNodeUnderScope = function isNodeUnderScope(node, scopeNode, ignorePseudo) {
            var nodeScopeList = generateScopeList(node, true);
            var scopeNodeScopeList = generateScopeList(scopeNode, true);
            return isUnderScope(nodeScopeList, scopeNodeScopeList, ignorePseudo);
        };
        module2.exports = isNodeUnderScope;
    }
});
// node_modules/postcss-css-variables/lib/gather-variable-dependencies.js
var require_gather_variable_dependencies = __commonJS({
    "node_modules/postcss-css-variables/lib/gather-variable-dependencies.js": function(exports, module2) {
        "use strict";
        init_shim();
        var gatherVariableDependencies = function gatherVariableDependencies1(variablesUsed, map, _dependencyVariablesList) {
            _dependencyVariablesList = _dependencyVariablesList || [];
            var hasCircularOrSelfReference = false;
            if (variablesUsed) {
                _dependencyVariablesList = variablesUsed.reduce(function(dependencyVariablesList, variableUsedName) {
                    var isVariableInMap = !!map[variableUsedName];
                    var doesThisVarHaveCircularOrSelfReference = !isVariableInMap ? false : dependencyVariablesList.some(function(dep) {
                        return map[variableUsedName].some(function(mapItem) {
                            if (dep === mapItem) {
                                return true;
                            }
                            return false;
                        });
                    });
                    hasCircularOrSelfReference = hasCircularOrSelfReference || doesThisVarHaveCircularOrSelfReference;
                    if (isVariableInMap && !hasCircularOrSelfReference) {
                        dependencyVariablesList = dependencyVariablesList.concat(map[variableUsedName]);
                        (map[variableUsedName] || []).forEach(function(mapItem) {
                            var result = gatherVariableDependencies(mapItem.variablesUsed, map, dependencyVariablesList);
                            dependencyVariablesList = result.deps;
                            hasCircularOrSelfReference = hasCircularOrSelfReference || result.hasCircularOrSelfReference;
                        });
                    }
                    return dependencyVariablesList;
                }, _dependencyVariablesList);
            }
            return {
                deps: _dependencyVariablesList,
                hasCircularOrSelfReference: hasCircularOrSelfReference
            };
        };
        module2.exports = gatherVariableDependencies;
    }
});
// node_modules/postcss-css-variables/lib/find-node-ancestor-with-selector.js
var require_find_node_ancestor_with_selector = __commonJS({
    "node_modules/postcss-css-variables/lib/find-node-ancestor-with-selector.js": function(exports, module2) {
        "use strict";
        init_shim();
        var generateScopeList = require_generate_scope_list();
        var findNodeAncestorWithSelector = function findNodeAncestorWithSelector(selector, node) {
            var matchingNode;
            var currentNode = node;
            while(currentNode.parent && !matchingNode){
                var currentNodeScopeList = generateScopeList(currentNode.clone(), true);
                currentNodeScopeList.some(function(scopePieces) {
                    return scopePieces.some(function(scopePiece) {
                        if (scopePiece === selector) {
                            matchingNode = currentNode;
                            return true;
                        }
                        return false;
                    });
                });
                currentNode = currentNode.parent;
            }
            return matchingNode;
        };
        module2.exports = findNodeAncestorWithSelector;
    }
});
// node_modules/postcss-css-variables/lib/clone-splice-parent-onto-node-when.js
var require_clone_splice_parent_onto_node_when = __commonJS({
    "node_modules/postcss-css-variables/lib/clone-splice-parent-onto-node-when.js": function(exports, module2) {
        "use strict";
        init_shim();
        var shallowCloneNode = require_shallow_clone_node();
        var cloneSpliceParentOntoNodeWhen = function cloneSpliceParentOntoNodeWhen(node, parent, whenCb) {
            whenCb = whenCb || function() {
                return true;
            };
            var cloneList = [];
            var current = node;
            var isWhenNow = false;
            while(current && !isWhenNow){
                if (current.type === "decl") {
                    cloneList.push(current.clone());
                } else {
                    cloneList.push(shallowCloneNode(current));
                }
                isWhenNow = whenCb(current);
                current = current.parent;
            }
            var cloneParentList = [];
            var currentParent = parent;
            while(currentParent){
                cloneParentList.push(shallowCloneNode(currentParent));
                currentParent = currentParent.parent;
            }
            cloneParentList.forEach(function(parentClone, index, cloneParentList2) {
                if (index + 1 < cloneParentList2.length) {
                    parentClone.parent = cloneParentList2[index + 1];
                }
            });
            cloneList.forEach(function(clone, index, cloneList2) {
                if (index + 1 < cloneList2.length) {
                    clone.parent = cloneList2[index + 1];
                } else {
                    cloneParentList.slice(-1)[0].parent = current;
                    clone.parent = cloneParentList[0];
                }
            });
            return cloneList[0];
        };
        module2.exports = cloneSpliceParentOntoNodeWhen;
    }
});
// node_modules/postcss-css-variables/lib/resolve-value.js
var require_resolve_value = __commonJS({
    "node_modules/postcss-css-variables/lib/resolve-value.js": function(exports, module2) {
        "use strict";
        init_shim();
        var balanced = require_balanced_match();
        var generateScopeList = require_generate_scope_list();
        var isNodeUnderScope = require_is_node_under_scope();
        var gatherVariableDependencies = require_gather_variable_dependencies();
        var findNodeAncestorWithSelector = require_find_node_ancestor_with_selector();
        var cloneSpliceParentOntoNodeWhen = require_clone_splice_parent_onto_node_when();
        var RE_VAR_FUNC = /var\(\s*(--[^,\s)]+)/;
        function toString(value) {
            return String(value);
        }
        function balancedVar(value) {
            var match = balanced("(", ")", value);
            if (match) {
                if (/(?:^|[^\w-])var$/.test(match.pre)) {
                    return {
                        pre: match.pre.slice(0, -3),
                        body: match.body,
                        post: match.post
                    };
                } else {
                    var bodyMatch = balancedVar(match.body);
                    if (bodyMatch) {
                        return {
                            pre: match.pre + "(" + bodyMatch.pre,
                            body: bodyMatch.body,
                            post: bodyMatch.post + ")" + match.post
                        };
                    } else {
                        var postMatch = balancedVar(match.post);
                        if (postMatch) {
                            return {
                                pre: match.pre + "(" + match.body + ")" + postMatch.pre,
                                body: postMatch.body,
                                post: postMatch.post
                            };
                        }
                    }
                }
            }
        }
        var resolveValue = function resolveValue1(decl2, map, ignorePseudoScope, _debugIsInternal) {
            var debugIndent = _debugIsInternal ? "	" : "";
            var matchingVarDecl = void 0;
            var resultantValue = toString(decl2.value);
            var warnings = [];
            var variablesUsedInValueMap = {};
            var remainingVariableValue = resultantValue;
            while(matchingVarDecl = balancedVar(remainingVariableValue)){
                var variableFallbackSplitPieces = matchingVarDecl.body.split(",");
                var variableName = variableFallbackSplitPieces[0].trim();
                variablesUsedInValueMap[variableName] = true;
                remainingVariableValue = (matchingVarDecl.pre || "") + matchingVarDecl.body.replace(variableName, "") + (matchingVarDecl.post || "");
            }
            remainingVariableValue = void 0;
            var variablesUsedInValue = Object.keys(variablesUsedInValueMap);
            var isResultantValueUndefined = false;
            while(matchingVarDecl = balancedVar(resultantValue)){
                var matchingVarDeclMapItem = void 0;
                var variableFallbackSplitPieces = matchingVarDecl.body.split(",");
                var variableName = variableFallbackSplitPieces[0].trim();
                var fallback = variableFallbackSplitPieces.length > 1 ? variableFallbackSplitPieces.slice(1).join(",").trim() : void 0;
                (map[variableName] || []).forEach(function(varDeclMapItem) {
                    var isRoot = varDeclMapItem.parent.type === "root" || varDeclMapItem.parent.selectors[0] === ":root";
                    var underScope = isNodeUnderScope(decl2.parent, varDeclMapItem.parent);
                    var underScsopeIgnorePseudo = isNodeUnderScope(decl2.parent, varDeclMapItem.parent, ignorePseudoScope);
                    if (underScsopeIgnorePseudo && // And if the currently matched declaration is `!important`, it will take another `!important` to override it
                    (!(matchingVarDeclMapItem || {}).isImportant || varDeclMapItem.isImportant)) {
                        matchingVarDeclMapItem = varDeclMapItem;
                    }
                });
                var replaceValue = (matchingVarDeclMapItem || {}).calculatedInPlaceValue || function() {
                    var fallbackValue = fallback;
                    if (fallback) {
                        var fallbackDecl = decl2.clone({
                            parent: decl2.parent,
                            value: fallback
                        });
                        fallbackValue = resolveValue(fallbackDecl, map, false, /*internal*/ true).value;
                    }
                    return fallbackValue;
                }();
                if (matchingVarDeclMapItem !== void 0 && !gatherVariableDependencies(variablesUsedInValue, map).hasCircularOrSelfReference) {
                    var varDeclScopeList = generateScopeList(decl2.parent.parent, true);
                    var innerMostAtRuleSelector = varDeclScopeList[0].slice(-1)[0];
                    var nodeToSpliceParentOnto = findNodeAncestorWithSelector(innerMostAtRuleSelector, matchingVarDeclMapItem.decl.parent);
                    var matchingMimicDecl = cloneSpliceParentOntoNodeWhen(matchingVarDeclMapItem.decl, decl2.parent.parent, function(ancestor) {
                        return ancestor === nodeToSpliceParentOnto;
                    });
                    replaceValue = resolveValue(matchingMimicDecl, map, false, /*internal*/ true).value;
                }
                isResultantValueUndefined = replaceValue === void 0;
                if (isResultantValueUndefined) {
                    warnings.push([
                        "variable " + variableName + " is undefined and used without a fallback",
                        {
                            node: decl2
                        }
                    ]);
                }
                resultantValue = (matchingVarDecl.pre || "") + replaceValue + (matchingVarDecl.post || "");
            }
            return {
                // The resolved value
                value: !isResultantValueUndefined ? resultantValue : void 0,
                // Array of variable names used in resolving this value
                variablesUsed: variablesUsedInValue,
                // Any warnings generated from parsing this value
                warnings: warnings
            };
        };
        resolveValue.RE_VAR_FUNC = RE_VAR_FUNC;
        module2.exports = resolveValue;
    }
});
// node_modules/postcss-css-variables/lib/resolve-decl.js
var require_resolve_decl = __commonJS({
    "node_modules/postcss-css-variables/lib/resolve-decl.js": function(exports, module2) {
        "use strict";
        init_shim();
        var resolveValue = require_resolve_value();
        var generateScopeList = require_generate_scope_list();
        var gatherVariableDependencies = require_gather_variable_dependencies();
        var isUnderScope = require_is_under_scope();
        var isNodeUnderScope = require_is_node_under_scope();
        var shallowCloneNode = require_shallow_clone_node();
        var findNodeAncestorWithSelector = require_find_node_ancestor_with_selector();
        var cloneSpliceParentOntoNodeWhen = require_clone_splice_parent_onto_node_when();
        function eachMapItemDependencyOfDecl(variablesUsedList, map, decl2, cb) {
            variablesUsedList.forEach(function(variableUsedName) {
                gatherVariableDependencies(variablesUsedList, map).deps.forEach(function(mapItem) {
                    var mimicDecl;
                    if (mapItem.isUnderAtRule) {
                        var varDeclScopeList = generateScopeList(mapItem.parent, true);
                        var innerMostAtRuleSelector = varDeclScopeList[0].slice(-1)[0];
                        var nodeToSpliceParentOnto = findNodeAncestorWithSelector(innerMostAtRuleSelector, decl2.parent);
                        var varDeclAtRule = mapItem.parent.parent;
                        mimicDecl = cloneSpliceParentOntoNodeWhen(decl2, varDeclAtRule, function(ancestor) {
                            return ancestor === nodeToSpliceParentOnto;
                        });
                    } else if (isUnderScope.RE_PSEUDO_SELECTOR.test(mapItem.parent.selector)) {
                        var ruleClone = shallowCloneNode(decl2.parent);
                        ruleClone.parent = decl2.parent.parent;
                        mimicDecl = decl2.clone();
                        ruleClone.append(mimicDecl);
                        var lastPseudoSelectorMatches = mapItem.parent.selector.match(new RegExp(isUnderScope.RE_PSEUDO_SELECTOR.source + "$"));
                        var lastPseudoSelector = lastPseudoSelectorMatches ? lastPseudoSelectorMatches[2] : "";
                        ruleClone.selector += lastPseudoSelector;
                    }
                    if (mimicDecl && isNodeUnderScope(mimicDecl, mapItem.parent, true)) {
                        cb(mimicDecl, mapItem);
                    }
                });
            });
        }
        function resolveDecl(decl2, map, shouldPreserve, preserveAtRulesOrder, logResolveValueResult) {
            shouldPreserve = (typeof shouldPreserve === "function" ? shouldPreserve(decl2) : shouldPreserve) || false;
            preserveAtRulesOrder = preserveAtRulesOrder || false;
            var _logResolveValueResult = function _logResolveValueResult(valueResults2) {
                if (logResolveValueResult) {
                    logResolveValueResult(valueResults2);
                }
                return valueResults2;
            };
            var valueResults = _logResolveValueResult(resolveValue(decl2, map));
            var previousAtRuleNode;
            eachMapItemDependencyOfDecl(valueResults.variablesUsed, map, decl2, function(mimicDecl, mapItem) {
                var ruleClone = shallowCloneNode(decl2.parent);
                var declClone = decl2.clone();
                ruleClone.append(declClone);
                var preserveVariable;
                if (typeof shouldPreserve === "function") {
                    preserveVariable = shouldPreserve(decl2);
                } else {
                    preserveVariable = shouldPreserve;
                }
                if (preserveVariable === true) {
                    declClone.cloneAfter();
                }
                declClone.value = _logResolveValueResult(resolveValue(mimicDecl, map, true)).value;
                if (mapItem.isUnderAtRule) {
                    var atRuleNode = shallowCloneNode(mapItem.parent.parent);
                    atRuleNode.append(ruleClone);
                    var parentAtRuleNode = atRuleNode;
                    var currentAtRuleNode = mapItem.parent.parent;
                    while(currentAtRuleNode.parent.type === "atrule"){
                        var newParentAtRuleNode = shallowCloneNode(currentAtRuleNode.parent);
                        newParentAtRuleNode.append(parentAtRuleNode);
                        parentAtRuleNode = newParentAtRuleNode;
                        currentAtRuleNode = currentAtRuleNode.parent;
                    }
                    decl2.parent.parent.insertAfter(preserveAtRulesOrder && previousAtRuleNode || decl2.parent, parentAtRuleNode);
                    previousAtRuleNode = parentAtRuleNode;
                } else {
                    ruleClone.selector = mimicDecl.parent.selector;
                    decl2.parent.parent.insertAfter(preserveAtRulesOrder && previousAtRuleNode || decl2.parent, ruleClone);
                }
            });
            if (shouldPreserve === true && decl2.value !== valueResults.value) {
                decl2.cloneAfter();
            }
            if (valueResults.value === void 0) {
                valueResults.value = "undefined";
            }
            decl2.value = valueResults.value;
        }
        module2.exports = resolveDecl;
    }
});
// node_modules/postcss-css-variables/index.js
var require_postcss_css_variables = __commonJS({
    "node_modules/postcss-css-variables/index.js": function(exports, module2) {
        "use strict";
        init_shim();
        var extend = require_extend();
        var shallowCloneNode = require_shallow_clone_node();
        var resolveValue = require_resolve_value();
        var resolveDecl = require_resolve_decl();
        var RE_VAR_PROP = /(--(.+))/;
        function eachCssVariableDeclaration(css, cb) {
            css.walkDecls(function(decl2) {
                if (RE_VAR_PROP.test(decl2.prop)) {
                    cb(decl2);
                }
            });
        }
        function cleanUpNode(node) {
            var nodeToPossiblyCleanUp = node;
            while(nodeToPossiblyCleanUp && nodeToPossiblyCleanUp.nodes.length <= 0){
                var nodeToRemove = nodeToPossiblyCleanUp.type !== "root" ? nodeToPossiblyCleanUp : null;
                if (nodeToRemove) {
                    nodeToPossiblyCleanUp = nodeToRemove.parent;
                    nodeToRemove.remove();
                } else {
                    nodeToPossiblyCleanUp = null;
                }
            }
        }
        var defaults = {
            // Allows you to preserve custom properties & var() usage in output.
            // `true`, `false`, or `'computed'`
            preserve: false,
            // Define variables via JS
            // Simple key-value pair
            // or an object with a `value` property and an optional `isImportant` bool property
            variables: {},
            // Preserve variables injected via JS with the `variables` option above
            // before serializing to CSS (`false` will remove these variables from output)
            preserveInjectedVariables: true,
            // Will write media queries in the same order as in the original file.
            // Currently defaulted to false for legacy behavior. We can update to `true` in a major version
            preserveAtRulesOrder: false
        };
        module2.exports = function() {
            var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var opts = extend({}, defaults, options);
            return {
                postcssPlugin: "postcss-css-variables",
                Once: function Once(css, param) {
                    var decl2 = param.decl, result = param.result, rule2 = param.rule;
                    var nodesToRemoveAtEnd = [];
                    var injectedDeclsToRemoveAtEnd = [];
                    var map = {};
                    map = extend(map, Object.keys(opts.variables).reduce(function(prevVariableMap, variableName) {
                        var variableEntry = opts.variables[variableName];
                        variableName = variableName.slice(0, 2) === "--" ? variableName : "--" + variableName;
                        var variableValue = (variableEntry || {}).value || variableEntry;
                        var isImportant = (variableEntry || {}).isImportant || false;
                        var variableRootRule = rule2({
                            selector: ":root"
                        });
                        css.root().prepend(variableRootRule);
                        var varDecl = decl2({
                            prop: variableName,
                            value: variableValue,
                            important: isImportant
                        });
                        variableRootRule.append(varDecl);
                        if (!opts.preserveInjectedVariables) {
                            injectedDeclsToRemoveAtEnd.push(varDecl);
                        }
                        prevVariableMap[variableName] = (prevVariableMap[variableName] || []).concat({
                            decl: varDecl,
                            prop: variableName,
                            calculatedInPlaceValue: variableValue,
                            isImportant: isImportant,
                            variablesUsed: [],
                            parent: variableRootRule,
                            isUnderAtRule: false
                        });
                        return prevVariableMap;
                    }, {}));
                    var logResolveValueResult = function logResolveValueResult(valueResult) {
                        var warningList = [].concat(valueResult.warnings);
                        warningList.forEach(function(warningArgs) {
                            warningArgs = [].concat(warningArgs);
                            result.warn.apply(result, warningArgs);
                        });
                        return valueResult;
                    };
                    eachCssVariableDeclaration(css, function(decl3) {
                        var declParentRule = decl3.parent;
                        var valueResults = logResolveValueResult(resolveValue(decl3, map));
                        decl3.parent.selectors.forEach(function(selector) {
                            var splitOutRule = shallowCloneNode(decl3.parent);
                            splitOutRule.selector = selector;
                            splitOutRule.parent = decl3.parent.parent;
                            var declClone = decl3.clone();
                            splitOutRule.append(declClone);
                            var prop = decl3.prop;
                            map[prop] = (map[prop] || []).concat({
                                decl: declClone,
                                prop: prop,
                                calculatedInPlaceValue: valueResults.value,
                                isImportant: decl3.important || false,
                                variablesUsed: valueResults.variablesUsed,
                                parent: splitOutRule,
                                // variables inside root or at-rules (eg. @media, @support)
                                isUnderAtRule: splitOutRule.parent.type === "atrule"
                            });
                        });
                        var preserveDecl;
                        if (typeof opts.preserve === "function") {
                            preserveDecl = opts.preserve(decl3);
                        } else {
                            preserveDecl = opts.preserve;
                        }
                        if (!preserveDecl) {
                            decl3.remove();
                        } else if (preserveDecl === "computed") {
                            decl3.value = valueResults.value;
                        }
                        if (declParentRule.nodes.length <= 0) {
                            nodesToRemoveAtEnd.push(declParentRule);
                        }
                    });
                    var rulesThatHaveDeclarationsWithVariablesList = [];
                    css.walk(function(rule3) {
                        if (rule3.nodes === void 0) return;
                        var doesRuleUseVariables = rule3.nodes.some(function(node) {
                            if (node.type === "decl") {
                                var decl3 = node;
                                if (resolveValue.RE_VAR_FUNC.test(decl3.value) && !RE_VAR_PROP.test(decl3.prop)) {
                                    return true;
                                }
                            }
                            return false;
                        });
                        if (doesRuleUseVariables) {
                            if (rule3.type === "rule" && rule3.selectors.length > 1) {
                                rule3.selectors.reverse().forEach(function(selector) {
                                    var ruleClone = rule3.cloneAfter();
                                    ruleClone.selector = selector;
                                    return ruleClone;
                                });
                                rule3.remove();
                            } else {
                                rulesThatHaveDeclarationsWithVariablesList.push(rule3);
                            }
                        }
                    });
                    rulesThatHaveDeclarationsWithVariablesList.forEach(function(rule3) {
                        rule3.nodes.slice(0).forEach(function(node) {
                            if (node.type === "decl") {
                                var decl3 = node;
                                resolveDecl(decl3, map, opts.preserve, opts.preserveAtRulesOrder, logResolveValueResult);
                            }
                        });
                    });
                    nodesToRemoveAtEnd.forEach(cleanUpNode);
                    injectedDeclsToRemoveAtEnd.forEach(function(injectedDecl) {
                        injectedDecl.remove();
                    });
                }
            };
        };
        module2.exports.postcss = true;
    }
});
// node_modules/postcss-value-parser/lib/parse.js
var require_parse2 = __commonJS({
    "node_modules/postcss-value-parser/lib/parse.js": function(exports, module2) {
        "use strict";
        init_shim();
        var openParentheses = "(".charCodeAt(0);
        var closeParentheses = ")".charCodeAt(0);
        var singleQuote = "'".charCodeAt(0);
        var doubleQuote = '"'.charCodeAt(0);
        var backslash = "\\".charCodeAt(0);
        var slash = "/".charCodeAt(0);
        var comma = ",".charCodeAt(0);
        var colon = ":".charCodeAt(0);
        var star = "*".charCodeAt(0);
        var uLower = "u".charCodeAt(0);
        var uUpper = "U".charCodeAt(0);
        var plus = "+".charCodeAt(0);
        var isUnicodeRange = /^[a-f0-9?-]+$/i;
        module2.exports = function(input) {
            var tokens = [];
            var value = input;
            var next, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
            var pos = 0;
            var code = value.charCodeAt(pos);
            var max = value.length;
            var stack = [
                {
                    nodes: tokens
                }
            ];
            var balanced = 0;
            var parent;
            var name = "";
            var before = "";
            var after = "";
            while(pos < max){
                if (code <= 32) {
                    next = pos;
                    do {
                        next += 1;
                        code = value.charCodeAt(next);
                    }while (code <= 32);
                    token = value.slice(pos, next);
                    prev = tokens[tokens.length - 1];
                    if (code === closeParentheses && balanced) {
                        after = token;
                    } else if (prev && prev.type === "div") {
                        prev.after = token;
                        prev.sourceEndIndex += token.length;
                    } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
                        before = token;
                    } else {
                        tokens.push({
                            type: "space",
                            sourceIndex: pos,
                            sourceEndIndex: next,
                            value: token
                        });
                    }
                    pos = next;
                } else if (code === singleQuote || code === doubleQuote) {
                    next = pos;
                    quote = code === singleQuote ? "'" : '"';
                    token = {
                        type: "string",
                        sourceIndex: pos,
                        quote: quote
                    };
                    do {
                        escape2 = false;
                        next = value.indexOf(quote, next + 1);
                        if (~next) {
                            escapePos = next;
                            while(value.charCodeAt(escapePos - 1) === backslash){
                                escapePos -= 1;
                                escape2 = !escape2;
                            }
                        } else {
                            value += quote;
                            next = value.length - 1;
                            token.unclosed = true;
                        }
                    }while (escape2);
                    token.value = value.slice(pos + 1, next);
                    token.sourceEndIndex = token.unclosed ? next : next + 1;
                    tokens.push(token);
                    pos = next + 1;
                    code = value.charCodeAt(pos);
                } else if (code === slash && value.charCodeAt(pos + 1) === star) {
                    next = value.indexOf("*/", pos);
                    token = {
                        type: "comment",
                        sourceIndex: pos,
                        sourceEndIndex: next + 2
                    };
                    if (next === -1) {
                        token.unclosed = true;
                        next = value.length;
                        token.sourceEndIndex = next;
                    }
                    token.value = value.slice(pos + 2, next);
                    tokens.push(token);
                    pos = next + 2;
                    code = value.charCodeAt(pos);
                } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
                    token = value[pos];
                    tokens.push({
                        type: "word",
                        sourceIndex: pos - before.length,
                        sourceEndIndex: pos + token.length,
                        value: token
                    });
                    pos += 1;
                    code = value.charCodeAt(pos);
                } else if (code === slash || code === comma || code === colon) {
                    token = value[pos];
                    tokens.push({
                        type: "div",
                        sourceIndex: pos - before.length,
                        sourceEndIndex: pos + token.length,
                        value: token,
                        before: before,
                        after: ""
                    });
                    before = "";
                    pos += 1;
                    code = value.charCodeAt(pos);
                } else if (openParentheses === code) {
                    next = pos;
                    do {
                        next += 1;
                        code = value.charCodeAt(next);
                    }while (code <= 32);
                    parenthesesOpenPos = pos;
                    token = {
                        type: "function",
                        sourceIndex: pos - name.length,
                        value: name,
                        before: value.slice(parenthesesOpenPos + 1, next)
                    };
                    pos = next;
                    if (name === "url" && code !== singleQuote && code !== doubleQuote) {
                        next -= 1;
                        do {
                            escape2 = false;
                            next = value.indexOf(")", next + 1);
                            if (~next) {
                                escapePos = next;
                                while(value.charCodeAt(escapePos - 1) === backslash){
                                    escapePos -= 1;
                                    escape2 = !escape2;
                                }
                            } else {
                                value += ")";
                                next = value.length - 1;
                                token.unclosed = true;
                            }
                        }while (escape2);
                        whitespacePos = next;
                        do {
                            whitespacePos -= 1;
                            code = value.charCodeAt(whitespacePos);
                        }while (code <= 32);
                        if (parenthesesOpenPos < whitespacePos) {
                            if (pos !== whitespacePos + 1) {
                                token.nodes = [
                                    {
                                        type: "word",
                                        sourceIndex: pos,
                                        sourceEndIndex: whitespacePos + 1,
                                        value: value.slice(pos, whitespacePos + 1)
                                    }
                                ];
                            } else {
                                token.nodes = [];
                            }
                            if (token.unclosed && whitespacePos + 1 !== next) {
                                token.after = "";
                                token.nodes.push({
                                    type: "space",
                                    sourceIndex: whitespacePos + 1,
                                    sourceEndIndex: next,
                                    value: value.slice(whitespacePos + 1, next)
                                });
                            } else {
                                token.after = value.slice(whitespacePos + 1, next);
                                token.sourceEndIndex = next;
                            }
                        } else {
                            token.after = "";
                            token.nodes = [];
                        }
                        pos = next + 1;
                        token.sourceEndIndex = token.unclosed ? next : pos;
                        code = value.charCodeAt(pos);
                        tokens.push(token);
                    } else {
                        balanced += 1;
                        token.after = "";
                        token.sourceEndIndex = pos + 1;
                        tokens.push(token);
                        stack.push(token);
                        tokens = token.nodes = [];
                        parent = token;
                    }
                    name = "";
                } else if (closeParentheses === code && balanced) {
                    pos += 1;
                    code = value.charCodeAt(pos);
                    parent.after = after;
                    parent.sourceEndIndex += after.length;
                    after = "";
                    balanced -= 1;
                    stack[stack.length - 1].sourceEndIndex = pos;
                    stack.pop();
                    parent = stack[balanced];
                    tokens = parent.nodes;
                } else {
                    next = pos;
                    do {
                        if (code === backslash) {
                            next += 1;
                        }
                        next += 1;
                        code = value.charCodeAt(next);
                    }while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
                    token = value.slice(pos, next);
                    if (openParentheses === code) {
                        name = token;
                    } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
                        tokens.push({
                            type: "unicode-range",
                            sourceIndex: pos,
                            sourceEndIndex: next,
                            value: token
                        });
                    } else {
                        tokens.push({
                            type: "word",
                            sourceIndex: pos,
                            sourceEndIndex: next,
                            value: token
                        });
                    }
                    pos = next;
                }
            }
            for(pos = stack.length - 1; pos; pos -= 1){
                stack[pos].unclosed = true;
                stack[pos].sourceEndIndex = value.length;
            }
            return stack[0].nodes;
        };
    }
});
// node_modules/postcss-value-parser/lib/walk.js
var require_walk = __commonJS({
    "node_modules/postcss-value-parser/lib/walk.js": function(exports, module2) {
        "use strict";
        init_shim();
        module2.exports = function walk(nodes, cb, bubble) {
            var i2, max, node, result;
            for(i2 = 0, max = nodes.length; i2 < max; i2 += 1){
                node = nodes[i2];
                if (!bubble) {
                    result = cb(node, i2, nodes);
                }
                if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
                    walk(node.nodes, cb, bubble);
                }
                if (bubble) {
                    cb(node, i2, nodes);
                }
            }
        };
    }
});
// node_modules/postcss-value-parser/lib/stringify.js
var require_stringify2 = __commonJS({
    "node_modules/postcss-value-parser/lib/stringify.js": function(exports, module2) {
        "use strict";
        init_shim();
        function stringifyNode(node, custom) {
            var type = node.type;
            var value = node.value;
            var buf;
            var customResult;
            if (custom && (customResult = custom(node)) !== void 0) {
                return customResult;
            } else if (type === "word" || type === "space") {
                return value;
            } else if (type === "string") {
                buf = node.quote || "";
                return buf + value + (node.unclosed ? "" : buf);
            } else if (type === "comment") {
                return "/*" + value + (node.unclosed ? "" : "*/");
            } else if (type === "div") {
                return (node.before || "") + value + (node.after || "");
            } else if (Array.isArray(node.nodes)) {
                buf = stringify4(node.nodes, custom);
                if (type !== "function") {
                    return buf;
                }
                return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
            }
            return value;
        }
        function stringify4(nodes, custom) {
            var result, i2;
            if (Array.isArray(nodes)) {
                result = "";
                for(i2 = nodes.length - 1; ~i2; i2 -= 1){
                    result = stringifyNode(nodes[i2], custom) + result;
                }
                return result;
            }
            return stringifyNode(nodes, custom);
        }
        module2.exports = stringify4;
    }
});
// node_modules/postcss-value-parser/lib/unit.js
var require_unit = __commonJS({
    "node_modules/postcss-value-parser/lib/unit.js": function(exports, module2) {
        "use strict";
        init_shim();
        var minus = "-".charCodeAt(0);
        var plus = "+".charCodeAt(0);
        var dot = ".".charCodeAt(0);
        var exp = "e".charCodeAt(0);
        var EXP = "E".charCodeAt(0);
        function likeNumber(value) {
            var code = value.charCodeAt(0);
            var nextCode;
            if (code === plus || code === minus) {
                nextCode = value.charCodeAt(1);
                if (nextCode >= 48 && nextCode <= 57) {
                    return true;
                }
                var nextNextCode = value.charCodeAt(2);
                if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
                    return true;
                }
                return false;
            }
            if (code === dot) {
                nextCode = value.charCodeAt(1);
                if (nextCode >= 48 && nextCode <= 57) {
                    return true;
                }
                return false;
            }
            if (code >= 48 && code <= 57) {
                return true;
            }
            return false;
        }
        module2.exports = function(value) {
            var pos = 0;
            var length = value.length;
            var code;
            var nextCode;
            var nextNextCode;
            if (length === 0 || !likeNumber(value)) {
                return false;
            }
            code = value.charCodeAt(pos);
            if (code === plus || code === minus) {
                pos++;
            }
            while(pos < length){
                code = value.charCodeAt(pos);
                if (code < 48 || code > 57) {
                    break;
                }
                pos += 1;
            }
            code = value.charCodeAt(pos);
            nextCode = value.charCodeAt(pos + 1);
            if (code === dot && nextCode >= 48 && nextCode <= 57) {
                pos += 2;
                while(pos < length){
                    code = value.charCodeAt(pos);
                    if (code < 48 || code > 57) {
                        break;
                    }
                    pos += 1;
                }
            }
            code = value.charCodeAt(pos);
            nextCode = value.charCodeAt(pos + 1);
            nextNextCode = value.charCodeAt(pos + 2);
            if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
                pos += nextCode === plus || nextCode === minus ? 3 : 2;
                while(pos < length){
                    code = value.charCodeAt(pos);
                    if (code < 48 || code > 57) {
                        break;
                    }
                    pos += 1;
                }
            }
            return {
                number: value.slice(0, pos),
                unit: value.slice(pos)
            };
        };
    }
});
// node_modules/postcss-value-parser/lib/index.js
var require_lib = __commonJS({
    "node_modules/postcss-value-parser/lib/index.js": function(exports, module2) {
        "use strict";
        init_shim();
        var parse5 = require_parse2();
        var walk = require_walk();
        var stringify4 = require_stringify2();
        function ValueParser(value) {
            if (_instanceof(this, ValueParser)) {
                this.nodes = parse5(value);
                return this;
            }
            return new ValueParser(value);
        }
        ValueParser.prototype.toString = function() {
            return Array.isArray(this.nodes) ? stringify4(this.nodes) : "";
        };
        ValueParser.prototype.walk = function(cb, bubble) {
            walk(this.nodes, cb, bubble);
            return this;
        };
        ValueParser.unit = require_unit();
        ValueParser.walk = walk;
        ValueParser.stringify = stringify4;
        module2.exports = ValueParser;
    }
});
// node_modules/postcss-logical/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
    default: function() {
        return creator;
    }
});
function directionFlowToAxes(r2) {
    switch(r2){
        case t.TopToBottom:
            return [
                i.Top,
                i.Bottom
            ];
        case t.BottomToTop:
            return [
                i.Bottom,
                i.Top
            ];
        case t.RightToLeft:
            return [
                i.Right,
                i.Left
            ];
        case t.LeftToRight:
            return [
                i.Left,
                i.Right
            ];
    }
}
function cloneDeclaration(r2, e2, n2) {
    return r2.parent && r2.parent.some(function(r3) {
        return "decl" == r3.type && r3.prop === n2 && r3.value === e2;
    }) ? [] : [
        r2.clone({
            value: e2,
            prop: n2
        })
    ];
}
function transformTransition(e2, n2, o2) {
    var t2 = e2.prop, i2 = e2.value, l = (0, import_postcss_value_parser.default)(i2), a = [];
    var s = [];
    l.nodes.forEach(function(r2) {
        if ("div" === r2.type && "," === r2.value) return a.push(s), void (s = []);
        s.push(r2);
    }), a.push(s);
    for(var r2 = 0; r2 < a.length; r2++){
        var e3 = a[r2];
        for(var t3 = 0; t3 < e3.length; t3++){
            var i3 = e3[t3];
            if ("word" !== i3.type) continue;
            var l2 = i3.value.toLowerCase(), s2 = o2[l2];
            if (!s2) continue;
            var d2 = s2(n2.decl({
                prop: l2,
                value: "initial"
            }));
            if (0 !== d2.length) {
                for(var n3 = d2.length - 1; n3 >= 0; n3--){
                    var o3 = JSON.parse(JSON.stringify(e3));
                    o3[t3].value = d2[n3].prop, a.splice(r2 + 1, 0, o3);
                }
                a.splice(r2, 1), r2++;
            }
        }
    }
    var d = [];
    for(var r21 = 0; r21 < a.length; r21++){
        var _d;
        var e31 = a[r21];
        (_d = d).push.apply(_d, _to_consumable_array(e31)), r21 !== a.length - 1 && d.push({
            type: "div",
            value: ",",
            sourceIndex: 0,
            sourceEndIndex: 0,
            before: "",
            after: " "
        });
    }
    var c = import_postcss_value_parser.default.stringify(d);
    return c !== i2 ? cloneDeclaration(e2, c, t2) : [];
}
function parseValueCouple(e2) {
    var n2 = (0, import_postcss_value_parser.default)(e2.value).nodes.filter(function(r2) {
        return "space" !== r2.type;
    });
    if (n2.length > 2 || 0 === n2.length) {
        var r2 = "[postcss-logical] Invalid number of values for ".concat(e2.prop, ". Found ").concat(n2.length, " values, expected 1 or 2.");
        throw e2.error(r2);
    }
    var o2, t2;
    return 1 === n2.length ? (o2 = import_postcss_value_parser.default.stringify(n2[0]), t2 = o2) : (o2 = import_postcss_value_parser.default.stringify(n2[0]), t2 = import_postcss_value_parser.default.stringify(n2[1])), [
        o2,
        t2
    ];
}
function transformBorder(r2, e2) {
    return function(n2) {
        return cloneDeclaration(n2, n2.value, "border-".concat(e2, "-").concat(r2));
    };
}
function transformBorderProperty(r2, e2) {
    return function(n2) {
        var _e2 = _sliced_to_array(e2, 2), o2 = _e2[0], t2 = _e2[1], _parseValueCouple = _sliced_to_array(parseValueCouple(n2), 2), i2 = _parseValueCouple[0], l = _parseValueCouple[1];
        return _to_consumable_array(cloneDeclaration(n2, i2, "border-".concat(o2, "-").concat(r2))).concat(_to_consumable_array(cloneDeclaration(n2, l, "border-".concat(t2, "-").concat(r2))));
    };
}
function transformBorderShorthand(r2) {
    return function(e2) {
        return r2.flatMap(function(r3) {
            return cloneDeclaration(e2, e2.value, "border-".concat(r3));
        });
    };
}
function transformBorderRadius(r2) {
    return function(e2) {
        var n2;
        switch(e2.prop.toLowerCase()){
            case "border-start-start-radius":
                n2 = "border-".concat(r2.inlineIsHorizontal ? "".concat(r2.block[0], "-").concat(r2.inline[0]) : "".concat(r2.inline[0], "-").concat(r2.block[0]), "-radius");
                break;
            case "border-start-end-radius":
                n2 = "border-".concat(r2.inlineIsHorizontal ? "".concat(r2.block[0], "-").concat(r2.inline[1]) : "".concat(r2.inline[1], "-").concat(r2.block[0]), "-radius");
                break;
            case "border-end-start-radius":
                n2 = "border-".concat(r2.inlineIsHorizontal ? "".concat(r2.block[1], "-").concat(r2.inline[0]) : "".concat(r2.inline[0], "-").concat(r2.block[1]), "-radius");
                break;
            case "border-end-end-radius":
                n2 = "border-".concat(r2.inlineIsHorizontal ? "".concat(r2.block[1], "-").concat(r2.inline[1]) : "".concat(r2.inline[1], "-").concat(r2.block[1]), "-radius");
                break;
        }
        return n2 ? cloneDeclaration(e2, e2.value, n2) : [];
    };
}
function transformLogicalSize(r2) {
    return function(e2) {
        var n2 = e2.value, o2 = r2.inlineIsHorizontal ? "width" : "height", t2 = r2.inlineIsHorizontal ? "height" : "width", i2 = e2.prop.toLowerCase().replace("inline-size", o2).replace("block-size", t2);
        return cloneDeclaration(e2, n2, i2);
    };
}
function transformOffset(r2) {
    return function(e2) {
        return cloneDeclaration(e2, e2.value, r2);
    };
}
function transformOffsetShorthand(r2) {
    return function(e2) {
        var _r2 = _sliced_to_array(r2, 2), n2 = _r2[0], o2 = _r2[1], _parseValueCouple = _sliced_to_array(parseValueCouple(e2), 2), t2 = _parseValueCouple[0], i2 = _parseValueCouple[1];
        return _to_consumable_array(cloneDeclaration(e2, t2, n2)).concat(_to_consumable_array(cloneDeclaration(e2, i2, o2)));
    };
}
function transformSide(r2, e2) {
    return function(n2) {
        return cloneDeclaration(n2, n2.value, "".concat(r2, "-").concat(e2));
    };
}
function transformSideShorthand(r2, e2) {
    return function(n2) {
        var _e2 = _sliced_to_array(e2, 2), o2 = _e2[0], t2 = _e2[1], _parseValueCouple = _sliced_to_array(parseValueCouple(n2), 2), i2 = _parseValueCouple[0], l = _parseValueCouple[1];
        return _to_consumable_array(cloneDeclaration(n2, i2, "".concat(r2, "-").concat(o2))).concat(_to_consumable_array(cloneDeclaration(n2, l, "".concat(r2, "-").concat(t2))));
    };
}
function logicalToPhysical(r2, e2) {
    var _e2_block = _sliced_to_array(e2.block, 2), n2 = _e2_block[0], t2 = _e2_block[1], _e2_inline = _sliced_to_array(e2.inline, 2), i2 = _e2_inline[0], l = _e2_inline[1];
    switch(r2){
        case o.BlockStart:
            return n2;
        case o.BlockEnd:
            return t2;
        case o.InlineStart:
            return i2;
        case o.InlineEnd:
            return l;
        default:
            throw new Error("Unsupported logical direction");
    }
}
function doTransform(e2, n2, o2) {
    var t2 = e2.prop, i2 = e2.value, l = (0, import_postcss_value_parser.default)(i2);
    l.nodes.forEach(function(r2) {
        if ("word" === r2.type) {
            var e3 = r2.value.toLowerCase();
            n2.includes(e3) && (r2.value = logicalToPhysical(e3, o2));
        }
    });
    var a = l.toString();
    return a !== i2 ? cloneDeclaration(e2, a, t2) : [];
}
function prepareTransforms(e2, t2, i2, l, a) {
    return {
        "caption-side": (d = e2, function(r2) {
            return doTransform(r2, Object.values(o), d);
        }),
        "text-align": e2.inlineIsHorizontal ? (s = e2.inline, function(e3) {
            var o2 = e3.prop, t3 = e3.value, i3 = (0, import_postcss_value_parser.default)(t3), _s = _sliced_to_array(s, 2), l2 = _s[0], a2 = _s[1];
            i3.nodes.forEach(function(r2) {
                if ("word" === r2.type) {
                    var e4 = r2.value.toLowerCase();
                    if (e4 === n.End) return void (r2.value = a2);
                    e4 === n.Start && (r2.value = l2);
                }
            });
            var d2 = i3.toString();
            return d2 !== t3 ? cloneDeclaration(e3, d2, o2) : [];
        }) : null,
        "block-size": transformLogicalSize(e2),
        "inline-size": transformLogicalSize(e2),
        "min-block-size": transformLogicalSize(e2),
        "max-block-size": transformLogicalSize(e2),
        "min-inline-size": transformLogicalSize(e2),
        "max-inline-size": transformLogicalSize(e2),
        "margin-block-start": transformSide("margin", t2),
        "margin-block-end": transformSide("margin", i2),
        "margin-inline-start": transformSide("margin", l),
        "margin-inline-end": transformSide("margin", a),
        "margin-block": transformSideShorthand("margin", e2.block),
        "margin-inline": transformSideShorthand("margin", e2.inline),
        "inset-block": transformOffsetShorthand(e2.block),
        "inset-block-start": transformOffset(t2),
        "inset-block-end": transformOffset(i2),
        "inset-inline": transformOffsetShorthand(e2.inline),
        "inset-inline-start": transformOffset(l),
        "inset-inline-end": transformOffset(a),
        inset: function(e3) {
            var n2 = (0, import_postcss_value_parser.default)(e3.value).nodes.filter(function(r2) {
                return "space" !== r2.type && "comment" !== r2.type;
            });
            if (n2.length > 4) {
                var r2 = "[postcss-logical] Invalid number of values for ".concat(e3.prop, ". Found ").concat(n2.length, " values, expected up to 4 values.");
                throw e3.error(r2);
            }
            var o2, t3, i3, l2;
            if (1 === n2.length) o2 = import_postcss_value_parser.default.stringify(n2[0]), t3 = o2, i3 = o2, l2 = o2;
            else if (2 === n2.length) o2 = import_postcss_value_parser.default.stringify(n2[0]), t3 = import_postcss_value_parser.default.stringify(n2[1]), i3 = o2, l2 = t3;
            else if (3 === n2.length) o2 = import_postcss_value_parser.default.stringify(n2[0]), t3 = import_postcss_value_parser.default.stringify(n2[1]), l2 = t3, i3 = import_postcss_value_parser.default.stringify(n2[2]);
            else {
                if (4 !== n2.length) return [];
                o2 = import_postcss_value_parser.default.stringify(n2[0]), t3 = import_postcss_value_parser.default.stringify(n2[1]), i3 = import_postcss_value_parser.default.stringify(n2[2]), l2 = import_postcss_value_parser.default.stringify(n2[3]);
            }
            return _to_consumable_array(cloneDeclaration(e3, o2, "top")).concat(_to_consumable_array(cloneDeclaration(e3, t3, "right")), _to_consumable_array(cloneDeclaration(e3, i3, "bottom")), _to_consumable_array(cloneDeclaration(e3, l2, "left")));
        },
        "padding-block-start": transformSide("padding", t2),
        "padding-block-end": transformSide("padding", i2),
        "padding-inline-start": transformSide("padding", l),
        "padding-inline-end": transformSide("padding", a),
        "padding-block": transformSideShorthand("padding", e2.block),
        "padding-inline": transformSideShorthand("padding", e2.inline),
        "border-block-start-width": transformBorder("width", t2),
        "border-block-end-width": transformBorder("width", i2),
        "border-inline-start-width": transformBorder("width", l),
        "border-inline-end-width": transformBorder("width", a),
        "border-block-width": transformBorderProperty("width", e2.block),
        "border-inline-width": transformBorderProperty("width", e2.inline),
        "border-block-start-style": transformBorder("style", t2),
        "border-block-end-style": transformBorder("style", i2),
        "border-inline-start-style": transformBorder("style", l),
        "border-inline-end-style": transformBorder("style", a),
        "border-block-style": transformBorderProperty("style", e2.block),
        "border-inline-style": transformBorderProperty("style", e2.inline),
        "border-block-start-color": transformBorder("color", t2),
        "border-block-end-color": transformBorder("color", i2),
        "border-inline-start-color": transformBorder("color", l),
        "border-inline-end-color": transformBorder("color", a),
        "border-block-color": transformBorderProperty("color", e2.block),
        "border-inline-color": transformBorderProperty("color", e2.inline),
        "border-block": transformBorderShorthand(e2.block),
        "border-block-start": transformBorderShorthand([
            t2
        ]),
        "border-block-end": transformBorderShorthand([
            i2
        ]),
        "border-inline": transformBorderShorthand(e2.inline),
        "border-inline-start": transformBorderShorthand([
            l
        ]),
        "border-inline-end": transformBorderShorthand([
            a
        ]),
        "border-start-start-radius": transformBorderRadius(e2),
        "border-start-end-radius": transformBorderRadius(e2),
        "border-end-start-radius": transformBorderRadius(e2),
        "border-end-end-radius": transformBorderRadius(e2)
    };
    var s, d;
}
var import_postcss_value_parser, e, n, o, t, i, creator;
var init_dist = __esm({
    "node_modules/postcss-logical/dist/index.mjs": function() {
        "use strict";
        init_shim();
        import_postcss_value_parser = __toESM(require_lib(), 1);
        !function(r2) {
            r2.Block = "block", r2.Inline = "inline";
        }(e || (e = {})), function(r2) {
            r2.Start = "start", r2.End = "end";
        }(n || (n = {}));
        o = {
            BlockStart: "block-start",
            BlockEnd: "block-end",
            InlineStart: "inline-start",
            InlineEnd: "inline-end"
        };
        !function(r2) {
            r2.TopToBottom = "top-to-bottom", r2.BottomToTop = "bottom-to-top", r2.RightToLeft = "right-to-left", r2.LeftToRight = "left-to-right";
        }(t || (t = {})), function(r2) {
            r2.Top = "top", r2.Right = "right", r2.Bottom = "bottom", r2.Left = "left";
        }(i || (i = {}));
        creator = function(r2) {
            var e2 = Object.assign({
                blockDirection: t.TopToBottom,
                inlineDirection: t.LeftToRight
            }, r2), n2 = Object.values(t);
            if (!n2.includes(e2.blockDirection)) throw new Error('[postcss-logical] "blockDirection" must be one of '.concat(n2.join(", ")));
            if (!n2.includes(e2.inlineDirection)) throw new Error('[postcss-logical] "inlineDirection" must be one of '.concat(n2.join(", ")));
            var _directionFlowToAxes = _sliced_to_array(directionFlowToAxes(e2.blockDirection), 2), o2 = _directionFlowToAxes[0], l = _directionFlowToAxes[1], _directionFlowToAxes1 = _sliced_to_array(directionFlowToAxes(e2.inlineDirection), 2), a = _directionFlowToAxes1[0], s = _directionFlowToAxes1[1];
            if (!Object.values(i).every(function(r3) {
                return [
                    o2,
                    l,
                    a,
                    s
                ].includes(r3);
            })) throw new Error('[postcss-logical] "blockDirection" and "inlineDirection" must be on separate axes');
            var makeTransform = function(r3) {
                return function(e3, param) {
                    var n3 = param.result;
                    if (!r3) return;
                    var o3 = [];
                    try {
                        o3 = r3(e3);
                    } catch (r4) {
                        return void e3.warn(n3, _instanceof(r4, Error) ? r4.message : String(r4));
                    }
                    (o3 === null || o3 === void 0 ? void 0 : o3.length) && (o3.forEach(function(r4) {
                        e3.cloneBefore(r4);
                    }), e3.remove());
                };
            }, d = prepareTransforms({
                block: [
                    o2,
                    l
                ],
                inline: [
                    a,
                    s
                ],
                inlineIsHorizontal: [
                    t.LeftToRight,
                    t.RightToLeft
                ].includes(e2.inlineDirection)
            }, o2, l, a, s);
            return {
                postcssPlugin: "postcss-logical",
                Declaration: {
                    "caption-side": makeTransform(d["caption-side"]),
                    "text-align": makeTransform(d["text-align"]),
                    "block-size": makeTransform(d["block-size"]),
                    "inline-size": makeTransform(d["inline-size"]),
                    "min-block-size": makeTransform(d["min-block-size"]),
                    "max-block-size": makeTransform(d["max-block-size"]),
                    "min-inline-size": makeTransform(d["min-inline-size"]),
                    "max-inline-size": makeTransform(d["max-inline-size"]),
                    "margin-block-start": makeTransform(d["margin-block-start"]),
                    "margin-block-end": makeTransform(d["margin-block-end"]),
                    "margin-inline-start": makeTransform(d["margin-inline-start"]),
                    "margin-inline-end": makeTransform(d["margin-inline-end"]),
                    "margin-block": makeTransform(d["margin-block"]),
                    "margin-inline": makeTransform(d["margin-inline"]),
                    "inset-block": makeTransform(d["inset-block"]),
                    "inset-block-start": makeTransform(d["inset-block-start"]),
                    "inset-block-end": makeTransform(d["inset-block-end"]),
                    "inset-inline": makeTransform(d["inset-inline"]),
                    "inset-inline-start": makeTransform(d["inset-inline-start"]),
                    "inset-inline-end": makeTransform(d["inset-inline-end"]),
                    inset: makeTransform(d.inset),
                    "padding-block-start": makeTransform(d["padding-block-start"]),
                    "padding-block-end": makeTransform(d["padding-block-end"]),
                    "padding-inline-start": makeTransform(d["padding-inline-start"]),
                    "padding-inline-end": makeTransform(d["padding-inline-end"]),
                    "padding-block": makeTransform(d["padding-block"]),
                    "padding-inline": makeTransform(d["padding-inline"]),
                    "border-block-start-width": makeTransform(d["border-block-start-width"]),
                    "border-block-end-width": makeTransform(d["border-block-end-width"]),
                    "border-inline-start-width": makeTransform(d["border-inline-start-width"]),
                    "border-inline-end-width": makeTransform(d["border-inline-end-width"]),
                    "border-block-width": makeTransform(d["border-block-width"]),
                    "border-inline-width": makeTransform(d["border-inline-width"]),
                    "border-block-start-style": makeTransform(d["border-block-start-style"]),
                    "border-block-end-style": makeTransform(d["border-block-end-style"]),
                    "border-inline-start-style": makeTransform(d["border-inline-start-style"]),
                    "border-inline-end-style": makeTransform(d["border-inline-end-style"]),
                    "border-block-style": makeTransform(d["border-block-style"]),
                    "border-inline-style": makeTransform(d["border-inline-style"]),
                    "border-block-start-color": makeTransform(d["border-block-start-color"]),
                    "border-block-end-color": makeTransform(d["border-block-end-color"]),
                    "border-inline-start-color": makeTransform(d["border-inline-start-color"]),
                    "border-inline-end-color": makeTransform(d["border-inline-end-color"]),
                    "border-block-color": makeTransform(d["border-block-color"]),
                    "border-inline-color": makeTransform(d["border-inline-color"]),
                    "border-block": makeTransform(d["border-block"]),
                    "border-block-start": makeTransform(d["border-block-start"]),
                    "border-block-end": makeTransform(d["border-block-end"]),
                    "border-inline": makeTransform(d["border-inline"]),
                    "border-inline-start": makeTransform(d["border-inline-start"]),
                    "border-inline-end": makeTransform(d["border-inline-end"]),
                    "border-start-start-radius": makeTransform(d["border-start-start-radius"]),
                    "border-start-end-radius": makeTransform(d["border-start-end-radius"]),
                    "border-end-start-radius": makeTransform(d["border-end-start-radius"]),
                    "border-end-end-radius": makeTransform(d["border-end-end-radius"]),
                    transition: function(r3, param) {
                        var e3 = param.result, n3 = param.postcss;
                        var o3 = [];
                        try {
                            o3 = transformTransition(r3, n3, d);
                        } catch (n4) {
                            return void r3.warn(e3, _instanceof(n4, Error) ? n4.message : String(n4));
                        }
                        (o3 === null || o3 === void 0 ? void 0 : o3.length) && (o3.forEach(function(e4) {
                            r3.cloneBefore(e4);
                        }), r3.remove());
                    }
                }
            };
        };
        creator.postcss = true;
    }
});
// src/client.ts
var client_exports = {};
__export(client_exports, {
    CSS: function() {
        return CSS;
    },
    CurrentPageTop: function() {
        return CurrentPageTop;
    },
    FloatBottom: function() {
        return FloatBottom;
    },
    Footnote: function() {
        return Footnote;
    },
    Latex: function() {
        return Latex;
    },
    Markdown: function() {
        return Markdown;
    },
    NoBreak: function() {
        return NoBreak;
    },
    PageBottom: function() {
        return PageBottom;
    },
    PageBreak: function() {
        return PageBreak;
    },
    PageNumber: function() {
        return PageNumber;
    },
    PageTop: function() {
        return PageTop;
    },
    PagesNumber: function() {
        return PagesNumber;
    },
    RunningH1: function() {
        return RunningH1;
    },
    RunningH2: function() {
        return RunningH2;
    },
    RunningH3: function() {
        return RunningH3;
    },
    RunningH4: function() {
        return RunningH4;
    },
    RunningH5: function() {
        return RunningH5;
    },
    RunningH6: function() {
        return RunningH6;
    },
    compile: function() {
        return compile;
    }
});
module.exports = __toCommonJS(client_exports);
init_shim();
// src/variables/variables.tsx
init_shim();
var import_react2 = __toESM(require("react"));
// src/shell/shell.tsx
init_shim();
var import_react = __toESM(require("react"));
var PageTop = function(props) {
    return /* @__PURE__ */ import_react.default.createElement("div", _object_spread_props(_object_spread({}, props), {
        className: "--onedoc-page-top ".concat((props === null || props === void 0 ? void 0 : props.className) || "")
    }));
};
var CurrentPageTop = function(props) {
    return /* @__PURE__ */ import_react.default.createElement("div", _object_spread_props(_object_spread({}, props), {
        className: "--onedoc-current-page-top ".concat((props === null || props === void 0 ? void 0 : props.className) || "")
    }));
};
var PageBottom = function(props) {
    return /* @__PURE__ */ import_react.default.createElement("div", _object_spread_props(_object_spread({}, props), {
        className: "--onedoc-page-bottom ".concat((props === null || props === void 0 ? void 0 : props.className) || "")
    }));
};
var PageBreak = function(props) {
    return /* @__PURE__ */ import_react.default.createElement("div", _object_spread_props(_object_spread({}, props), {
        className: "--onedoc-page-break ".concat((props === null || props === void 0 ? void 0 : props.className) || "")
    }));
};
var NoBreak = function(props) {
    return /* @__PURE__ */ import_react.default.createElement("div", _object_spread_props(_object_spread({}, props), {
        className: "--onedoc-no-break ".concat((props === null || props === void 0 ? void 0 : props.className) || "")
    }));
};
var FloatBottom = function(props) {
    return /* @__PURE__ */ import_react.default.createElement("div", _object_spread_props(_object_spread({}, props), {
        style: {
            PrinceFloat: "bottom"
        }
    }), props.children);
};
// src/variables/variables.tsx
var PageNumber = function(param) {
    var _param_counterStyle = param.counterStyle, counterStyle = _param_counterStyle === void 0 ? "decimal" : _param_counterStyle;
    return /* @__PURE__ */ import_react2.default.createElement("span", {
        style: {
            content: "counter(page, ".concat(counterStyle, ")")
        }
    });
};
var PagesNumber = function(param) {
    var _param_counterStyle = param.counterStyle, counterStyle = _param_counterStyle === void 0 ? "decimal" : _param_counterStyle;
    return /* @__PURE__ */ import_react2.default.createElement("span", {
        style: {
            content: "counter(pages, ".concat(counterStyle, ")")
        }
    });
};
var RunningHeader = function(level) {
    return function(param) {
        var _param_before = param.before, before = _param_before === void 0 ? "" : _param_before, _param_after = param.after, after = _param_after === void 0 ? "" : _param_after;
        return /* @__PURE__ */ import_react2.default.createElement("span", {
            className: "--onedoc-heading-contents --onedoc-h".concat(level, "-contents"),
            "data-before": before,
            "data-after": after
        });
    };
};
var RunningH1 = RunningHeader(1);
var RunningH2 = RunningHeader(2);
var RunningH3 = RunningHeader(3);
var RunningH4 = RunningHeader(4);
var RunningH5 = RunningHeader(5);
var RunningH6 = RunningHeader(6);
var __docConfig = {
    name: "Variables",
    icon: "subscript",
    description: "Display dynamic values based on your document, such as page numbers and running headers.",
    components: {
        PageNumber: {
            server: true,
            client: true,
            examples: {
                default: {
                    template: /* @__PURE__ */ import_react2.default.createElement(PageNumber, {
                        counterStyle: "decimal"
                    })
                },
                customStyle: {
                    description: "You can use a custom CSS counter-style, by passing a known name or a custom counter style.",
                    template: /* @__PURE__ */ import_react2.default.createElement(PageNumber, {
                        counterStyle: "lower-roman"
                    })
                }
            }
        },
        PagesNumber: {
            server: true,
            client: true,
            examples: {
                default: {
                    imports: [
                        "PageNumber"
                    ],
                    template: /* @__PURE__ */ import_react2.default.createElement(import_react2.default.Fragment, null, /* @__PURE__ */ import_react2.default.createElement(PageNumber, {
                        counterStyle: "decimal"
                    }), " of ", /* @__PURE__ */ import_react2.default.createElement(PagesNumber, {
                        counterStyle: "decimal"
                    }))
                }
            }
        },
        RunningH1: {
            server: true,
            client: true,
            examples: {
                default: {
                    description: "Show the current running header of level 1 in the page header. All running headers are reset when any of their parent headings are encountered (e.g. a level 2 heading resets the level 3, 4, 5 and 6 headings).",
                    template: /* @__PURE__ */ import_react2.default.createElement(import_react2.default.Fragment, null, /* @__PURE__ */ import_react2.default.createElement(PageTop, {
                        style: {
                            paddingTop: "1rem"
                        }
                    }, /* @__PURE__ */ import_react2.default.createElement(RunningH1, null)), /* @__PURE__ */ import_react2.default.createElement("h1", null, "Heading of level 1"))
                }
            }
        },
        RunningH2: {
            server: true,
            client: true
        },
        RunningH3: {
            server: true,
            client: true
        },
        RunningH4: {
            server: true,
            client: true
        },
        RunningH5: {
            server: true,
            client: true
        },
        RunningH6: {
            server: true,
            client: true
        }
    }
};
// src/footnote/footnote.tsx
init_shim();
var import_react3 = __toESM(require("react"));
var Footnote = function(_param) {
    var children = _param.children, props = _object_without_properties(_param, [
        "children"
    ]);
    return /* @__PURE__ */ import_react3.default.createElement("span", _object_spread({
        className: "--onedoc-footnote text-left text-xs font-normal"
    }, props), children);
};
// src/compile/compile.tsx
init_shim();
var import_react5 = __toESM(require("react"));
// raw-loader:../../dist/index.css?raw
var dist_default = '/* src/generic.css */\n.hyphenate {\n  hyphens: auto;\n}\ninput,\nselect option {\n  -prince-pdf-form: enable;\n}\n\n/* src/variables/headings.css */\nh1 {\n  string-set: onedocH1Contents contents onedocH2Contents "" onedocH3Contents "" onedocH4Contents "" onedocH5Contents "" onedocH6Contents "";\n}\nh2 {\n  string-set: onedocH2Contents contents onedocH3Contents "" onedocH4Contents "" onedocH5Contents "" onedocH6Contents "";\n}\nh3 {\n  string-set: onedocH3Contents contents onedocH4Contents "" onedocH5Contents "" onedocH6Contents "";\n}\nh4 {\n  string-set: onedocH4Contents contents onedocH5Contents "" onedocH6Contents "";\n}\nh5 {\n  string-set: onedocH5Contents contents onedocH6Contents "";\n}\nh6 {\n  string-set: onedocH6Contents contents;\n}\n.--onedoc-heading-contents:not(:empty)::before {\n  content: attr(data-before);\n}\n.--onedoc-heading-contents:not(:empty)::after {\n  content: attr(data-after);\n}\n.--onedoc-h1-contents {\n  content: string(onedocH1Contents);\n}\n.--onedoc-h2-contents {\n  content: string(onedocH2Contents);\n}\n.--onedoc-h3-contents {\n  content: string(onedocH3Contents);\n}\n.--onedoc-h4-contents {\n  content: string(onedocH4Contents);\n}\n.--onedoc-h5-contents {\n  content: string(onedocH5Contents);\n}\n.--onedoc-h6-contents {\n  content: string(onedocH6Contents);\n}\n\n/* src/variables/variables.css */\n\n/* src/shell/shell.css */\n@page {\n  @top-left {\n    content: flow(--onedoc-page-top);\n    position: relative;\n  }\n  @bottom-left {\n    content: flow(--onedoc-page-bottom);\n    position: relative;\n  }\n}\n.--onedoc-page-top {\n  -prince-flow: static(--onedoc-page-top);\n  width: 100%;\n  height: 100%;\n}\n.--onedoc-current-page-top {\n  position: --onedoc-page-top;\n  width: 100%;\n  height: 100%;\n}\n.--onedoc-page-bottom {\n  -prince-flow: static(--onedoc-page-bottom);\n  width: 100%;\n  height: 100%;\n}\n.--onedoc-page-break {\n  page-break-after: always;\n}\n.--onedoc-no-break {\n  page-break-inside: avoid;\n}\n\n/* src/footnote/footnote.css */\n.--onedoc-footnote {\n  float: footnote;\n  footnote-style-position: inside;\n}\n/*# sourceMappingURL=index.css.map */';
// src/css/css.tsx
init_shim();
var import_react4 = __toESM(require("react"));
var import_html_entities = require("html-entities");
var allowedEntities = {
    "&apos;": "'",
    "&quot;": '"'
};
var CSS = function(param) {
    var children = param.children;
    var contents = (0, import_html_entities.encode)(children);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = Object.entries(allowedEntities)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var _step_value = _sliced_to_array(_step.value, 2), entity = _step_value[0], value = _step_value[1];
            contents = contents.replace(new RegExp(entity, "g"), value);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return /* @__PURE__ */ import_react4.default.createElement("style", {
        dangerouslySetInnerHTML: {
            __html: contents
        }
    });
};
var __docConfig2 = {
    name: "CSS",
    icon: "css3-alt",
    description: "Allows adding CSS to the document while securely parsing and escaping it.\n\nNB: While you can add regular CSS with the `<style>` tag, it's recommended to use the `CSS` component to ensure that the CSS is properly escaped, most notably when using URLs or other potentially unsafe content.",
    components: {
        CSS: {
            server: true,
            client: true,
            examples: {
                default: {
                    description: "Use a simple CSS print property to set the page size.",
                    template: /* @__PURE__ */ import_react4.default.createElement(CSS, null, "@page { size: a4 landscape; }")
                },
                loadFont: {
                    name: "Load a Google Font",
                    description: "Load a Google Font using the `@import` rule.",
                    template: /* @__PURE__ */ import_react4.default.createElement(import_react4.default.Fragment, null, /* @__PURE__ */ import_react4.default.createElement(CSS, null, "@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap');"), /* @__PURE__ */ import_react4.default.createElement("p", {
                        style: {
                            fontFamily: "Roboto, sans-serif"
                        }
                    }, "This text uses the Roboto Light font."))
                },
                layout: {
                    name: "Layout",
                    description: "You can use the `@page` at-rule in CSS to manage all aspects of printed pages. More on this [here](https://developer.mozilla.org/en-US/docs/Web/CSS/@page).",
                    template: /* @__PURE__ */ import_react4.default.createElement(import_react4.default.Fragment, null, /* @__PURE__ */ import_react4.default.createElement(CSS, null, "@page {size: A4;margin-top:1cm;margin-right:1cm;margin-left:1cm;margin-bottom:1cm;"), /* @__PURE__ */ import_react4.default.createElement("div", null, "Hello world!"))
                }
            }
        }
    }
};
// src/compile/compile.tsx
var compile = function() {
    var _ref = _async_to_generator(function(node, options) {
        var emotion, ReactDOMServer, Element, CacheProvider, _ref, createCache, _ref1, createEmotionServer, cache, _createEmotionServer, extractCriticalToChunks, constructStyleTagsFromChunks, html, chunks, styles, mergedStylesheet, _ref2, postcss2, _ref3, cssvariables, _ref4, logical, result;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    emotion = Object.assign({
                        emotion: false
                    }, options || {}).emotion;
                    return [
                        4,
                        import("react-dom/server")
                    ];
                case 1:
                    ReactDOMServer = _state.sent();
                    Element = /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null, /* @__PURE__ */ import_react5.default.createElement(CSS, null, dist_default), node);
                    if (!emotion) {
                        return [
                            2,
                            ReactDOMServer.renderToString(Element)
                        ];
                    }
                    return [
                        4,
                        import("@emotion/react")
                    ];
                case 2:
                    CacheProvider = _state.sent().CacheProvider;
                    return [
                        4,
                        import("@emotion/cache")
                    ];
                case 3:
                    _ref = _state.sent(), createCache = _ref.default;
                    return [
                        4,
                        import("@emotion/server/create-instance")
                    ];
                case 4:
                    _ref1 = _state.sent(), createEmotionServer = _ref1.default;
                    cache = createCache({
                        key: "css"
                    });
                    _createEmotionServer = createEmotionServer(cache), extractCriticalToChunks = _createEmotionServer.extractCriticalToChunks, constructStyleTagsFromChunks = _createEmotionServer.constructStyleTagsFromChunks;
                    Element = /* @__PURE__ */ import_react5.default.createElement(CacheProvider, {
                        value: cache
                    }, Element);
                    html = ReactDOMServer.renderToString(Element);
                    chunks = extractCriticalToChunks(html);
                    styles = constructStyleTagsFromChunks(chunks);
                    mergedStylesheet = styles.replace(/<\/?style( data-emotion="[a-z0-9- ]+")?>/gm, "");
                    return [
                        4,
                        Promise.resolve().then(function() {
                            return init_postcss(), postcss_exports;
                        })
                    ];
                case 5:
                    _ref2 = _state.sent(), postcss2 = _ref2.default;
                    return [
                        4,
                        Promise.resolve().then(function() {
                            return __toESM(require_postcss_css_variables());
                        })
                    ];
                case 6:
                    _ref3 = _state.sent(), cssvariables = _ref3.default;
                    return [
                        4,
                        Promise.resolve().then(function() {
                            return init_dist(), dist_exports;
                        })
                    ];
                case 7:
                    _ref4 = _state.sent(), logical = _ref4.default;
                    return [
                        4,
                        postcss2([
                            cssvariables(),
                            logical()
                        ]).process(mergedStylesheet, {
                            from: void 0
                        })
                    ];
                case 8:
                    result = _state.sent();
                    return [
                        2,
                        "<style>".concat(result.css, "</style>").concat(html)
                    ];
            }
        });
    });
    return function compile(node, options) {
        return _ref.apply(this, arguments);
    };
}();
// src/markdown/markdown.tsx
init_shim();
var import_markdown_to_jsx = __toESM(require("markdown-to-jsx"));
var import_react6 = __toESM(require("react"));
var Markdown = import_markdown_to_jsx.default;
// src/latex/latex.tsx
init_shim();
var import_react7 = __toESM(require("react"));
var import_katex = __toESM(require("katex"));
var Latex = function(param) {
    var children = param.children;
    var html = import_katex.default.renderToString(children, {
        throwOnError: false
    });
    return /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, /* @__PURE__ */ import_react7.default.createElement("link", {
        rel: "stylesheet",
        href: "https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.css",
        integrity: "sha384-OH8qNTHoMMVNVcKdKewlipV4SErXqccxxlg6HC9Cwjr5oZu2AdBej1TndeCirael",
        crossOrigin: "anonymous"
    }), /* @__PURE__ */ import_react7.default.createElement("span", {
        dangerouslySetInnerHTML: {
            __html: html
        }
    }));
};
var __docConfig3 = {
    name: "LaTeX",
    icon: "square-root-variable",
    description: "Render LaTeX formulas right in your React components.\n\n<Warning>\nLaTeX rendering is still in beta. Please report any issues you encounter on our [Discord](https://discord.com/invite/uRJE6e2rgr).\n</Warning>\n\n<Note>Rendering LaTeX using KaTeX requires pulling a remote stylesshet hosted by jsdelivr. This is done to prevent the styles from being purged.</Note>\n\n<Tip>You can use `String.raw` to avoid escaping LaTeX backslashes.</Tip>",
    components: {
        Latex: {
            server: true,
            client: true,
            examples: {
                default: {
                    template: /* @__PURE__ */ import_react7.default.createElement(Latex, null, String.raw(_templateObject()))
                },
                complex: {
                    template: /* @__PURE__ */ import_react7.default.createElement(Latex, null, String.raw(_templateObject1()))
                }
            }
        }
    }
}; /*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)
*/ 
//# sourceMappingURL=client.js.map