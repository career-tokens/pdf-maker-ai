var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
  get: (a3, b3) => (typeof require !== "undefined" ? require : a3)[b3]
}) : x3)(function(x3) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x3 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require3() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    init_shim();
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i5 = 0, len = code.length; i5 < len; ++i5) {
      lookup[i5] = code[i5];
      revLookup[code.charCodeAt(i5)] = i5;
    }
    var i5;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i6;
      for (i6 = 0; i6 < len2; i6 += 4) {
        tmp = revLookup[b64.charCodeAt(i6)] << 18 | revLookup[b64.charCodeAt(i6 + 1)] << 12 | revLookup[b64.charCodeAt(i6 + 2)] << 6 | revLookup[b64.charCodeAt(i6 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i6)] << 2 | revLookup[b64.charCodeAt(i6 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i6)] << 10 | revLookup[b64.charCodeAt(i6 + 1)] << 4 | revLookup[b64.charCodeAt(i6 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i6 = start; i6 < end; i6 += 3) {
        tmp = (uint8[i6] << 16 & 16711680) + (uint8[i6 + 1] << 8 & 65280) + (uint8[i6 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i6 = 0, len22 = len2 - extraBytes; i6 < len22; i6 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i6, i6 + maxChunkLength > len22 ? len22 : i6 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    "use strict";
    init_shim();
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e4, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i5 = isLE ? nBytes - 1 : 0;
      var d3 = isLE ? -1 : 1;
      var s2 = buffer[offset + i5];
      i5 += d3;
      e4 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e4 = e4 * 256 + buffer[offset + i5], i5 += d3, nBits -= 8) {
      }
      m2 = e4 & (1 << -nBits) - 1;
      e4 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i5], i5 += d3, nBits -= 8) {
      }
      if (e4 === 0) {
        e4 = 1 - eBias;
      } else if (e4 === eMax) {
        return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e4 = e4 - eBias;
      }
      return (s2 ? -1 : 1) * m2 * Math.pow(2, e4 - mLen);
    };
    exports.write = function(buffer, value2, offset, isLE, mLen, nBytes) {
      var e4, m2, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i5 = isLE ? 0 : nBytes - 1;
      var d3 = isLE ? 1 : -1;
      var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
      value2 = Math.abs(value2);
      if (isNaN(value2) || value2 === Infinity) {
        m2 = isNaN(value2) ? 1 : 0;
        e4 = eMax;
      } else {
        e4 = Math.floor(Math.log(value2) / Math.LN2);
        if (value2 * (c2 = Math.pow(2, -e4)) < 1) {
          e4--;
          c2 *= 2;
        }
        if (e4 + eBias >= 1) {
          value2 += rt / c2;
        } else {
          value2 += rt * Math.pow(2, 1 - eBias);
        }
        if (value2 * c2 >= 2) {
          e4++;
          c2 /= 2;
        }
        if (e4 + eBias >= eMax) {
          m2 = 0;
          e4 = eMax;
        } else if (e4 + eBias >= 1) {
          m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
          e4 = e4 + eBias;
        } else {
          m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e4 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i5] = m2 & 255, i5 += d3, m2 /= 256, mLen -= 8) {
      }
      e4 = e4 << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i5] = e4 & 255, i5 += d3, e4 /= 256, eLen -= 8) {
      }
      buffer[offset + i5 - d3] |= s2 * 128;
    };
  }
});

// node_modules/node-stdlib-browser/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/node-stdlib-browser/node_modules/buffer/index.js"(exports) {
    "use strict";
    init_shim();
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e4) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length2);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length2);
    }
    Buffer3.poolSize = 8192;
    function from(value2, encodingOrOffset, length2) {
      if (typeof value2 === "string") {
        return fromString(value2, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value2)) {
        return fromArrayView(value2);
      }
      if (value2 == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
        );
      }
      if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value2, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value2, encodingOrOffset, length2);
      }
      if (typeof value2 === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value2.valueOf && value2.valueOf();
      if (valueOf != null && valueOf !== value2) {
        return Buffer3.from(valueOf, encodingOrOffset, length2);
      }
      var b3 = fromObject(value2);
      if (b3)
        return b3;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
        return Buffer3.from(
          value2[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length2
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    Buffer3.from = function(value2, encodingOrOffset, length2) {
      return from(value2, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length2 = byteLength(string, encoding) | 0;
      var buf = createBuffer(length2);
      var actual = buf.write(string, encoding);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length2);
      for (var i5 = 0; i5 < length2; i5 += 1) {
        buf[i5] = array[i5] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length2);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer3.alloc(+length2);
    }
    Buffer3.isBuffer = function isBuffer(b3) {
      return b3 != null && b3._isBuffer === true && b3 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a3, b3) {
      if (isInstance(a3, Uint8Array))
        a3 = Buffer3.from(a3, a3.offset, a3.byteLength);
      if (isInstance(b3, Uint8Array))
        b3 = Buffer3.from(b3, b3.offset, b3.byteLength);
      if (!Buffer3.isBuffer(a3) || !Buffer3.isBuffer(b3)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a3 === b3)
        return 0;
      var x3 = a3.length;
      var y3 = b3.length;
      for (var i5 = 0, len = Math.min(x3, y3); i5 < len; ++i5) {
        if (a3[i5] !== b3[i5]) {
          x3 = a3[i5];
          y3 = b3[i5];
          break;
        }
      }
      if (x3 < y3)
        return -1;
      if (y3 < x3)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list3, length2) {
      if (!Array.isArray(list3)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list3.length === 0) {
        return Buffer3.alloc(0);
      }
      var i5;
      if (length2 === void 0) {
        length2 = 0;
        for (i5 = 0; i5 < list3.length; ++i5) {
          length2 += list3[i5].length;
        }
      }
      var buffer = Buffer3.allocUnsafe(length2);
      var pos = 0;
      for (i5 = 0; i5 < list3.length; ++i5) {
        var buf = list3[i5];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer3.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b3, n4, m2) {
      var i5 = b3[n4];
      b3[n4] = b3[m2];
      b3[m2] = i5;
    }
    Buffer3.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 2) {
        swap(this, i5, i5 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 4) {
        swap(this, i5, i5 + 3);
        swap(this, i5 + 1, i5 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i5 = 0; i5 < len; i5 += 8) {
        swap(this, i5, i5 + 7);
        swap(this, i5 + 1, i5 + 6);
        swap(this, i5 + 2, i5 + 5);
        swap(this, i5 + 3, i5 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      var length2 = this.length;
      if (length2 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b3) {
      if (!Buffer3.isBuffer(b3))
        throw new TypeError("Argument must be a Buffer");
      if (this === b3)
        return true;
      return Buffer3.compare(this, b3) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      var str = "";
      var max3 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max3).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max3)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x3 = thisEnd - thisStart;
      var y3 = end - start;
      var len = Math.min(x3, y3);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i5 = 0; i5 < len; ++i5) {
        if (thisCopy[i5] !== targetCopy[i5]) {
          x3 = thisCopy[i5];
          y3 = targetCopy[i5];
          break;
        }
      }
      if (x3 < y3)
        return -1;
      if (y3 < x3)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i6) {
        if (indexSize === 1) {
          return buf[i6];
        } else {
          return buf.readUInt16BE(i6 * indexSize);
        }
      }
      var i5;
      if (dir) {
        var foundIndex = -1;
        for (i5 = byteOffset; i5 < arrLength; i5++) {
          if (read(arr, i5) === read(val, foundIndex === -1 ? 0 : i5 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i5;
            if (i5 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i5 -= i5 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i5 = byteOffset; i5 >= 0; i5--) {
          var found = true;
          for (var j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i5 + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found)
            return i5;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length2) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      var strLen = string.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      for (var i5 = 0; i5 < length2; ++i5) {
        var parsed = parseInt(string.substr(i5 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i5;
        buf[offset + i5] = parsed;
      }
      return i5;
    }
    function utf8Write(buf, string, offset, length2) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length2);
    }
    function asciiWrite(buf, string, offset, length2) {
      return blitBuffer(asciiToBytes(string), buf, offset, length2);
    }
    function base64Write(buf, string, offset, length2) {
      return blitBuffer(base64ToBytes(string), buf, offset, length2);
    }
    function ucs2Write(buf, string, offset, length2) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length2);
    }
    Buffer3.prototype.write = function write(string, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining)
        length2 = remaining;
      if (string.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length2);
          case "base64":
            return base64Write(this, string, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length2);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i5 = start;
      while (i5 < end) {
        var firstByte = buf[i5];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i5 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i5 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              fourthByte = buf[i5 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i5 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i5 = 0;
      while (i5 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i5, i5 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i5 = start; i5 < end; ++i5) {
        out += hexSliceLookupTable[buf[i5]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i5 = 0; i5 < bytes.length - 1; i5 += 2) {
        res += String.fromCharCode(bytes[i5] + bytes[i5 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i5 = 0;
      while (++i5 < byteLength2 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i5 = 0;
      while (++i5 < byteLength2 && (mul *= 256)) {
        val += this[offset + i5] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i5 = byteLength2;
      var mul = 1;
      var val = this[offset + --i5];
      while (i5 > 0 && (mul *= 256)) {
        val += this[offset + --i5] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value2, offset, ext, max3, min2) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value2 > max3 || value2 < min2)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i5 = 0;
      this[offset] = value2 & 255;
      while (++i5 < byteLength2 && (mul *= 256)) {
        this[offset + i5] = value2 / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      var i5 = byteLength2 - 1;
      var mul = 1;
      this[offset + i5] = value2 & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        this[offset + i5] = value2 / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 255, 0);
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset + 3] = value2 >>> 24;
      this[offset + 2] = value2 >>> 16;
      this[offset + 1] = value2 >>> 8;
      this[offset] = value2 & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      var i5 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value2 & 255;
      while (++i5 < byteLength2 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i5 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i5] = (value2 / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength2, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      var i5 = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i5] = value2 & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i5 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i5] = (value2 / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 127, -128);
      if (value2 < 0)
        value2 = 255 + value2 + 1;
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      this[offset + 2] = value2 >>> 16;
      this[offset + 3] = value2 >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      if (value2 < 0)
        value2 = 4294967295 + value2 + 1;
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value2, offset, ext, max3, min2) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value2, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, false, noAssert);
    };
    function writeDouble(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value2, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length2 = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i5 = 0; i5 < length2; ++i5) {
        codePoint = string.charCodeAt(i5);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i5 + 1 === length2) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i5 = 0; i5 < str.length; ++i5) {
        byteArray.push(str.charCodeAt(i5) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c2, hi, lo;
      var byteArray = [];
      for (var i5 = 0; i5 < str.length; ++i5) {
        if ((units -= 2) < 0)
          break;
        c2 = str.charCodeAt(i5);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length2) {
      for (var i5 = 0; i5 < length2; ++i5) {
        if (i5 + offset >= dst.length || i5 >= src.length)
          break;
        dst[i5 + offset] = src[i5];
      }
      return i5;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i5 = 0; i5 < 16; ++i5) {
        var i16 = i5 * 16;
        for (var j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i5] + alphabet[j2];
        }
      }
      return table;
    }();
  }
});

// node_modules/process/browser.js
var require_browser = __commonJS({
  "node_modules/process/browser.js"(exports, module) {
    "use strict";
    init_shim();
    var process2 = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e4) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e4) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e4) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e5) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e4) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e5) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process2.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i5 = 1; i5 < arguments.length; i5++) {
          args[i5 - 1] = arguments[i5];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process2.title = "browser";
    process2.browser = true;
    process2.env = {};
    process2.argv = [];
    process2.version = "";
    process2.versions = {};
    function noop2() {
    }
    process2.on = noop2;
    process2.addListener = noop2;
    process2.once = noop2;
    process2.off = noop2;
    process2.removeListener = noop2;
    process2.removeAllListeners = noop2;
    process2.emit = noop2;
    process2.prependListener = noop2;
    process2.prependOnceListener = noop2;
    process2.listeners = function(name) {
      return [];
    };
    process2.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process2.cwd = function() {
      return "/";
    };
    process2.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process2.umask = function() {
      return 0;
    };
  }
});

// node_modules/node-stdlib-browser/helpers/esbuild/shim.js
var import_buffer, import_process, _globalThis, _global;
var init_shim = __esm({
  "node_modules/node-stdlib-browser/helpers/esbuild/shim.js"() {
    "use strict";
    import_buffer = __toESM(require_buffer());
    import_process = __toESM(require_browser());
    _globalThis = function(Object2) {
      function get() {
        var _global3 = this || self;
        delete Object2.prototype.__magic__;
        return _global3;
      }
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (this) {
        return get();
      } else {
        Object2.defineProperty(Object2.prototype, "__magic__", {
          configurable: true,
          get
        });
        var _global2 = __magic__;
        return _global2;
      }
    }(Object);
    _global = _globalThis;
  }
});

// node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "node_modules/picocolors/picocolors.browser.js"(exports, module) {
    "use strict";
    init_shim();
    var x3 = String;
    var create = function() {
      return { isColorSupported: false, reset: x3, bold: x3, dim: x3, italic: x3, underline: x3, inverse: x3, hidden: x3, strikethrough: x3, black: x3, red: x3, green: x3, yellow: x3, blue: x3, magenta: x3, cyan: x3, white: x3, gray: x3, bgBlack: x3, bgRed: x3, bgGreen: x3, bgYellow: x3, bgBlue: x3, bgMagenta: x3, bgCyan: x3, bgWhite: x3 };
    };
    module.exports = create();
    module.exports.createColors = create;
  }
});

// (disabled):node_modules/postcss/lib/terminal-highlight
var require_terminal_highlight = __commonJS({
  "(disabled):node_modules/postcss/lib/terminal-highlight"() {
    "use strict";
    init_shim();
  }
});

// node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS({
  "node_modules/postcss/lib/css-syntax-error.js"(exports, module) {
    "use strict";
    init_shim();
    var pico = require_picocolors_browser();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError2 = class _CssSyntaxError extends Error {
      constructor(message, line, column, source, file, plugin2) {
        super(message);
        this.name = "CssSyntaxError";
        this.reason = message;
        if (file) {
          this.file = file;
        }
        if (source) {
          this.source = source;
        }
        if (plugin2) {
          this.plugin = plugin2;
        }
        if (typeof line !== "undefined" && typeof column !== "undefined") {
          if (typeof line === "number") {
            this.line = line;
            this.column = column;
          } else {
            this.line = line.line;
            this.column = line.column;
            this.endLine = column.line;
            this.endColumn = column.column;
          }
        }
        this.setMessage();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _CssSyntaxError);
        }
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "";
        this.message += this.file ? this.file : "<css input>";
        if (typeof this.line !== "undefined") {
          this.message += ":" + this.line + ":" + this.column;
        }
        this.message += ": " + this.reason;
      }
      showSourceCode(color3) {
        if (!this.source)
          return "";
        let css = this.source;
        if (color3 == null)
          color3 = pico.isColorSupported;
        if (terminalHighlight) {
          if (color3)
            css = terminalHighlight(css);
        }
        let lines = css.split(/\r?\n/);
        let start = Math.max(this.line - 3, 0);
        let end = Math.min(this.line + 2, lines.length);
        let maxWidth = String(end).length;
        let mark, aside;
        if (color3) {
          let { bold, gray, red } = pico.createColors(true);
          mark = (text) => bold(red(text));
          aside = (text) => gray(text);
        } else {
          mark = aside = (str) => str;
        }
        return lines.slice(start, end).map((line, index2) => {
          let number2 = start + 1 + index2;
          let gutter = " " + (" " + number2).slice(-maxWidth) + " | ";
          if (number2 === this.line) {
            let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
          }
          return " " + aside(gutter) + line;
        }).join("\n");
      }
      toString() {
        let code = this.showSourceCode();
        if (code) {
          code = "\n\n" + code + "\n";
        }
        return this.name + ": " + this.message + code;
      }
    };
    module.exports = CssSyntaxError2;
    CssSyntaxError2.default = CssSyntaxError2;
  }
});

// node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/postcss/lib/symbols.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports.isClean = Symbol("isClean");
    module.exports.my = Symbol("my");
  }
});

// node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS({
  "node_modules/postcss/lib/stringifier.js"(exports, module) {
    "use strict";
    init_shim();
    var DEFAULT_RAW = {
      after: "\n",
      beforeClose: "\n",
      beforeComment: "\n",
      beforeDecl: "\n",
      beforeOpen: " ",
      beforeRule: "\n",
      colon: ": ",
      commentLeft: " ",
      commentRight: " ",
      emptyBody: "",
      indent: "    ",
      semicolon: false
    };
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }
    var Stringifier = class {
      constructor(builder) {
        this.builder = builder;
      }
      atrule(node, semicolon) {
        let name = "@" + node.name;
        let params = node.params ? this.rawValue(node, "params") : "";
        if (typeof node.raws.afterName !== "undefined") {
          name += node.raws.afterName;
        } else if (params) {
          name += " ";
        }
        if (node.nodes) {
          this.block(node, name + params);
        } else {
          let end = (node.raws.between || "") + (semicolon ? ";" : "");
          this.builder(name + params + end, node);
        }
      }
      beforeAfter(node, detect) {
        let value2;
        if (node.type === "decl") {
          value2 = this.raw(node, null, "beforeDecl");
        } else if (node.type === "comment") {
          value2 = this.raw(node, null, "beforeComment");
        } else if (detect === "before") {
          value2 = this.raw(node, null, "beforeRule");
        } else {
          value2 = this.raw(node, null, "beforeClose");
        }
        let buf = node.parent;
        let depth = 0;
        while (buf && buf.type !== "root") {
          depth += 1;
          buf = buf.parent;
        }
        if (value2.includes("\n")) {
          let indent = this.raw(node, null, "indent");
          if (indent.length) {
            for (let step = 0; step < depth; step++)
              value2 += indent;
          }
        }
        return value2;
      }
      block(node, start) {
        let between = this.raw(node, "between", "beforeOpen");
        this.builder(start + between + "{", node, "start");
        let after;
        if (node.nodes && node.nodes.length) {
          this.body(node);
          after = this.raw(node, "after");
        } else {
          after = this.raw(node, "after", "emptyBody");
        }
        if (after)
          this.builder(after);
        this.builder("}", node, "end");
      }
      body(node) {
        let last = node.nodes.length - 1;
        while (last > 0) {
          if (node.nodes[last].type !== "comment")
            break;
          last -= 1;
        }
        let semicolon = this.raw(node, "semicolon");
        for (let i5 = 0; i5 < node.nodes.length; i5++) {
          let child = node.nodes[i5];
          let before = this.raw(child, "before");
          if (before)
            this.builder(before);
          this.stringify(child, last !== i5 || semicolon);
        }
      }
      comment(node) {
        let left = this.raw(node, "left", "commentLeft");
        let right = this.raw(node, "right", "commentRight");
        this.builder("/*" + left + node.text + right + "*/", node);
      }
      decl(node, semicolon) {
        let between = this.raw(node, "between", "colon");
        let string = node.prop + between + this.rawValue(node, "value");
        if (node.important) {
          string += node.raws.important || " !important";
        }
        if (semicolon)
          string += ";";
        this.builder(string, node);
      }
      document(node) {
        this.body(node);
      }
      raw(node, own, detect) {
        let value2;
        if (!detect)
          detect = own;
        if (own) {
          value2 = node.raws[own];
          if (typeof value2 !== "undefined")
            return value2;
        }
        let parent = node.parent;
        if (detect === "before") {
          if (!parent || parent.type === "root" && parent.first === node) {
            return "";
          }
          if (parent && parent.type === "document") {
            return "";
          }
        }
        if (!parent)
          return DEFAULT_RAW[detect];
        let root2 = node.root();
        if (!root2.rawCache)
          root2.rawCache = {};
        if (typeof root2.rawCache[detect] !== "undefined") {
          return root2.rawCache[detect];
        }
        if (detect === "before" || detect === "after") {
          return this.beforeAfter(node, detect);
        } else {
          let method = "raw" + capitalize(detect);
          if (this[method]) {
            value2 = this[method](root2, node);
          } else {
            root2.walk((i5) => {
              value2 = i5.raws[own];
              if (typeof value2 !== "undefined")
                return false;
            });
          }
        }
        if (typeof value2 === "undefined")
          value2 = DEFAULT_RAW[detect];
        root2.rawCache[detect] = value2;
        return value2;
      }
      rawBeforeClose(root2) {
        let value2;
        root2.walk((i5) => {
          if (i5.nodes && i5.nodes.length > 0) {
            if (typeof i5.raws.after !== "undefined") {
              value2 = i5.raws.after;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value2)
          value2 = value2.replace(/\S/g, "");
        return value2;
      }
      rawBeforeComment(root2, node) {
        let value2;
        root2.walkComments((i5) => {
          if (typeof i5.raws.before !== "undefined") {
            value2 = i5.raws.before;
            if (value2.includes("\n")) {
              value2 = value2.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value2 === "undefined") {
          value2 = this.raw(node, null, "beforeDecl");
        } else if (value2) {
          value2 = value2.replace(/\S/g, "");
        }
        return value2;
      }
      rawBeforeDecl(root2, node) {
        let value2;
        root2.walkDecls((i5) => {
          if (typeof i5.raws.before !== "undefined") {
            value2 = i5.raws.before;
            if (value2.includes("\n")) {
              value2 = value2.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value2 === "undefined") {
          value2 = this.raw(node, null, "beforeRule");
        } else if (value2) {
          value2 = value2.replace(/\S/g, "");
        }
        return value2;
      }
      rawBeforeOpen(root2) {
        let value2;
        root2.walk((i5) => {
          if (i5.type !== "decl") {
            value2 = i5.raws.between;
            if (typeof value2 !== "undefined")
              return false;
          }
        });
        return value2;
      }
      rawBeforeRule(root2) {
        let value2;
        root2.walk((i5) => {
          if (i5.nodes && (i5.parent !== root2 || root2.first !== i5)) {
            if (typeof i5.raws.before !== "undefined") {
              value2 = i5.raws.before;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value2)
          value2 = value2.replace(/\S/g, "");
        return value2;
      }
      rawColon(root2) {
        let value2;
        root2.walkDecls((i5) => {
          if (typeof i5.raws.between !== "undefined") {
            value2 = i5.raws.between.replace(/[^\s:]/g, "");
            return false;
          }
        });
        return value2;
      }
      rawEmptyBody(root2) {
        let value2;
        root2.walk((i5) => {
          if (i5.nodes && i5.nodes.length === 0) {
            value2 = i5.raws.after;
            if (typeof value2 !== "undefined")
              return false;
          }
        });
        return value2;
      }
      rawIndent(root2) {
        if (root2.raws.indent)
          return root2.raws.indent;
        let value2;
        root2.walk((i5) => {
          let p3 = i5.parent;
          if (p3 && p3 !== root2 && p3.parent && p3.parent === root2) {
            if (typeof i5.raws.before !== "undefined") {
              let parts = i5.raws.before.split("\n");
              value2 = parts[parts.length - 1];
              value2 = value2.replace(/\S/g, "");
              return false;
            }
          }
        });
        return value2;
      }
      rawSemicolon(root2) {
        let value2;
        root2.walk((i5) => {
          if (i5.nodes && i5.nodes.length && i5.last.type === "decl") {
            value2 = i5.raws.semicolon;
            if (typeof value2 !== "undefined")
              return false;
          }
        });
        return value2;
      }
      rawValue(node, prop) {
        let value2 = node[prop];
        let raw = node.raws[prop];
        if (raw && raw.value === value2) {
          return raw.raw;
        }
        return value2;
      }
      root(node) {
        this.body(node);
        if (node.raws.after)
          this.builder(node.raws.after);
      }
      rule(node) {
        this.block(node, this.rawValue(node, "selector"));
        if (node.raws.ownSemicolon) {
          this.builder(node.raws.ownSemicolon, node, "end");
        }
      }
      stringify(node, semicolon) {
        if (!this[node.type]) {
          throw new Error(
            "Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier."
          );
        }
        this[node.type](node, semicolon);
      }
    };
    module.exports = Stringifier;
    Stringifier.default = Stringifier;
  }
});

// node_modules/postcss/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/postcss/lib/stringify.js"(exports, module) {
    "use strict";
    init_shim();
    var Stringifier = require_stringifier();
    function stringify6(node, builder) {
      let str = new Stringifier(builder);
      str.stringify(node);
    }
    module.exports = stringify6;
    stringify6.default = stringify6;
  }
});

// node_modules/postcss/lib/node.js
var require_node = __commonJS({
  "node_modules/postcss/lib/node.js"(exports, module) {
    "use strict";
    init_shim();
    var { isClean, my } = require_symbols();
    var CssSyntaxError2 = require_css_syntax_error();
    var Stringifier = require_stringifier();
    var stringify6 = require_stringify();
    function cloneNode(obj, parent) {
      let cloned = new obj.constructor();
      for (let i5 in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, i5)) {
          continue;
        }
        if (i5 === "proxyCache")
          continue;
        let value2 = obj[i5];
        let type = typeof value2;
        if (i5 === "parent" && type === "object") {
          if (parent)
            cloned[i5] = parent;
        } else if (i5 === "source") {
          cloned[i5] = value2;
        } else if (Array.isArray(value2)) {
          cloned[i5] = value2.map((j2) => cloneNode(j2, cloned));
        } else {
          if (type === "object" && value2 !== null)
            value2 = cloneNode(value2);
          cloned[i5] = value2;
        }
      }
      return cloned;
    }
    var Node2 = class {
      constructor(defaults3 = {}) {
        this.raws = {};
        this[isClean] = false;
        this[my] = true;
        for (let name in defaults3) {
          if (name === "nodes") {
            this.nodes = [];
            for (let node of defaults3[name]) {
              if (typeof node.clone === "function") {
                this.append(node.clone());
              } else {
                this.append(node);
              }
            }
          } else {
            this[name] = defaults3[name];
          }
        }
      }
      addToError(error) {
        error.postcssNode = this;
        if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
          let s2 = this.source;
          error.stack = error.stack.replace(
            /\n\s{4}at /,
            `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
          );
        }
        return error;
      }
      after(add) {
        this.parent.insertAfter(this, add);
        return this;
      }
      assign(overrides = {}) {
        for (let name in overrides) {
          this[name] = overrides[name];
        }
        return this;
      }
      before(add) {
        this.parent.insertBefore(this, add);
        return this;
      }
      cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween)
          delete this.raws.between;
      }
      clone(overrides = {}) {
        let cloned = cloneNode(this);
        for (let name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      }
      cloneAfter(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      }
      cloneBefore(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      }
      error(message, opts = {}) {
        if (this.source) {
          let { end, start } = this.rangeBy(opts);
          return this.source.input.error(
            message,
            { column: start.column, line: start.line },
            { column: end.column, line: end.line },
            opts
          );
        }
        return new CssSyntaxError2(message);
      }
      getProxyProcessor() {
        return {
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else {
              return node[prop];
            }
          },
          set(node, prop, value2) {
            if (node[prop] === value2)
              return true;
            node[prop] = value2;
            if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
            prop === "text") {
              node.markDirty();
            }
            return true;
          }
        };
      }
      markDirty() {
        if (this[isClean]) {
          this[isClean] = false;
          let next = this;
          while (next = next.parent) {
            next[isClean] = false;
          }
        }
      }
      next() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 + 1];
      }
      positionBy(opts, stringRepresentation) {
        let pos = this.source.start;
        if (opts.index) {
          pos = this.positionInside(opts.index, stringRepresentation);
        } else if (opts.word) {
          stringRepresentation = this.toString();
          let index2 = stringRepresentation.indexOf(opts.word);
          if (index2 !== -1)
            pos = this.positionInside(index2, stringRepresentation);
        }
        return pos;
      }
      positionInside(index2, stringRepresentation) {
        let string = stringRepresentation || this.toString();
        let column = this.source.start.column;
        let line = this.source.start.line;
        for (let i5 = 0; i5 < index2; i5++) {
          if (string[i5] === "\n") {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }
        return { column, line };
      }
      prev() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 - 1];
      }
      rangeBy(opts) {
        let start = {
          column: this.source.start.column,
          line: this.source.start.line
        };
        let end = this.source.end ? {
          column: this.source.end.column + 1,
          line: this.source.end.line
        } : {
          column: start.column + 1,
          line: start.line
        };
        if (opts.word) {
          let stringRepresentation = this.toString();
          let index2 = stringRepresentation.indexOf(opts.word);
          if (index2 !== -1) {
            start = this.positionInside(index2, stringRepresentation);
            end = this.positionInside(index2 + opts.word.length, stringRepresentation);
          }
        } else {
          if (opts.start) {
            start = {
              column: opts.start.column,
              line: opts.start.line
            };
          } else if (opts.index) {
            start = this.positionInside(opts.index);
          }
          if (opts.end) {
            end = {
              column: opts.end.column,
              line: opts.end.line
            };
          } else if (opts.endIndex) {
            end = this.positionInside(opts.endIndex);
          } else if (opts.index) {
            end = this.positionInside(opts.index + 1);
          }
        }
        if (end.line < start.line || end.line === start.line && end.column <= start.column) {
          end = { column: start.column + 1, line: start.line };
        }
        return { end, start };
      }
      raw(prop, defaultType) {
        let str = new Stringifier();
        return str.raw(this, prop, defaultType);
      }
      remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      }
      replaceWith(...nodes) {
        if (this.parent) {
          let bookmark = this;
          let foundSelf = false;
          for (let node of nodes) {
            if (node === this) {
              foundSelf = true;
            } else if (foundSelf) {
              this.parent.insertAfter(bookmark, node);
              bookmark = node;
            } else {
              this.parent.insertBefore(bookmark, node);
            }
          }
          if (!foundSelf) {
            this.remove();
          }
        }
        return this;
      }
      root() {
        let result = this;
        while (result.parent && result.parent.type !== "document") {
          result = result.parent;
        }
        return result;
      }
      toJSON(_3, inputs) {
        let fixed = {};
        let emitInputs = inputs == null;
        inputs = inputs || /* @__PURE__ */ new Map();
        let inputsNextIndex = 0;
        for (let name in this) {
          if (!Object.prototype.hasOwnProperty.call(this, name)) {
            continue;
          }
          if (name === "parent" || name === "proxyCache")
            continue;
          let value2 = this[name];
          if (Array.isArray(value2)) {
            fixed[name] = value2.map((i5) => {
              if (typeof i5 === "object" && i5.toJSON) {
                return i5.toJSON(null, inputs);
              } else {
                return i5;
              }
            });
          } else if (typeof value2 === "object" && value2.toJSON) {
            fixed[name] = value2.toJSON(null, inputs);
          } else if (name === "source") {
            let inputId = inputs.get(value2.input);
            if (inputId == null) {
              inputId = inputsNextIndex;
              inputs.set(value2.input, inputsNextIndex);
              inputsNextIndex++;
            }
            fixed[name] = {
              end: value2.end,
              inputId,
              start: value2.start
            };
          } else {
            fixed[name] = value2;
          }
        }
        if (emitInputs) {
          fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
        }
        return fixed;
      }
      toProxy() {
        if (!this.proxyCache) {
          this.proxyCache = new Proxy(this, this.getProxyProcessor());
        }
        return this.proxyCache;
      }
      toString(stringifier = stringify6) {
        if (stringifier.stringify)
          stringifier = stringifier.stringify;
        let result = "";
        stringifier(this, (i5) => {
          result += i5;
        });
        return result;
      }
      warn(result, text, opts) {
        let data = { node: this };
        for (let i5 in opts)
          data[i5] = opts[i5];
        return result.warn(text, data);
      }
      get proxyOf() {
        return this;
      }
    };
    module.exports = Node2;
    Node2.default = Node2;
  }
});

// node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS({
  "node_modules/postcss/lib/declaration.js"(exports, module) {
    "use strict";
    init_shim();
    var Node2 = require_node();
    var Declaration2 = class extends Node2 {
      constructor(defaults3) {
        if (defaults3 && typeof defaults3.value !== "undefined" && typeof defaults3.value !== "string") {
          defaults3 = { ...defaults3, value: String(defaults3.value) };
        }
        super(defaults3);
        this.type = "decl";
      }
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
    };
    module.exports = Declaration2;
    Declaration2.default = Declaration2;
  }
});

// (disabled):node_modules/source-map-js/source-map.js
var require_source_map = __commonJS({
  "(disabled):node_modules/source-map-js/source-map.js"() {
    "use strict";
    init_shim();
  }
});

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    init_shim();
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i5 = 0; i5 <= path.length; ++i5) {
        if (i5 < path.length)
          code = path.charCodeAt(i5);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i5 - 1 || dots === 1) {
          } else if (lastSlash !== i5 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i5;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i5;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i5);
            else
              res = path.slice(lastSlash + 1, i5);
            lastSegmentLength = i5 - lastSlash - 1;
          }
          lastSlash = i5;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve2() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i5 = arguments.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
          var path;
          if (i5 >= 0)
            path = arguments[i5];
          else {
            if (cwd === void 0)
              cwd = import_process.default.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize3(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute)
          path = ".";
        if (path.length > 0 && trailingSeparator)
          path += "/";
        if (isAbsolute)
          return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join2() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i5 = 0; i5 < arguments.length; ++i5) {
          var arg = arguments[i5];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length2 = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i5 = 0;
        for (; i5 <= length2; ++i5) {
          if (i5 === length2) {
            if (toLen > length2) {
              if (to.charCodeAt(toStart + i5) === 47) {
                return to.slice(toStart + i5 + 1);
              } else if (i5 === 0) {
                return to.slice(toStart + i5);
              }
            } else if (fromLen > length2) {
              if (from.charCodeAt(fromStart + i5) === 47) {
                lastCommonSep = i5;
              } else if (i5 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i5);
          var toCode = to.charCodeAt(toStart + i5);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i5;
        }
        var out = "";
        for (i5 = fromStart + lastCommonSep + 1; i5 <= fromEnd; ++i5) {
          if (i5 === fromEnd || from.charCodeAt(i5) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i5 = path.length - 1; i5 >= 1; --i5) {
          code = path.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              end = i5;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i5;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i5 = path.length - 1; i5 >= 0; --i5) {
            var code = path.charCodeAt(i5);
            if (code === 47) {
              if (!matchedSlash) {
                start = i5 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i5 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i5;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path.length;
          return path.slice(start, end);
        } else {
          for (i5 = path.length - 1; i5 >= 0; --i5) {
            if (path.charCodeAt(i5) === 47) {
              if (!matchedSlash) {
                start = i5 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i5 + 1;
            }
          }
          if (end === -1)
            return "";
          return path.slice(start, end);
        }
      },
      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i5 = path.length - 1; i5 >= 0; --i5) {
          var code = path.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i5 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i5;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format2(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse6(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
          return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i5 = path.length - 1;
        var preDotState = 0;
        for (; i5 >= start; --i5) {
          code = path.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i5 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i5;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path.slice(1, end);
            else
              ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module.exports = posix;
  }
});

// node_modules/node-stdlib-browser/node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "node_modules/node-stdlib-browser/node_modules/punycode/punycode.js"(exports, module) {
    "use strict";
    init_shim();
    (function(root2) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof _global == "object" && _global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root2 = freeGlobal;
      }
      var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length2 = array.length;
        var result = [];
        while (length2--) {
          result[length2] = fn(array[length2]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length2 = string.length, value2, extra;
        while (counter < length2) {
          value2 = string.charCodeAt(counter++);
          if (value2 >= 55296 && value2 <= 56319 && counter < length2) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value2);
              counter--;
            }
          } else {
            output.push(value2);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value2) {
          var output = "";
          if (value2 > 65535) {
            value2 -= 65536;
            output += stringFromCharCode(value2 >>> 10 & 1023 | 55296);
            value2 = 56320 | value2 & 1023;
          }
          output += stringFromCharCode(value2);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k3 = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k3 += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k3 + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode3(input) {
        var output = [], inputLength = input.length, out, i5 = 0, n4 = initialN, bias = initialBias, basic, j2, index2, oldi, w3, k3, digit, t5, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j2 = 0; j2 < basic; ++j2) {
          if (input.charCodeAt(j2) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j2));
        }
        for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          for (oldi = i5, w3 = 1, k3 = base; ; k3 += base) {
            if (index2 >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base || digit > floor((maxInt - i5) / w3)) {
              error("overflow");
            }
            i5 += digit * w3;
            t5 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
            if (digit < t5) {
              break;
            }
            baseMinusT = base - t5;
            if (w3 > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w3 *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i5 - oldi, out, oldi == 0);
          if (floor(i5 / out) > maxInt - n4) {
            error("overflow");
          }
          n4 += floor(i5 / out);
          i5 %= out;
          output.splice(i5++, 0, n4);
        }
        return ucs2encode(output);
      }
      function encode4(input) {
        var n4, delta, handledCPCount, basicLength, bias, j2, m2, q2, k3, t5, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n4 = initialN;
        delta = 0;
        bias = initialBias;
        for (j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
            currentValue = input[j2];
            if (currentValue >= n4 && currentValue < m2) {
              m2 = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m2 - n4 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m2 - n4) * handledCPCountPlusOne;
          n4 = m2;
          for (j2 = 0; j2 < inputLength; ++j2) {
            currentValue = input[j2];
            if (currentValue < n4 && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n4) {
              for (q2 = delta, k3 = base; ; k3 += base) {
                t5 = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
                if (q2 < t5) {
                  break;
                }
                qMinusT = q2 - t5;
                baseMinusT = base - t5;
                output.push(
                  stringFromCharCode(digitToBasic(t5 + qMinusT % baseMinusT, 0))
                );
                q2 = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q2, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n4;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode3(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode4(string) : string;
        });
      }
      punycode2 = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode3,
        "encode": encode4,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode2;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode2;
        } else {
          for (key in punycode2) {
            punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
          }
        }
      } else {
        root2.punycode = punycode2;
      }
    })(exports);
  }
});

// node_modules/querystring-es3/decode.js
var require_decode = __commonJS({
  "node_modules/querystring-es3/decode.js"(exports, module) {
    "use strict";
    init_shim();
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    module.exports = function(qs, sep, eq, options) {
      sep = sep || "&";
      eq = eq || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i5 = 0; i5 < len; ++i5) {
        var x3 = qs[i5].replace(regexp, "%20"), idx = x3.indexOf(eq), kstr, vstr, k3, v2;
        if (idx >= 0) {
          kstr = x3.substr(0, idx);
          vstr = x3.substr(idx + 1);
        } else {
          kstr = x3;
          vstr = "";
        }
        k3 = decodeURIComponent(kstr);
        v2 = decodeURIComponent(vstr);
        if (!hasOwnProperty(obj, k3)) {
          obj[k3] = v2;
        } else if (isArray(obj[k3])) {
          obj[k3].push(v2);
        } else {
          obj[k3] = [obj[k3], v2];
        }
      }
      return obj;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/querystring-es3/encode.js
var require_encode = __commonJS({
  "node_modules/querystring-es3/encode.js"(exports, module) {
    "use strict";
    init_shim();
    var stringifyPrimitive = function(v2) {
      switch (typeof v2) {
        case "string":
          return v2;
        case "boolean":
          return v2 ? "true" : "false";
        case "number":
          return isFinite(v2) ? v2 : "";
        default:
          return "";
      }
    };
    module.exports = function(obj, sep, eq, name) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return map(objectKeys(obj), function(k3) {
          var ks = encodeURIComponent(stringifyPrimitive(k3)) + eq;
          if (isArray(obj[k3])) {
            return map(obj[k3], function(v2) {
              return ks + encodeURIComponent(stringifyPrimitive(v2));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k3]));
          }
        }).join(sep);
      }
      if (!name)
        return "";
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
    function map(xs, f2) {
      if (xs.map)
        return xs.map(f2);
      var res = [];
      for (var i5 = 0; i5 < xs.length; i5++) {
        res.push(f2(xs[i5], i5));
      }
      return res;
    }
    var objectKeys = Object.keys || function(obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          res.push(key);
      }
      return res;
    };
  }
});

// node_modules/querystring-es3/index.js
var require_querystring_es3 = __commonJS({
  "node_modules/querystring-es3/index.js"(exports) {
    "use strict";
    init_shim();
    exports.decode = exports.parse = require_decode();
    exports.encode = exports.stringify = require_encode();
  }
});

// node_modules/node-stdlib-browser/esm/proxy/querystring.js
function qsEscape(string) {
  return encodeURIComponent(string);
}
function qsUnescape(string) {
  return decodeURIComponent(string);
}
var import_querystring_es3, import_querystring_es32, api;
var init_querystring = __esm({
  "node_modules/node-stdlib-browser/esm/proxy/querystring.js"() {
    "use strict";
    init_shim();
    import_querystring_es3 = __toESM(require_querystring_es3());
    import_querystring_es32 = __toESM(require_querystring_es3());
    api = {
      decode: import_querystring_es3.decode,
      encode: import_querystring_es3.encode,
      parse: import_querystring_es3.parse,
      stringify: import_querystring_es3.stringify,
      escape: qsEscape,
      unescape: qsUnescape
    };
  }
});

// node_modules/node-stdlib-browser/esm/proxy/url.js
var url_exports = {};
__export(url_exports, {
  URL: () => URL2,
  URLSearchParams: () => URLSearchParams,
  Url: () => UrlImport,
  default: () => api2,
  domainToASCII: () => domainToASCII,
  domainToUnicode: () => domainToUnicode,
  fileURLToPath: () => fileURLToPath,
  format: () => formatImportWithOverloads,
  parse: () => parseImport,
  pathToFileURL: () => pathToFileURL,
  resolve: () => resolveImport,
  resolveObject: () => resolveObject
});
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && util.isObject(url2) && url2 instanceof Url)
    return url2;
  var u3 = new Url();
  u3.parse(url2, parseQueryString, slashesDenoteHost);
  return u3;
}
function urlFormat(obj) {
  if (util.isString(obj))
    obj = urlParse(obj);
  if (!(obj instanceof Url))
    return Url.prototype.format.call(obj);
  return obj.format();
}
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
function urlResolveObject(source, relative) {
  if (!source)
    return relative;
  return urlParse(source, false, true).resolveObject(relative);
}
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i5 = parts.length - 1; i5 >= 0; i5--) {
    var last = parts[i5];
    if (last === ".") {
      parts.splice(i5, 1);
    } else if (last === "..") {
      parts.splice(i5, 1);
      up++;
    } else if (up) {
      parts.splice(i5, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i5 = arguments.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
    var path = i5 >= 0 ? arguments[i5] : "/";
    if (typeof path !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p3) {
    return !!p3;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function filter(xs, f2) {
  if (xs.filter)
    return xs.filter(f2);
  var res = [];
  for (var i5 = 0; i5 < xs.length; i5++) {
    if (f2(xs[i5], i5, xs))
      res.push(xs[i5]);
  }
  return res;
}
function isURLInstance(instance) {
  var resolved = (
    /** @type {URL|null} */
    instance != null ? instance : null
  );
  return Boolean(resolved !== null && (resolved == null ? void 0 : resolved.href) && (resolved == null ? void 0 : resolved.origin));
}
function getPathFromURLPosix(url2) {
  if (url2.hostname !== "") {
    throw new TypeError('File URL host must be "localhost" or empty on browser');
  }
  var pathname = url2.pathname;
  for (var n4 = 0; n4 < pathname.length; n4++) {
    if (pathname[n4] === "%") {
      var third = pathname.codePointAt(n4 + 2) | 32;
      if (pathname[n4 + 1] === "2" && third === 102) {
        throw new TypeError("File URL path must not include encoded / characters");
      }
    }
  }
  return decodeURIComponent(pathname);
}
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes("\n")) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("	")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
var import_punycode, util$1, punycode, util, parse3, resolve$1, resolveObject, format, Url_1, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol, querystring, _globalThis2, formatImport, parseImport, resolveImport, UrlImport, URL2, URLSearchParams, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx, CHAR_FORWARD_SLASH, domainToASCII, domainToUnicode, pathToFileURL, fileURLToPath, formatImportWithOverloads, api2;
var init_url = __esm({
  "node_modules/node-stdlib-browser/esm/proxy/url.js"() {
    "use strict";
    init_shim();
    import_punycode = __toESM(require_punycode());
    init_querystring();
    util$1 = {
      isString: function(arg) {
        return typeof arg === "string";
      },
      isObject: function(arg) {
        return typeof arg === "object" && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };
    punycode = import_punycode.default;
    util = util$1;
    parse3 = urlParse;
    resolve$1 = urlResolve;
    resolveObject = urlResolveObject;
    format = urlFormat;
    Url_1 = Url;
    protocolPattern = /^([a-z0-9.+-]+:)/i;
    portPattern = /:[0-9]*$/;
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    autoEscape = ["'"].concat(unwise);
    nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    hostEndingChars = ["/", "?", "#"];
    hostnameMaxLen = 255;
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    };
    hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    querystring = api;
    Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url2)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
      }
      var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url2 = uSplit.join(splitter);
      var rest = url2;
      rest = rest.trim();
      if (!slashesDenoteHost && url2.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i5 = 0; i5 < hostEndingChars.length; i5++) {
          var hec = rest.indexOf(hostEndingChars[i5]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i5 = 0; i5 < nonHostChars.length; i5++) {
          var hec = rest.indexOf(nonHostChars[i5]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        if (hostEnd === -1)
          hostEnd = rest.length;
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i5 = 0, l2 = hostparts.length; i5 < l2; i5++) {
            var part = hostparts[i5];
            if (!part)
              continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j2 = 0, k3 = part.length; j2 < k3; j2++) {
                if (part.charCodeAt(j2) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j2];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i5);
                var notHost = hostparts.slice(i5 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p3 = this.port ? ":" + this.port : "";
        var h3 = this.hostname || "";
        this.host = h3 + p3;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i5 = 0, l2 = autoEscape.length; i5 < l2; i5++) {
          var ae2 = autoEscape[i5];
          if (rest.indexOf(ae2) === -1)
            continue;
          var esc = encodeURIComponent(ae2);
          if (esc === ae2) {
            esc = escape(ae2);
          }
          rest = rest.split(ae2).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest)
        this.pathname = rest;
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p3 = this.pathname || "";
        var s2 = this.search || "";
        this.path = p3 + s2;
      }
      this.href = this.format();
      return this;
    };
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":")
        protocol += ":";
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/")
          pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#")
        hash = "#" + hash;
      if (search && search.charAt(0) !== "?")
        search = "?" + search;
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    Url.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol")
            result[rkey] = relative[rkey];
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v2 = 0; v2 < keys.length; v2++) {
            var k3 = keys[v2];
            result[k3] = relative[k3];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p3 = result.pathname || "";
          var s2 = result.search || "";
          result.path = p3 + s2;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i5 = srcPath.length; i5 >= 0; i5--) {
        last = srcPath[i5];
        if (last === ".") {
          srcPath.splice(i5, 1);
        } else if (last === "..") {
          srcPath.splice(i5, 1);
          up++;
        } else if (up) {
          srcPath.splice(i5, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host)
        this.hostname = host;
    };
    _globalThis2 = function(Object2) {
      function get() {
        var _global3 = this || self;
        delete Object2.prototype.__magic__;
        return _global3;
      }
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (this) {
        return get();
      } else {
        Object2.defineProperty(Object2.prototype, "__magic__", {
          configurable: true,
          get
        });
        var _global2 = __magic__;
        return _global2;
      }
    }(Object);
    formatImport = /** @type {formatImport}*/
    format;
    parseImport = /** @type {parseImport}*/
    parse3;
    resolveImport = /** @type {resolveImport}*/
    resolve$1;
    UrlImport = /** @type {UrlImport}*/
    Url_1;
    URL2 = _globalThis2.URL;
    URLSearchParams = _globalThis2.URLSearchParams;
    percentRegEx = /%/g;
    backslashRegEx = /\\/g;
    newlineRegEx = /\n/g;
    carriageReturnRegEx = /\r/g;
    tabRegEx = /\t/g;
    CHAR_FORWARD_SLASH = 47;
    domainToASCII = /**
     * @type {domainToASCII}
     */
    function domainToASCII2(domain) {
      if (typeof domain === "undefined") {
        throw new TypeError('The "domain" argument must be specified');
      }
      return new URL2("http://" + domain).hostname;
    };
    domainToUnicode = /**
     * @type {domainToUnicode}
     */
    function domainToUnicode2(domain) {
      if (typeof domain === "undefined") {
        throw new TypeError('The "domain" argument must be specified');
      }
      return new URL2("http://" + domain).hostname;
    };
    pathToFileURL = /**
     * @type {(url: string) => URL}
     */
    function pathToFileURL2(filepath) {
      var outURL = new URL2("file://");
      var resolved = resolve(filepath);
      var filePathLast = filepath.charCodeAt(filepath.length - 1);
      if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
        resolved += "/";
      }
      outURL.pathname = encodePathChars(resolved);
      return outURL;
    };
    fileURLToPath = /**
     * @type {fileURLToPath & ((path: string | URL) => string)}
     */
    function fileURLToPath2(path) {
      if (!isURLInstance(path) && typeof path !== "string") {
        throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof path + " (" + path + ")");
      }
      var resolved = new URL2(path);
      if (resolved.protocol !== "file:") {
        throw new TypeError("The URL must be of scheme file");
      }
      return getPathFromURLPosix(resolved);
    };
    formatImportWithOverloads = /**
     * @type {(
     *   ((urlObject: URL, options?: URLFormatOptions) => string) &
     *   ((urlObject: UrlObject | string, options?: never) => string)
     * )}
     */
    function formatImportWithOverloads2(urlObject, options) {
      var _options$auth, _options$fragment, _options$search;
      if (options === void 0) {
        options = {};
      }
      if (!(urlObject instanceof URL2)) {
        return formatImport(urlObject);
      }
      if (typeof options !== "object" || options === null) {
        throw new TypeError('The "options" argument must be of type object.');
      }
      var auth = (_options$auth = options.auth) != null ? _options$auth : true;
      var fragment = (_options$fragment = options.fragment) != null ? _options$fragment : true;
      var search = (_options$search = options.search) != null ? _options$search : true;
      var parsed = new URL2(urlObject.toString());
      if (!auth) {
        parsed.username = "";
        parsed.password = "";
      }
      if (!fragment) {
        parsed.hash = "";
      }
      if (!search) {
        parsed.search = "";
      }
      return parsed.toString();
    };
    api2 = {
      format: formatImportWithOverloads,
      parse: parseImport,
      resolve: resolveImport,
      resolveObject,
      Url: UrlImport,
      URL: URL2,
      URLSearchParams,
      domainToASCII,
      domainToUnicode,
      pathToFileURL,
      fileURLToPath
    };
  }
});

// node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS({
  "node_modules/nanoid/non-secure/index.cjs"(exports, module) {
    "use strict";
    init_shim();
    var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id = "";
        let i5 = size;
        while (i5--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    var nanoid = (size = 21) => {
      let id = "";
      let i5 = size;
      while (i5--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
    module.exports = { nanoid, customAlphabet };
  }
});

// node_modules/node-stdlib-browser/esm/mock/empty.js
var empty_exports = {};
__export(empty_exports, {
  default: () => empty
});
var empty;
var init_empty = __esm({
  "node_modules/node-stdlib-browser/esm/mock/empty.js"() {
    "use strict";
    init_shim();
    empty = null;
  }
});

// node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS({
  "node_modules/postcss/lib/previous-map.js"(exports, module) {
    "use strict";
    init_shim();
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { existsSync, readFileSync } = (init_empty(), __toCommonJS(empty_exports));
    var { dirname, join: join2 } = require_path_browserify();
    function fromBase64(str) {
      if (import_buffer.Buffer) {
        return import_buffer.Buffer.from(str, "base64").toString();
      } else {
        return window.atob(str);
      }
    }
    var PreviousMap = class {
      constructor(css, opts) {
        if (opts.map === false)
          return;
        this.loadAnnotation(css);
        this.inline = this.startWith(this.annotation, "data:");
        let prev = opts.map ? opts.map.prev : void 0;
        let text = this.loadMap(opts.from, prev);
        if (!this.mapFile && opts.from) {
          this.mapFile = opts.from;
        }
        if (this.mapFile)
          this.root = dirname(this.mapFile);
        if (text)
          this.text = text;
      }
      consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new SourceMapConsumer(this.text);
        }
        return this.consumerCache;
      }
      decodeInline(text) {
        let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        let baseUri = /^data:application\/json;base64,/;
        let charsetUri = /^data:application\/json;charset=utf-?8,/;
        let uri = /^data:application\/json,/;
        if (charsetUri.test(text) || uri.test(text)) {
          return decodeURIComponent(text.substr(RegExp.lastMatch.length));
        }
        if (baseCharsetUri.test(text) || baseUri.test(text)) {
          return fromBase64(text.substr(RegExp.lastMatch.length));
        }
        let encoding = text.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + encoding);
      }
      getAnnotationURL(sourceMapString) {
        return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
      }
      isMap(map) {
        if (typeof map !== "object")
          return false;
        return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
      }
      loadAnnotation(css) {
        let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
        if (!comments)
          return;
        let start = css.lastIndexOf(comments.pop());
        let end = css.indexOf("*/", start);
        if (start > -1 && end > -1) {
          this.annotation = this.getAnnotationURL(css.substring(start, end));
        }
      }
      loadFile(path) {
        this.root = dirname(path);
        if (existsSync(path)) {
          this.mapFile = path;
          return readFileSync(path, "utf-8").toString().trim();
        }
      }
      loadMap(file, prev) {
        if (prev === false)
          return false;
        if (prev) {
          if (typeof prev === "string") {
            return prev;
          } else if (typeof prev === "function") {
            let prevPath = prev(file);
            if (prevPath) {
              let map = this.loadFile(prevPath);
              if (!map) {
                throw new Error(
                  "Unable to load previous source map: " + prevPath.toString()
                );
              }
              return map;
            }
          } else if (prev instanceof SourceMapConsumer) {
            return SourceMapGenerator.fromSourceMap(prev).toString();
          } else if (prev instanceof SourceMapGenerator) {
            return prev.toString();
          } else if (this.isMap(prev)) {
            return JSON.stringify(prev);
          } else {
            throw new Error(
              "Unsupported previous source map format: " + prev.toString()
            );
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation);
        } else if (this.annotation) {
          let map = this.annotation;
          if (file)
            map = join2(dirname(file), map);
          return this.loadFile(map);
        }
      }
      startWith(string, start) {
        if (!string)
          return false;
        return string.substr(0, start.length) === start;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
    };
    module.exports = PreviousMap;
    PreviousMap.default = PreviousMap;
  }
});

// node_modules/postcss/lib/input.js
var require_input = __commonJS({
  "node_modules/postcss/lib/input.js"(exports, module) {
    "use strict";
    init_shim();
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { fileURLToPath: fileURLToPath3, pathToFileURL: pathToFileURL3 } = (init_url(), __toCommonJS(url_exports));
    var { isAbsolute, resolve: resolve2 } = require_path_browserify();
    var { nanoid } = require_non_secure();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError2 = require_css_syntax_error();
    var PreviousMap = require_previous_map();
    var fromOffsetCache = Symbol("fromOffsetCache");
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(resolve2 && isAbsolute);
    var Input2 = class {
      constructor(css, opts = {}) {
        if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
          throw new Error(`PostCSS received ${css} instead of CSS string`);
        }
        this.css = css.toString();
        if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }
        if (opts.from) {
          if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
            this.file = opts.from;
          } else {
            this.file = resolve2(opts.from);
          }
        }
        if (pathAvailable && sourceMapAvailable) {
          let map = new PreviousMap(this.css, opts);
          if (map.text) {
            this.map = map;
            let file = map.consumer().file;
            if (!this.file && file)
              this.file = this.mapResolve(file);
          }
        }
        if (!this.file) {
          this.id = "<input css " + nanoid(6) + ">";
        }
        if (this.map)
          this.map.file = this.from;
      }
      error(message, line, column, opts = {}) {
        let result, endLine, endColumn;
        if (line && typeof line === "object") {
          let start = line;
          let end = column;
          if (typeof start.offset === "number") {
            let pos = this.fromOffset(start.offset);
            line = pos.line;
            column = pos.col;
          } else {
            line = start.line;
            column = start.column;
          }
          if (typeof end.offset === "number") {
            let pos = this.fromOffset(end.offset);
            endLine = pos.line;
            endColumn = pos.col;
          } else {
            endLine = end.line;
            endColumn = end.column;
          }
        } else if (!column) {
          let pos = this.fromOffset(line);
          line = pos.line;
          column = pos.col;
        }
        let origin = this.origin(line, column, endLine, endColumn);
        if (origin) {
          result = new CssSyntaxError2(
            message,
            origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
            origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
            origin.source,
            origin.file,
            opts.plugin
          );
        } else {
          result = new CssSyntaxError2(
            message,
            endLine === void 0 ? line : { column, line },
            endLine === void 0 ? column : { column: endColumn, line: endLine },
            this.css,
            this.file,
            opts.plugin
          );
        }
        result.input = { column, endColumn, endLine, line, source: this.css };
        if (this.file) {
          if (pathToFileURL3) {
            result.input.url = pathToFileURL3(this.file).toString();
          }
          result.input.file = this.file;
        }
        return result;
      }
      fromOffset(offset) {
        let lastLine, lineToIndex;
        if (!this[fromOffsetCache]) {
          let lines = this.css.split("\n");
          lineToIndex = new Array(lines.length);
          let prevIndex = 0;
          for (let i5 = 0, l2 = lines.length; i5 < l2; i5++) {
            lineToIndex[i5] = prevIndex;
            prevIndex += lines[i5].length + 1;
          }
          this[fromOffsetCache] = lineToIndex;
        } else {
          lineToIndex = this[fromOffsetCache];
        }
        lastLine = lineToIndex[lineToIndex.length - 1];
        let min2 = 0;
        if (offset >= lastLine) {
          min2 = lineToIndex.length - 1;
        } else {
          let max3 = lineToIndex.length - 2;
          let mid;
          while (min2 < max3) {
            mid = min2 + (max3 - min2 >> 1);
            if (offset < lineToIndex[mid]) {
              max3 = mid - 1;
            } else if (offset >= lineToIndex[mid + 1]) {
              min2 = mid + 1;
            } else {
              min2 = mid;
              break;
            }
          }
        }
        return {
          col: offset - lineToIndex[min2] + 1,
          line: min2 + 1
        };
      }
      mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file;
        }
        return resolve2(this.map.consumer().sourceRoot || this.map.root || ".", file);
      }
      origin(line, column, endLine, endColumn) {
        if (!this.map)
          return false;
        let consumer = this.map.consumer();
        let from = consumer.originalPositionFor({ column, line });
        if (!from.source)
          return false;
        let to;
        if (typeof endLine === "number") {
          to = consumer.originalPositionFor({ column: endColumn, line: endLine });
        }
        let fromUrl;
        if (isAbsolute(from.source)) {
          fromUrl = pathToFileURL3(from.source);
        } else {
          fromUrl = new URL(
            from.source,
            this.map.consumer().sourceRoot || pathToFileURL3(this.map.mapFile)
          );
        }
        let result = {
          column: from.column,
          endColumn: to && to.column,
          endLine: to && to.line,
          line: from.line,
          url: fromUrl.toString()
        };
        if (fromUrl.protocol === "file:") {
          if (fileURLToPath3) {
            result.file = fileURLToPath3(fromUrl);
          } else {
            throw new Error(`file: protocol is not available in this PostCSS build`);
          }
        }
        let source = consumer.sourceContentFor(from.source);
        if (source)
          result.source = source;
        return result;
      }
      toJSON() {
        let json = {};
        for (let name of ["hasBOM", "css", "file", "id"]) {
          if (this[name] != null) {
            json[name] = this[name];
          }
        }
        if (this.map) {
          json.map = { ...this.map };
          if (json.map.consumerCache) {
            json.map.consumerCache = void 0;
          }
        }
        return json;
      }
      get from() {
        return this.file || this.id;
      }
    };
    module.exports = Input2;
    Input2.default = Input2;
    if (terminalHighlight && terminalHighlight.registerInput) {
      terminalHighlight.registerInput(Input2);
    }
  }
});

// node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS({
  "node_modules/postcss/lib/map-generator.js"(exports, module) {
    "use strict";
    init_shim();
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { dirname, relative, resolve: resolve2, sep } = require_path_browserify();
    var { pathToFileURL: pathToFileURL3 } = (init_url(), __toCommonJS(url_exports));
    var Input2 = require_input();
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(dirname && resolve2 && relative && sep);
    var MapGenerator = class {
      constructor(stringify6, root2, opts, cssString) {
        this.stringify = stringify6;
        this.mapOpts = opts.map || {};
        this.root = root2;
        this.opts = opts;
        this.css = cssString;
        this.originalCSS = cssString;
        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
        this.memoizedFileURLs = /* @__PURE__ */ new Map();
        this.memoizedPaths = /* @__PURE__ */ new Map();
        this.memoizedURLs = /* @__PURE__ */ new Map();
      }
      addAnnotation() {
        let content;
        if (this.isInline()) {
          content = "data:application/json;base64," + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === "string") {
          content = this.mapOpts.annotation;
        } else if (typeof this.mapOpts.annotation === "function") {
          content = this.mapOpts.annotation(this.opts.to, this.root);
        } else {
          content = this.outputFile() + ".map";
        }
        let eol = "\n";
        if (this.css.includes("\r\n"))
          eol = "\r\n";
        this.css += eol + "/*# sourceMappingURL=" + content + " */";
      }
      applyPrevMaps() {
        for (let prev of this.previous()) {
          let from = this.toUrl(this.path(prev.file));
          let root2 = prev.root || dirname(prev.file);
          let map;
          if (this.mapOpts.sourcesContent === false) {
            map = new SourceMapConsumer(prev.text);
            if (map.sourcesContent) {
              map.sourcesContent = null;
            }
          } else {
            map = prev.consumer();
          }
          this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));
        }
      }
      clearAnnotation() {
        if (this.mapOpts.annotation === false)
          return;
        if (this.root) {
          let node;
          for (let i5 = this.root.nodes.length - 1; i5 >= 0; i5--) {
            node = this.root.nodes[i5];
            if (node.type !== "comment")
              continue;
            if (node.text.indexOf("# sourceMappingURL=") === 0) {
              this.root.removeChild(i5);
            }
          }
        } else if (this.css) {
          this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, "");
        }
      }
      generate() {
        this.clearAnnotation();
        if (pathAvailable && sourceMapAvailable && this.isMap()) {
          return this.generateMap();
        } else {
          let result = "";
          this.stringify(this.root, (i5) => {
            result += i5;
          });
          return [result];
        }
      }
      generateMap() {
        if (this.root) {
          this.generateString();
        } else if (this.previous().length === 1) {
          let prev = this.previous()[0].consumer();
          prev.file = this.outputFile();
          this.map = SourceMapGenerator.fromSourceMap(prev);
        } else {
          this.map = new SourceMapGenerator({ file: this.outputFile() });
          this.map.addMapping({
            generated: { column: 0, line: 1 },
            original: { column: 0, line: 1 },
            source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
          });
        }
        if (this.isSourcesContent())
          this.setSourcesContent();
        if (this.root && this.previous().length > 0)
          this.applyPrevMaps();
        if (this.isAnnotation())
          this.addAnnotation();
        if (this.isInline()) {
          return [this.css];
        } else {
          return [this.css, this.map];
        }
      }
      generateString() {
        this.css = "";
        this.map = new SourceMapGenerator({ file: this.outputFile() });
        let line = 1;
        let column = 1;
        let noSource = "<no source>";
        let mapping = {
          generated: { column: 0, line: 0 },
          original: { column: 0, line: 0 },
          source: ""
        };
        let lines, last;
        this.stringify(this.root, (str, node, type) => {
          this.css += str;
          if (node && type !== "end") {
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            if (node.source && node.source.start) {
              mapping.source = this.sourcePath(node);
              mapping.original.line = node.source.start.line;
              mapping.original.column = node.source.start.column - 1;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              this.map.addMapping(mapping);
            }
          }
          lines = str.match(/\n/g);
          if (lines) {
            line += lines.length;
            last = str.lastIndexOf("\n");
            column = str.length - last;
          } else {
            column += str.length;
          }
          if (node && type !== "start") {
            let p3 = node.parent || { raws: {} };
            let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
            if (!childless || node !== p3.last || p3.raws.semicolon) {
              if (node.source && node.source.end) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.end.line;
                mapping.original.column = node.source.end.column - 1;
                mapping.generated.line = line;
                mapping.generated.column = column - 2;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                mapping.generated.line = line;
                mapping.generated.column = column - 1;
                this.map.addMapping(mapping);
              }
            }
          }
        });
      }
      isAnnotation() {
        if (this.isInline()) {
          return true;
        }
        if (typeof this.mapOpts.annotation !== "undefined") {
          return this.mapOpts.annotation;
        }
        if (this.previous().length) {
          return this.previous().some((i5) => i5.annotation);
        }
        return true;
      }
      isInline() {
        if (typeof this.mapOpts.inline !== "undefined") {
          return this.mapOpts.inline;
        }
        let annotation = this.mapOpts.annotation;
        if (typeof annotation !== "undefined" && annotation !== true) {
          return false;
        }
        if (this.previous().length) {
          return this.previous().some((i5) => i5.inline);
        }
        return true;
      }
      isMap() {
        if (typeof this.opts.map !== "undefined") {
          return !!this.opts.map;
        }
        return this.previous().length > 0;
      }
      isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== "undefined") {
          return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
          return this.previous().some((i5) => i5.withContent());
        }
        return true;
      }
      outputFile() {
        if (this.opts.to) {
          return this.path(this.opts.to);
        } else if (this.opts.from) {
          return this.path(this.opts.from);
        } else {
          return "to.css";
        }
      }
      path(file) {
        if (this.mapOpts.absolute)
          return file;
        if (file.charCodeAt(0) === 60)
          return file;
        if (/^\w+:\/\//.test(file))
          return file;
        let cached = this.memoizedPaths.get(file);
        if (cached)
          return cached;
        let from = this.opts.to ? dirname(this.opts.to) : ".";
        if (typeof this.mapOpts.annotation === "string") {
          from = dirname(resolve2(from, this.mapOpts.annotation));
        }
        let path = relative(from, file);
        this.memoizedPaths.set(file, path);
        return path;
      }
      previous() {
        if (!this.previousMaps) {
          this.previousMaps = [];
          if (this.root) {
            this.root.walk((node) => {
              if (node.source && node.source.input.map) {
                let map = node.source.input.map;
                if (!this.previousMaps.includes(map)) {
                  this.previousMaps.push(map);
                }
              }
            });
          } else {
            let input = new Input2(this.originalCSS, this.opts);
            if (input.map)
              this.previousMaps.push(input.map);
          }
        }
        return this.previousMaps;
      }
      setSourcesContent() {
        let already = {};
        if (this.root) {
          this.root.walk((node) => {
            if (node.source) {
              let from = node.source.input.from;
              if (from && !already[from]) {
                already[from] = true;
                let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
                this.map.setSourceContent(fromUrl, node.source.input.css);
              }
            }
          });
        } else if (this.css) {
          let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
          this.map.setSourceContent(from, this.css);
        }
      }
      sourcePath(node) {
        if (this.mapOpts.from) {
          return this.toUrl(this.mapOpts.from);
        } else if (this.usesFileUrls) {
          return this.toFileUrl(node.source.input.from);
        } else {
          return this.toUrl(this.path(node.source.input.from));
        }
      }
      toBase64(str) {
        if (import_buffer.Buffer) {
          return import_buffer.Buffer.from(str).toString("base64");
        } else {
          return window.btoa(unescape(encodeURIComponent(str)));
        }
      }
      toFileUrl(path) {
        let cached = this.memoizedFileURLs.get(path);
        if (cached)
          return cached;
        if (pathToFileURL3) {
          let fileURL = pathToFileURL3(path).toString();
          this.memoizedFileURLs.set(path, fileURL);
          return fileURL;
        } else {
          throw new Error(
            "`map.absolute` option is not available in this PostCSS build"
          );
        }
      }
      toUrl(path) {
        let cached = this.memoizedURLs.get(path);
        if (cached)
          return cached;
        if (sep === "\\") {
          path = path.replace(/\\/g, "/");
        }
        let url2 = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
        this.memoizedURLs.set(path, url2);
        return url2;
      }
    };
    module.exports = MapGenerator;
  }
});

// node_modules/postcss/lib/comment.js
var require_comment = __commonJS({
  "node_modules/postcss/lib/comment.js"(exports, module) {
    "use strict";
    init_shim();
    var Node2 = require_node();
    var Comment2 = class extends Node2 {
      constructor(defaults3) {
        super(defaults3);
        this.type = "comment";
      }
    };
    module.exports = Comment2;
    Comment2.default = Comment2;
  }
});

// node_modules/postcss/lib/container.js
var require_container = __commonJS({
  "node_modules/postcss/lib/container.js"(exports, module) {
    "use strict";
    init_shim();
    var { isClean, my } = require_symbols();
    var Declaration2 = require_declaration();
    var Comment2 = require_comment();
    var Node2 = require_node();
    var parse6;
    var Rule2;
    var AtRule2;
    var Root2;
    function cleanSource(nodes) {
      return nodes.map((i5) => {
        if (i5.nodes)
          i5.nodes = cleanSource(i5.nodes);
        delete i5.source;
        return i5;
      });
    }
    function markDirtyUp(node) {
      node[isClean] = false;
      if (node.proxyOf.nodes) {
        for (let i5 of node.proxyOf.nodes) {
          markDirtyUp(i5);
        }
      }
    }
    var Container2 = class _Container extends Node2 {
      append(...children) {
        for (let child of children) {
          let nodes = this.normalize(child, this.last);
          for (let node of nodes)
            this.proxyOf.nodes.push(node);
        }
        this.markDirty();
        return this;
      }
      cleanRaws(keepBetween) {
        super.cleanRaws(keepBetween);
        if (this.nodes) {
          for (let node of this.nodes)
            node.cleanRaws(keepBetween);
        }
      }
      each(callback) {
        if (!this.proxyOf.nodes)
          return void 0;
        let iterator = this.getIterator();
        let index2, result;
        while (this.indexes[iterator] < this.proxyOf.nodes.length) {
          index2 = this.indexes[iterator];
          result = callback(this.proxyOf.nodes[index2], index2);
          if (result === false)
            break;
          this.indexes[iterator] += 1;
        }
        delete this.indexes[iterator];
        return result;
      }
      every(condition) {
        return this.nodes.every(condition);
      }
      getIterator() {
        if (!this.lastEach)
          this.lastEach = 0;
        if (!this.indexes)
          this.indexes = {};
        this.lastEach += 1;
        let iterator = this.lastEach;
        this.indexes[iterator] = 0;
        return iterator;
      }
      getProxyProcessor() {
        return {
          get(node, prop) {
            if (prop === "proxyOf") {
              return node;
            } else if (!node[prop]) {
              return node[prop];
            } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
              return (...args) => {
                return node[prop](
                  ...args.map((i5) => {
                    if (typeof i5 === "function") {
                      return (child, index2) => i5(child.toProxy(), index2);
                    } else {
                      return i5;
                    }
                  })
                );
              };
            } else if (prop === "every" || prop === "some") {
              return (cb) => {
                return node[prop](
                  (child, ...other) => cb(child.toProxy(), ...other)
                );
              };
            } else if (prop === "root") {
              return () => node.root().toProxy();
            } else if (prop === "nodes") {
              return node.nodes.map((i5) => i5.toProxy());
            } else if (prop === "first" || prop === "last") {
              return node[prop].toProxy();
            } else {
              return node[prop];
            }
          },
          set(node, prop, value2) {
            if (node[prop] === value2)
              return true;
            node[prop] = value2;
            if (prop === "name" || prop === "params" || prop === "selector") {
              node.markDirty();
            }
            return true;
          }
        };
      }
      index(child) {
        if (typeof child === "number")
          return child;
        if (child.proxyOf)
          child = child.proxyOf;
        return this.proxyOf.nodes.indexOf(child);
      }
      insertAfter(exist, add) {
        let existIndex = this.index(exist);
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
        existIndex = this.index(exist);
        for (let node of nodes)
          this.proxyOf.nodes.splice(existIndex + 1, 0, node);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (existIndex < index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      insertBefore(exist, add) {
        let existIndex = this.index(exist);
        let type = existIndex === 0 ? "prepend" : false;
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
        existIndex = this.index(exist);
        for (let node of nodes)
          this.proxyOf.nodes.splice(existIndex, 0, node);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (existIndex <= index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      normalize(nodes, sample) {
        if (typeof nodes === "string") {
          nodes = cleanSource(parse6(nodes).nodes);
        } else if (typeof nodes === "undefined") {
          nodes = [];
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (let i5 of nodes) {
            if (i5.parent)
              i5.parent.removeChild(i5, "ignore");
          }
        } else if (nodes.type === "root" && this.type !== "document") {
          nodes = nodes.nodes.slice(0);
          for (let i5 of nodes) {
            if (i5.parent)
              i5.parent.removeChild(i5, "ignore");
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === "undefined") {
            throw new Error("Value field is missed in node creation");
          } else if (typeof nodes.value !== "string") {
            nodes.value = String(nodes.value);
          }
          nodes = [new Declaration2(nodes)];
        } else if (nodes.selector) {
          nodes = [new Rule2(nodes)];
        } else if (nodes.name) {
          nodes = [new AtRule2(nodes)];
        } else if (nodes.text) {
          nodes = [new Comment2(nodes)];
        } else {
          throw new Error("Unknown node type in node creation");
        }
        let processed = nodes.map((i5) => {
          if (!i5[my])
            _Container.rebuild(i5);
          i5 = i5.proxyOf;
          if (i5.parent)
            i5.parent.removeChild(i5);
          if (i5[isClean])
            markDirtyUp(i5);
          if (typeof i5.raws.before === "undefined") {
            if (sample && typeof sample.raws.before !== "undefined") {
              i5.raws.before = sample.raws.before.replace(/\S/g, "");
            }
          }
          i5.parent = this.proxyOf;
          return i5;
        });
        return processed;
      }
      prepend(...children) {
        children = children.reverse();
        for (let child of children) {
          let nodes = this.normalize(child, this.first, "prepend").reverse();
          for (let node of nodes)
            this.proxyOf.nodes.unshift(node);
          for (let id in this.indexes) {
            this.indexes[id] = this.indexes[id] + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      push(child) {
        child.parent = this;
        this.proxyOf.nodes.push(child);
        return this;
      }
      removeAll() {
        for (let node of this.proxyOf.nodes)
          node.parent = void 0;
        this.proxyOf.nodes = [];
        this.markDirty();
        return this;
      }
      removeChild(child) {
        child = this.index(child);
        this.proxyOf.nodes[child].parent = void 0;
        this.proxyOf.nodes.splice(child, 1);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (index2 >= child) {
            this.indexes[id] = index2 - 1;
          }
        }
        this.markDirty();
        return this;
      }
      replaceValues(pattern2, opts, callback) {
        if (!callback) {
          callback = opts;
          opts = {};
        }
        this.walkDecls((decl2) => {
          if (opts.props && !opts.props.includes(decl2.prop))
            return;
          if (opts.fast && !decl2.value.includes(opts.fast))
            return;
          decl2.value = decl2.value.replace(pattern2, callback);
        });
        this.markDirty();
        return this;
      }
      some(condition) {
        return this.nodes.some(condition);
      }
      walk(callback) {
        return this.each((child, i5) => {
          let result;
          try {
            result = callback(child, i5);
          } catch (e4) {
            throw child.addToError(e4);
          }
          if (result !== false && child.walk) {
            result = child.walk(callback);
          }
          return result;
        });
      }
      walkAtRules(name, callback) {
        if (!callback) {
          callback = name;
          return this.walk((child, i5) => {
            if (child.type === "atrule") {
              return callback(child, i5);
            }
          });
        }
        if (name instanceof RegExp) {
          return this.walk((child, i5) => {
            if (child.type === "atrule" && name.test(child.name)) {
              return callback(child, i5);
            }
          });
        }
        return this.walk((child, i5) => {
          if (child.type === "atrule" && child.name === name) {
            return callback(child, i5);
          }
        });
      }
      walkComments(callback) {
        return this.walk((child, i5) => {
          if (child.type === "comment") {
            return callback(child, i5);
          }
        });
      }
      walkDecls(prop, callback) {
        if (!callback) {
          callback = prop;
          return this.walk((child, i5) => {
            if (child.type === "decl") {
              return callback(child, i5);
            }
          });
        }
        if (prop instanceof RegExp) {
          return this.walk((child, i5) => {
            if (child.type === "decl" && prop.test(child.prop)) {
              return callback(child, i5);
            }
          });
        }
        return this.walk((child, i5) => {
          if (child.type === "decl" && child.prop === prop) {
            return callback(child, i5);
          }
        });
      }
      walkRules(selector, callback) {
        if (!callback) {
          callback = selector;
          return this.walk((child, i5) => {
            if (child.type === "rule") {
              return callback(child, i5);
            }
          });
        }
        if (selector instanceof RegExp) {
          return this.walk((child, i5) => {
            if (child.type === "rule" && selector.test(child.selector)) {
              return callback(child, i5);
            }
          });
        }
        return this.walk((child, i5) => {
          if (child.type === "rule" && child.selector === selector) {
            return callback(child, i5);
          }
        });
      }
      get first() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[0];
      }
      get last() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
    };
    Container2.registerParse = (dependant) => {
      parse6 = dependant;
    };
    Container2.registerRule = (dependant) => {
      Rule2 = dependant;
    };
    Container2.registerAtRule = (dependant) => {
      AtRule2 = dependant;
    };
    Container2.registerRoot = (dependant) => {
      Root2 = dependant;
    };
    module.exports = Container2;
    Container2.default = Container2;
    Container2.rebuild = (node) => {
      if (node.type === "atrule") {
        Object.setPrototypeOf(node, AtRule2.prototype);
      } else if (node.type === "rule") {
        Object.setPrototypeOf(node, Rule2.prototype);
      } else if (node.type === "decl") {
        Object.setPrototypeOf(node, Declaration2.prototype);
      } else if (node.type === "comment") {
        Object.setPrototypeOf(node, Comment2.prototype);
      } else if (node.type === "root") {
        Object.setPrototypeOf(node, Root2.prototype);
      }
      node[my] = true;
      if (node.nodes) {
        node.nodes.forEach((child) => {
          Container2.rebuild(child);
        });
      }
    };
  }
});

// node_modules/postcss/lib/document.js
var require_document = __commonJS({
  "node_modules/postcss/lib/document.js"(exports, module) {
    "use strict";
    init_shim();
    var Container2 = require_container();
    var LazyResult;
    var Processor3;
    var Document2 = class extends Container2 {
      constructor(defaults3) {
        super({ type: "document", ...defaults3 });
        if (!this.nodes) {
          this.nodes = [];
        }
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor3(), this, opts);
        return lazy.stringify();
      }
    };
    Document2.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Document2.registerProcessor = (dependant) => {
      Processor3 = dependant;
    };
    module.exports = Document2;
    Document2.default = Document2;
  }
});

// node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS({
  "node_modules/postcss/lib/warn-once.js"(exports, module) {
    "use strict";
    init_shim();
    var printed = {};
    module.exports = function warnOnce(message) {
      if (printed[message])
        return;
      printed[message] = true;
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
    };
  }
});

// node_modules/postcss/lib/warning.js
var require_warning = __commonJS({
  "node_modules/postcss/lib/warning.js"(exports, module) {
    "use strict";
    init_shim();
    var Warning2 = class {
      constructor(text, opts = {}) {
        this.type = "warning";
        this.text = text;
        if (opts.node && opts.node.source) {
          let range = opts.node.rangeBy(opts);
          this.line = range.start.line;
          this.column = range.start.column;
          this.endLine = range.end.line;
          this.endColumn = range.end.column;
        }
        for (let opt in opts)
          this[opt] = opts[opt];
      }
      toString() {
        if (this.node) {
          return this.node.error(this.text, {
            index: this.index,
            plugin: this.plugin,
            word: this.word
          }).message;
        }
        if (this.plugin) {
          return this.plugin + ": " + this.text;
        }
        return this.text;
      }
    };
    module.exports = Warning2;
    Warning2.default = Warning2;
  }
});

// node_modules/postcss/lib/result.js
var require_result = __commonJS({
  "node_modules/postcss/lib/result.js"(exports, module) {
    "use strict";
    init_shim();
    var Warning2 = require_warning();
    var Result2 = class {
      constructor(processor, root2, opts) {
        this.processor = processor;
        this.messages = [];
        this.root = root2;
        this.opts = opts;
        this.css = void 0;
        this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(text, opts = {}) {
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }
        let warning = new Warning2(text, opts);
        this.messages.push(warning);
        return warning;
      }
      warnings() {
        return this.messages.filter((i5) => i5.type === "warning");
      }
      get content() {
        return this.css;
      }
    };
    module.exports = Result2;
    Result2.default = Result2;
  }
});

// node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/postcss/lib/tokenize.js"(exports, module) {
    "use strict";
    init_shim();
    var SINGLE_QUOTE = "'".charCodeAt(0);
    var DOUBLE_QUOTE = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var SLASH = "/".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var SPACE3 = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var OPEN_SQUARE = "[".charCodeAt(0);
    var CLOSE_SQUARE = "]".charCodeAt(0);
    var OPEN_PARENTHESES = "(".charCodeAt(0);
    var CLOSE_PARENTHESES = ")".charCodeAt(0);
    var OPEN_CURLY = "{".charCodeAt(0);
    var CLOSE_CURLY = "}".charCodeAt(0);
    var SEMICOLON = ";".charCodeAt(0);
    var ASTERISK = "*".charCodeAt(0);
    var COLON = ":".charCodeAt(0);
    var AT = "@".charCodeAt(0);
    var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
    var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
    var RE_HEX_ESCAPE = /[\da-f]/i;
    module.exports = function tokenizer2(input, options = {}) {
      let css = input.css.valueOf();
      let ignore = options.ignoreErrors;
      let code, next, quote, content, escape3;
      let escaped, escapePos, prev, n4, currentToken;
      let length2 = css.length;
      let pos = 0;
      let buffer = [];
      let returned = [];
      function position2() {
        return pos;
      }
      function unclosed(what) {
        throw input.error("Unclosed " + what, pos);
      }
      function endOfFile() {
        return returned.length === 0 && pos >= length2;
      }
      function nextToken(opts) {
        if (returned.length)
          return returned.pop();
        if (pos >= length2)
          return;
        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
        code = css.charCodeAt(pos);
        switch (code) {
          case NEWLINE:
          case SPACE3:
          case TAB:
          case CR:
          case FEED: {
            next = pos;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === SPACE3 || code === NEWLINE || code === TAB || code === CR || code === FEED);
            currentToken = ["space", css.slice(pos, next)];
            pos = next - 1;
            break;
          }
          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON:
          case SEMICOLON:
          case CLOSE_PARENTHESES: {
            let controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, pos];
            break;
          }
          case OPEN_PARENTHESES: {
            prev = buffer.length ? buffer.pop()[1] : "";
            n4 = css.charCodeAt(pos + 1);
            if (prev === "url" && n4 !== SINGLE_QUOTE && n4 !== DOUBLE_QUOTE && n4 !== SPACE3 && n4 !== NEWLINE && n4 !== TAB && n4 !== FEED && n4 !== CR) {
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(")", next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos;
                    break;
                  } else {
                    unclosed("bracket");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              next = css.indexOf(")", pos + 1);
              content = css.slice(pos, next + 1);
              if (next === -1 || RE_BAD_BRACKET.test(content)) {
                currentToken = ["(", "(", pos];
              } else {
                currentToken = ["brackets", content, pos, next];
                pos = next;
              }
            }
            break;
          }
          case SINGLE_QUOTE:
          case DOUBLE_QUOTE: {
            quote = code === SINGLE_QUOTE ? "'" : '"';
            next = pos;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos + 1;
                  break;
                } else {
                  unclosed("string");
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            currentToken = ["string", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case AT: {
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css);
            if (RE_AT_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }
            currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case BACKSLASH: {
            next = pos;
            escape3 = true;
            while (css.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape3 = !escape3;
            }
            code = css.charCodeAt(next + 1);
            if (escape3 && code !== SLASH && code !== SPACE3 && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
              next += 1;
              if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                  next += 1;
                }
                if (css.charCodeAt(next + 1) === SPACE3) {
                  next += 1;
                }
              }
            }
            currentToken = ["word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          default: {
            if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
              next = css.indexOf("*/", pos + 2) + 1;
              if (next === 0) {
                if (ignore || ignoreUnclosed) {
                  next = css.length;
                } else {
                  unclosed("comment");
                }
              }
              currentToken = ["comment", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css);
              if (RE_WORD_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }
              currentToken = ["word", css.slice(pos, next + 1), pos, next];
              buffer.push(currentToken);
              pos = next;
            }
            break;
          }
        }
        pos++;
        return currentToken;
      }
      function back(token) {
        returned.push(token);
      }
      return {
        back,
        endOfFile,
        nextToken,
        position: position2
      };
    };
  }
});

// node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS({
  "node_modules/postcss/lib/at-rule.js"(exports, module) {
    "use strict";
    init_shim();
    var Container2 = require_container();
    var AtRule2 = class extends Container2 {
      constructor(defaults3) {
        super(defaults3);
        this.type = "atrule";
      }
      append(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.append(...children);
      }
      prepend(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.prepend(...children);
      }
    };
    module.exports = AtRule2;
    AtRule2.default = AtRule2;
    Container2.registerAtRule(AtRule2);
  }
});

// node_modules/postcss/lib/root.js
var require_root = __commonJS({
  "node_modules/postcss/lib/root.js"(exports, module) {
    "use strict";
    init_shim();
    var Container2 = require_container();
    var LazyResult;
    var Processor3;
    var Root2 = class extends Container2 {
      constructor(defaults3) {
        super(defaults3);
        this.type = "root";
        if (!this.nodes)
          this.nodes = [];
      }
      normalize(child, sample, type) {
        let nodes = super.normalize(child);
        if (sample) {
          if (type === "prepend") {
            if (this.nodes.length > 1) {
              sample.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample.raws.before;
            }
          } else if (this.first !== sample) {
            for (let node of nodes) {
              node.raws.before = sample.raws.before;
            }
          }
        }
        return nodes;
      }
      removeChild(child, ignore) {
        let index2 = this.index(child);
        if (!ignore && index2 === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index2].raws.before;
        }
        return super.removeChild(child);
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor3(), this, opts);
        return lazy.stringify();
      }
    };
    Root2.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Root2.registerProcessor = (dependant) => {
      Processor3 = dependant;
    };
    module.exports = Root2;
    Root2.default = Root2;
    Container2.registerRoot(Root2);
  }
});

// node_modules/postcss/lib/list.js
var require_list = __commonJS({
  "node_modules/postcss/lib/list.js"(exports, module) {
    "use strict";
    init_shim();
    var list3 = {
      comma(string) {
        return list3.split(string, [","], true);
      },
      space(string) {
        let spaces = [" ", "\n", "	"];
        return list3.split(string, spaces);
      },
      split(string, separators, last) {
        let array = [];
        let current = "";
        let split = false;
        let func = 0;
        let inQuote = false;
        let prevQuote = "";
        let escape3 = false;
        for (let letter of string) {
          if (escape3) {
            escape3 = false;
          } else if (letter === "\\") {
            escape3 = true;
          } else if (inQuote) {
            if (letter === prevQuote) {
              inQuote = false;
            }
          } else if (letter === '"' || letter === "'") {
            inQuote = true;
            prevQuote = letter;
          } else if (letter === "(") {
            func += 1;
          } else if (letter === ")") {
            if (func > 0)
              func -= 1;
          } else if (func === 0) {
            if (separators.includes(letter))
              split = true;
          }
          if (split) {
            if (current !== "")
              array.push(current.trim());
            current = "";
            split = false;
          } else {
            current += letter;
          }
        }
        if (last || current !== "")
          array.push(current.trim());
        return array;
      }
    };
    module.exports = list3;
    list3.default = list3;
  }
});

// node_modules/postcss/lib/rule.js
var require_rule = __commonJS({
  "node_modules/postcss/lib/rule.js"(exports, module) {
    "use strict";
    init_shim();
    var Container2 = require_container();
    var list3 = require_list();
    var Rule2 = class extends Container2 {
      constructor(defaults3) {
        super(defaults3);
        this.type = "rule";
        if (!this.nodes)
          this.nodes = [];
      }
      get selectors() {
        return list3.comma(this.selector);
      }
      set selectors(values) {
        let match = this.selector ? this.selector.match(/,\s*/) : null;
        let sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
        this.selector = values.join(sep);
      }
    };
    module.exports = Rule2;
    Rule2.default = Rule2;
    Container2.registerRule(Rule2);
  }
});

// node_modules/postcss/lib/parser.js
var require_parser = __commonJS({
  "node_modules/postcss/lib/parser.js"(exports, module) {
    "use strict";
    init_shim();
    var Declaration2 = require_declaration();
    var tokenizer2 = require_tokenize();
    var Comment2 = require_comment();
    var AtRule2 = require_at_rule();
    var Root2 = require_root();
    var Rule2 = require_rule();
    var SAFE_COMMENT_NEIGHBOR = {
      empty: true,
      space: true
    };
    function findLastWithPosition(tokens) {
      for (let i5 = tokens.length - 1; i5 >= 0; i5--) {
        let token = tokens[i5];
        let pos = token[3] || token[2];
        if (pos)
          return pos;
      }
    }
    var Parser = class {
      constructor(input) {
        this.input = input;
        this.root = new Root2();
        this.current = this.root;
        this.spaces = "";
        this.semicolon = false;
        this.createTokenizer();
        this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
      }
      atrule(token) {
        let node = new AtRule2();
        node.name = token[1].slice(1);
        if (node.name === "") {
          this.unnamedAtrule(node, token);
        }
        this.init(node, token[2]);
        let type;
        let prev;
        let shift;
        let last = false;
        let open = false;
        let params = [];
        let brackets = [];
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          type = token[0];
          if (type === "(" || type === "[") {
            brackets.push(type === "(" ? ")" : "]");
          } else if (type === "{" && brackets.length > 0) {
            brackets.push("}");
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
          }
          if (brackets.length === 0) {
            if (type === ";") {
              node.source.end = this.getPosition(token[2]);
              node.source.end.offset++;
              this.semicolon = true;
              break;
            } else if (type === "{") {
              open = true;
              break;
            } else if (type === "}") {
              if (params.length > 0) {
                shift = params.length - 1;
                prev = params[shift];
                while (prev && prev[0] === "space") {
                  prev = params[--shift];
                }
                if (prev) {
                  node.source.end = this.getPosition(prev[3] || prev[2]);
                  node.source.end.offset++;
                }
              }
              this.end(token);
              break;
            } else {
              params.push(token);
            }
          } else {
            params.push(token);
          }
          if (this.tokenizer.endOfFile()) {
            last = true;
            break;
          }
        }
        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node, "params", params);
          if (last) {
            token = params[params.length - 1];
            node.source.end = this.getPosition(token[3] || token[2]);
            node.source.end.offset++;
            this.spaces = node.raws.between;
            node.raws.between = "";
          }
        } else {
          node.raws.afterName = "";
          node.params = "";
        }
        if (open) {
          node.nodes = [];
          this.current = node;
        }
      }
      checkMissedSemicolon(tokens) {
        let colon = this.colon(tokens);
        if (colon === false)
          return;
        let founded = 0;
        let token;
        for (let j2 = colon - 1; j2 >= 0; j2--) {
          token = tokens[j2];
          if (token[0] !== "space") {
            founded += 1;
            if (founded === 2)
              break;
          }
        }
        throw this.input.error(
          "Missed semicolon",
          token[0] === "word" ? token[3] + 1 : token[2]
        );
      }
      colon(tokens) {
        let brackets = 0;
        let token, type, prev;
        for (let [i5, element] of tokens.entries()) {
          token = element;
          type = token[0];
          if (type === "(") {
            brackets += 1;
          }
          if (type === ")") {
            brackets -= 1;
          }
          if (brackets === 0 && type === ":") {
            if (!prev) {
              this.doubleColon(token);
            } else if (prev[0] === "word" && prev[1] === "progid") {
              continue;
            } else {
              return i5;
            }
          }
          prev = token;
        }
        return false;
      }
      comment(token) {
        let node = new Comment2();
        this.init(node, token[2]);
        node.source.end = this.getPosition(token[3] || token[2]);
        node.source.end.offset++;
        let text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
          node.text = "";
          node.raws.left = text;
          node.raws.right = "";
        } else {
          let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
          node.text = match[2];
          node.raws.left = match[1];
          node.raws.right = match[3];
        }
      }
      createTokenizer() {
        this.tokenizer = tokenizer2(this.input);
      }
      decl(tokens, customProperty) {
        let node = new Declaration2();
        this.init(node, tokens[0][2]);
        let last = tokens[tokens.length - 1];
        if (last[0] === ";") {
          this.semicolon = true;
          tokens.pop();
        }
        node.source.end = this.getPosition(
          last[3] || last[2] || findLastWithPosition(tokens)
        );
        node.source.end.offset++;
        while (tokens[0][0] !== "word") {
          if (tokens.length === 1)
            this.unknownWord(tokens);
          node.raws.before += tokens.shift()[1];
        }
        node.source.start = this.getPosition(tokens[0][2]);
        node.prop = "";
        while (tokens.length) {
          let type = tokens[0][0];
          if (type === ":" || type === "space" || type === "comment") {
            break;
          }
          node.prop += tokens.shift()[1];
        }
        node.raws.between = "";
        let token;
        while (tokens.length) {
          token = tokens.shift();
          if (token[0] === ":") {
            node.raws.between += token[1];
            break;
          } else {
            if (token[0] === "word" && /\w/.test(token[1])) {
              this.unknownWord([token]);
            }
            node.raws.between += token[1];
          }
        }
        if (node.prop[0] === "_" || node.prop[0] === "*") {
          node.raws.before += node.prop[0];
          node.prop = node.prop.slice(1);
        }
        let firstSpaces = [];
        let next;
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          firstSpaces.push(tokens.shift());
        }
        this.precheckMissedSemicolon(tokens);
        for (let i5 = tokens.length - 1; i5 >= 0; i5--) {
          token = tokens[i5];
          if (token[1].toLowerCase() === "!important") {
            node.important = true;
            let string = this.stringFrom(tokens, i5);
            string = this.spacesFromEnd(tokens) + string;
            if (string !== " !important")
              node.raws.important = string;
            break;
          } else if (token[1].toLowerCase() === "important") {
            let cache2 = tokens.slice(0);
            let str = "";
            for (let j2 = i5; j2 > 0; j2--) {
              let type = cache2[j2][0];
              if (str.trim().indexOf("!") === 0 && type !== "space") {
                break;
              }
              str = cache2.pop()[1] + str;
            }
            if (str.trim().indexOf("!") === 0) {
              node.important = true;
              node.raws.important = str;
              tokens = cache2;
            }
          }
          if (token[0] !== "space" && token[0] !== "comment") {
            break;
          }
        }
        let hasWord = tokens.some((i5) => i5[0] !== "space" && i5[0] !== "comment");
        if (hasWord) {
          node.raws.between += firstSpaces.map((i5) => i5[1]).join("");
          firstSpaces = [];
        }
        this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
        if (node.value.includes(":") && !customProperty) {
          this.checkMissedSemicolon(tokens);
        }
      }
      doubleColon(token) {
        throw this.input.error(
          "Double colon",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
      emptyRule(token) {
        let node = new Rule2();
        this.init(node, token[2]);
        node.selector = "";
        node.raws.between = "";
        this.current = node;
      }
      end(token) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.spaces = "";
        if (this.current.parent) {
          this.current.source.end = this.getPosition(token[2]);
          this.current.source.end.offset++;
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token);
        }
      }
      endFile() {
        if (this.current.parent)
          this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.root.source.end = this.getPosition(this.tokenizer.position());
      }
      freeSemicolon(token) {
        this.spaces += token[1];
        if (this.current.nodes) {
          let prev = this.current.nodes[this.current.nodes.length - 1];
          if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
            prev.raws.ownSemicolon = this.spaces;
            this.spaces = "";
          }
        }
      }
      // Helpers
      getPosition(offset) {
        let pos = this.input.fromOffset(offset);
        return {
          column: pos.col,
          line: pos.line,
          offset
        };
      }
      init(node, offset) {
        this.current.push(node);
        node.source = {
          input: this.input,
          start: this.getPosition(offset)
        };
        node.raws.before = this.spaces;
        this.spaces = "";
        if (node.type !== "comment")
          this.semicolon = false;
      }
      other(start) {
        let end = false;
        let type = null;
        let colon = false;
        let bracket = null;
        let brackets = [];
        let customProperty = start[1].startsWith("--");
        let tokens = [];
        let token = start;
        while (token) {
          type = token[0];
          tokens.push(token);
          if (type === "(" || type === "[") {
            if (!bracket)
              bracket = token;
            brackets.push(type === "(" ? ")" : "]");
          } else if (customProperty && colon && type === "{") {
            if (!bracket)
              bracket = token;
            brackets.push("}");
          } else if (brackets.length === 0) {
            if (type === ";") {
              if (colon) {
                this.decl(tokens, customProperty);
                return;
              } else {
                break;
              }
            } else if (type === "{") {
              this.rule(tokens);
              return;
            } else if (type === "}") {
              this.tokenizer.back(tokens.pop());
              end = true;
              break;
            } else if (type === ":") {
              colon = true;
            }
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0)
              bracket = null;
          }
          token = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile())
          end = true;
        if (brackets.length > 0)
          this.unclosedBracket(bracket);
        if (end && colon) {
          if (!customProperty) {
            while (tokens.length) {
              token = tokens[tokens.length - 1][0];
              if (token !== "space" && token !== "comment")
                break;
              this.tokenizer.back(tokens.pop());
            }
          }
          this.decl(tokens, customProperty);
        } else {
          this.unknownWord(tokens);
        }
      }
      parse() {
        let token;
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          switch (token[0]) {
            case "space":
              this.spaces += token[1];
              break;
            case ";":
              this.freeSemicolon(token);
              break;
            case "}":
              this.end(token);
              break;
            case "comment":
              this.comment(token);
              break;
            case "at-word":
              this.atrule(token);
              break;
            case "{":
              this.emptyRule(token);
              break;
            default:
              this.other(token);
              break;
          }
        }
        this.endFile();
      }
      precheckMissedSemicolon() {
      }
      raw(node, prop, tokens, customProperty) {
        let token, type;
        let length2 = tokens.length;
        let value2 = "";
        let clean = true;
        let next, prev;
        for (let i5 = 0; i5 < length2; i5 += 1) {
          token = tokens[i5];
          type = token[0];
          if (type === "space" && i5 === length2 - 1 && !customProperty) {
            clean = false;
          } else if (type === "comment") {
            prev = tokens[i5 - 1] ? tokens[i5 - 1][0] : "empty";
            next = tokens[i5 + 1] ? tokens[i5 + 1][0] : "empty";
            if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
              if (value2.slice(-1) === ",") {
                clean = false;
              } else {
                value2 += token[1];
              }
            } else {
              clean = false;
            }
          } else {
            value2 += token[1];
          }
        }
        if (!clean) {
          let raw = tokens.reduce((all, i5) => all + i5[1], "");
          node.raws[prop] = { raw, value: value2 };
        }
        node[prop] = value2;
      }
      rule(tokens) {
        tokens.pop();
        let node = new Rule2();
        this.init(node, tokens[0][2]);
        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, "selector", tokens);
        this.current = node;
      }
      spacesAndCommentsFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space" && lastTokenType !== "comment")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      // Errors
      spacesAndCommentsFromStart(tokens) {
        let next;
        let spaces = "";
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          spaces += tokens.shift()[1];
        }
        return spaces;
      }
      spacesFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      stringFrom(tokens, from) {
        let result = "";
        for (let i5 = from; i5 < tokens.length; i5++) {
          result += tokens[i5][1];
        }
        tokens.splice(from, tokens.length - from);
        return result;
      }
      unclosedBlock() {
        let pos = this.current.source.start;
        throw this.input.error("Unclosed block", pos.line, pos.column);
      }
      unclosedBracket(bracket) {
        throw this.input.error(
          "Unclosed bracket",
          { offset: bracket[2] },
          { offset: bracket[2] + 1 }
        );
      }
      unexpectedClose(token) {
        throw this.input.error(
          "Unexpected }",
          { offset: token[2] },
          { offset: token[2] + 1 }
        );
      }
      unknownWord(tokens) {
        throw this.input.error(
          "Unknown word",
          { offset: tokens[0][2] },
          { offset: tokens[0][2] + tokens[0][1].length }
        );
      }
      unnamedAtrule(node, token) {
        throw this.input.error(
          "At-rule without name",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
    };
    module.exports = Parser;
  }
});

// node_modules/postcss/lib/parse.js
var require_parse = __commonJS({
  "node_modules/postcss/lib/parse.js"(exports, module) {
    "use strict";
    init_shim();
    var Container2 = require_container();
    var Parser = require_parser();
    var Input2 = require_input();
    function parse6(css, opts) {
      let input = new Input2(css, opts);
      let parser4 = new Parser(input);
      try {
        parser4.parse();
      } catch (e4) {
        if (import_process.default.env.NODE_ENV !== "production") {
          if (e4.name === "CssSyntaxError" && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e4.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
            } else if (/\.sass/i.test(opts.from)) {
              e4.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
            } else if (/\.less$/i.test(opts.from)) {
              e4.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
            }
          }
        }
        throw e4;
      }
      return parser4.root;
    }
    module.exports = parse6;
    parse6.default = parse6;
    Container2.registerParse(parse6);
  }
});

// node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS({
  "node_modules/postcss/lib/lazy-result.js"(exports, module) {
    "use strict";
    init_shim();
    var { isClean, my } = require_symbols();
    var MapGenerator = require_map_generator();
    var stringify6 = require_stringify();
    var Container2 = require_container();
    var Document2 = require_document();
    var warnOnce = require_warn_once();
    var Result2 = require_result();
    var parse6 = require_parse();
    var Root2 = require_root();
    var TYPE_TO_CLASS_NAME = {
      atrule: "AtRule",
      comment: "Comment",
      decl: "Declaration",
      document: "Document",
      root: "Root",
      rule: "Rule"
    };
    var PLUGIN_PROPS = {
      AtRule: true,
      AtRuleExit: true,
      Comment: true,
      CommentExit: true,
      Declaration: true,
      DeclarationExit: true,
      Document: true,
      DocumentExit: true,
      Once: true,
      OnceExit: true,
      postcssPlugin: true,
      prepare: true,
      Root: true,
      RootExit: true,
      Rule: true,
      RuleExit: true
    };
    var NOT_VISITORS = {
      Once: true,
      postcssPlugin: true,
      prepare: true
    };
    var CHILDREN = 0;
    function isPromise(obj) {
      return typeof obj === "object" && typeof obj.then === "function";
    }
    function getEvents(node) {
      let key = false;
      let type = TYPE_TO_CLASS_NAME[node.type];
      if (node.type === "decl") {
        key = node.prop.toLowerCase();
      } else if (node.type === "atrule") {
        key = node.name.toLowerCase();
      }
      if (key && node.append) {
        return [
          type,
          type + "-" + key,
          CHILDREN,
          type + "Exit",
          type + "Exit-" + key
        ];
      } else if (key) {
        return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
      } else if (node.append) {
        return [type, CHILDREN, type + "Exit"];
      } else {
        return [type, type + "Exit"];
      }
    }
    function toStack(node) {
      let events;
      if (node.type === "document") {
        events = ["Document", CHILDREN, "DocumentExit"];
      } else if (node.type === "root") {
        events = ["Root", CHILDREN, "RootExit"];
      } else {
        events = getEvents(node);
      }
      return {
        eventIndex: 0,
        events,
        iterator: 0,
        node,
        visitorIndex: 0,
        visitors: []
      };
    }
    function cleanMarks(node) {
      node[isClean] = false;
      if (node.nodes)
        node.nodes.forEach((i5) => cleanMarks(i5));
      return node;
    }
    var postcss2 = {};
    var LazyResult = class _LazyResult {
      constructor(processor, css, opts) {
        this.stringified = false;
        this.processed = false;
        let root2;
        if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
          root2 = cleanMarks(css);
        } else if (css instanceof _LazyResult || css instanceof Result2) {
          root2 = cleanMarks(css.root);
          if (css.map) {
            if (typeof opts.map === "undefined")
              opts.map = {};
            if (!opts.map.inline)
              opts.map.inline = false;
            opts.map.prev = css.map;
          }
        } else {
          let parser4 = parse6;
          if (opts.syntax)
            parser4 = opts.syntax.parse;
          if (opts.parser)
            parser4 = opts.parser;
          if (parser4.parse)
            parser4 = parser4.parse;
          try {
            root2 = parser4(css, opts);
          } catch (error) {
            this.processed = true;
            this.error = error;
          }
          if (root2 && !root2[my]) {
            Container2.rebuild(root2);
          }
        }
        this.result = new Result2(processor, root2, opts);
        this.helpers = { ...postcss2, postcss: postcss2, result: this.result };
        this.plugins = this.processor.plugins.map((plugin2) => {
          if (typeof plugin2 === "object" && plugin2.prepare) {
            return { ...plugin2, ...plugin2.prepare(this.result) };
          } else {
            return plugin2;
          }
        });
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        if (this.processed)
          return Promise.resolve(this.result);
        if (!this.processing) {
          this.processing = this.runAsync();
        }
        return this.processing;
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(error, node) {
        let plugin2 = this.result.lastPlugin;
        try {
          if (node)
            node.addToError(error);
          this.error = error;
          if (error.name === "CssSyntaxError" && !error.plugin) {
            error.plugin = plugin2.postcssPlugin;
            error.setMessage();
          } else if (plugin2.postcssVersion) {
            if (import_process.default.env.NODE_ENV !== "production") {
              let pluginName = plugin2.postcssPlugin;
              let pluginVer = plugin2.postcssVersion;
              let runtimeVer = this.result.processor.version;
              let a3 = pluginVer.split(".");
              let b3 = runtimeVer.split(".");
              if (a3[0] !== b3[0] || parseInt(a3[1]) > parseInt(b3[1])) {
                console.error(
                  "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                );
              }
            }
          }
        } catch (err) {
          if (console && console.error)
            console.error(err);
        }
        return error;
      }
      prepareVisitors() {
        this.listeners = {};
        let add = (plugin2, type, cb) => {
          if (!this.listeners[type])
            this.listeners[type] = [];
          this.listeners[type].push([plugin2, cb]);
        };
        for (let plugin2 of this.plugins) {
          if (typeof plugin2 === "object") {
            for (let event in plugin2) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error(
                  `Unknown event ${event} in ${plugin2.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                );
              }
              if (!NOT_VISITORS[event]) {
                if (typeof plugin2[event] === "object") {
                  for (let filter2 in plugin2[event]) {
                    if (filter2 === "*") {
                      add(plugin2, event, plugin2[event][filter2]);
                    } else {
                      add(
                        plugin2,
                        event + "-" + filter2.toLowerCase(),
                        plugin2[event][filter2]
                      );
                    }
                  }
                } else if (typeof plugin2[event] === "function") {
                  add(plugin2, event, plugin2[event]);
                }
              }
            }
          }
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      async runAsync() {
        this.plugin = 0;
        for (let i5 = 0; i5 < this.plugins.length; i5++) {
          let plugin2 = this.plugins[i5];
          let promise = this.runOnRoot(plugin2);
          if (isPromise(promise)) {
            try {
              await promise;
            } catch (error) {
              throw this.handleError(error);
            }
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root2 = this.result.root;
          while (!root2[isClean]) {
            root2[isClean] = true;
            let stack = [toStack(root2)];
            while (stack.length > 0) {
              let promise = this.visitTick(stack);
              if (isPromise(promise)) {
                try {
                  await promise;
                } catch (e4) {
                  let node = stack[stack.length - 1].node;
                  throw this.handleError(e4, node);
                }
              }
            }
          }
          if (this.listeners.OnceExit) {
            for (let [plugin2, visitor] of this.listeners.OnceExit) {
              this.result.lastPlugin = plugin2;
              try {
                if (root2.type === "document") {
                  let roots = root2.nodes.map(
                    (subRoot) => visitor(subRoot, this.helpers)
                  );
                  await Promise.all(roots);
                } else {
                  await visitor(root2, this.helpers);
                }
              } catch (e4) {
                throw this.handleError(e4);
              }
            }
          }
        }
        this.processed = true;
        return this.stringify();
      }
      runOnRoot(plugin2) {
        this.result.lastPlugin = plugin2;
        try {
          if (typeof plugin2 === "object" && plugin2.Once) {
            if (this.result.root.type === "document") {
              let roots = this.result.root.nodes.map(
                (root2) => plugin2.Once(root2, this.helpers)
              );
              if (isPromise(roots[0])) {
                return Promise.all(roots);
              }
              return roots;
            }
            return plugin2.Once(this.result.root, this.helpers);
          } else if (typeof plugin2 === "function") {
            return plugin2(this.result.root, this.result);
          }
        } catch (error) {
          throw this.handleError(error);
        }
      }
      stringify() {
        if (this.error)
          throw this.error;
        if (this.stringified)
          return this.result;
        this.stringified = true;
        this.sync();
        let opts = this.result.opts;
        let str = stringify6;
        if (opts.syntax)
          str = opts.syntax.stringify;
        if (opts.stringifier)
          str = opts.stringifier;
        if (str.stringify)
          str = str.stringify;
        let map = new MapGenerator(str, this.result.root, this.result.opts);
        let data = map.generate();
        this.result.css = data[0];
        this.result.map = data[1];
        return this.result;
      }
      sync() {
        if (this.error)
          throw this.error;
        if (this.processed)
          return this.result;
        this.processed = true;
        if (this.processing) {
          throw this.getAsyncError();
        }
        for (let plugin2 of this.plugins) {
          let promise = this.runOnRoot(plugin2);
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root2 = this.result.root;
          while (!root2[isClean]) {
            root2[isClean] = true;
            this.walkSync(root2);
          }
          if (this.listeners.OnceExit) {
            if (root2.type === "document") {
              for (let subRoot of root2.nodes) {
                this.visitSync(this.listeners.OnceExit, subRoot);
              }
            } else {
              this.visitSync(this.listeners.OnceExit, root2);
            }
          }
        }
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (import_process.default.env.NODE_ENV !== "production") {
          if (!("from" in this.opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this.css;
      }
      visitSync(visitors, node) {
        for (let [plugin2, visitor] of visitors) {
          this.result.lastPlugin = plugin2;
          let promise;
          try {
            promise = visitor(node, this.helpers);
          } catch (e4) {
            throw this.handleError(e4, node.proxyOf);
          }
          if (node.type !== "root" && node.type !== "document" && !node.parent) {
            return true;
          }
          if (isPromise(promise)) {
            throw this.getAsyncError();
          }
        }
      }
      visitTick(stack) {
        let visit = stack[stack.length - 1];
        let { node, visitors } = visit;
        if (node.type !== "root" && node.type !== "document" && !node.parent) {
          stack.pop();
          return;
        }
        if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
          let [plugin2, visitor] = visitors[visit.visitorIndex];
          visit.visitorIndex += 1;
          if (visit.visitorIndex === visitors.length) {
            visit.visitors = [];
            visit.visitorIndex = 0;
          }
          this.result.lastPlugin = plugin2;
          try {
            return visitor(node.toProxy(), this.helpers);
          } catch (e4) {
            throw this.handleError(e4, node);
          }
        }
        if (visit.iterator !== 0) {
          let iterator = visit.iterator;
          let child;
          while (child = node.nodes[node.indexes[iterator]]) {
            node.indexes[iterator] += 1;
            if (!child[isClean]) {
              child[isClean] = true;
              stack.push(toStack(child));
              return;
            }
          }
          visit.iterator = 0;
          delete node.indexes[iterator];
        }
        let events = visit.events;
        while (visit.eventIndex < events.length) {
          let event = events[visit.eventIndex];
          visit.eventIndex += 1;
          if (event === CHILDREN) {
            if (node.nodes && node.nodes.length) {
              node[isClean] = true;
              visit.iterator = node.getIterator();
            }
            return;
          } else if (this.listeners[event]) {
            visit.visitors = this.listeners[event];
            return;
          }
        }
        stack.pop();
      }
      walkSync(node) {
        node[isClean] = true;
        let events = getEvents(node);
        for (let event of events) {
          if (event === CHILDREN) {
            if (node.nodes) {
              node.each((child) => {
                if (!child[isClean])
                  this.walkSync(child);
              });
            }
          } else {
            let visitors = this.listeners[event];
            if (visitors) {
              if (this.visitSync(visitors, node.toProxy()))
                return;
            }
          }
        }
      }
      warnings() {
        return this.sync().warnings();
      }
      get content() {
        return this.stringify().content;
      }
      get css() {
        return this.stringify().css;
      }
      get map() {
        return this.stringify().map;
      }
      get messages() {
        return this.sync().messages;
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        return this.sync().root;
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
    };
    LazyResult.registerPostcss = (dependant) => {
      postcss2 = dependant;
    };
    module.exports = LazyResult;
    LazyResult.default = LazyResult;
    Root2.registerLazyResult(LazyResult);
    Document2.registerLazyResult(LazyResult);
  }
});

// node_modules/postcss/lib/no-work-result.js
var require_no_work_result = __commonJS({
  "node_modules/postcss/lib/no-work-result.js"(exports, module) {
    "use strict";
    init_shim();
    var MapGenerator = require_map_generator();
    var stringify6 = require_stringify();
    var warnOnce = require_warn_once();
    var parse6 = require_parse();
    var Result2 = require_result();
    var NoWorkResult = class {
      constructor(processor, css, opts) {
        css = css.toString();
        this.stringified = false;
        this._processor = processor;
        this._css = css;
        this._opts = opts;
        this._map = void 0;
        let root2;
        let str = stringify6;
        this.result = new Result2(this._processor, root2, this._opts);
        this.result.css = css;
        let self2 = this;
        Object.defineProperty(this.result, "root", {
          get() {
            return self2.root;
          }
        });
        let map = new MapGenerator(str, root2, this._opts, css);
        if (map.isMap()) {
          let [generatedCSS, generatedMap] = map.generate();
          if (generatedCSS) {
            this.result.css = generatedCSS;
          }
          if (generatedMap) {
            this.result.map = generatedMap;
          }
        } else {
          map.clearAnnotation();
          this.result.css = map.css;
        }
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        return Promise.resolve(this.result);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      sync() {
        if (this.error)
          throw this.error;
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (import_process.default.env.NODE_ENV !== "production") {
          if (!("from" in this._opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this._css;
      }
      warnings() {
        return [];
      }
      get content() {
        return this.result.css;
      }
      get css() {
        return this.result.css;
      }
      get map() {
        return this.result.map;
      }
      get messages() {
        return [];
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        if (this._root) {
          return this._root;
        }
        let root2;
        let parser4 = parse6;
        try {
          root2 = parser4(this._css, this._opts);
        } catch (error) {
          this.error = error;
        }
        if (this.error) {
          throw this.error;
        } else {
          this._root = root2;
          return root2;
        }
      }
      get [Symbol.toStringTag]() {
        return "NoWorkResult";
      }
    };
    module.exports = NoWorkResult;
    NoWorkResult.default = NoWorkResult;
  }
});

// node_modules/postcss/lib/processor.js
var require_processor = __commonJS({
  "node_modules/postcss/lib/processor.js"(exports, module) {
    "use strict";
    init_shim();
    var NoWorkResult = require_no_work_result();
    var LazyResult = require_lazy_result();
    var Document2 = require_document();
    var Root2 = require_root();
    var Processor3 = class {
      constructor(plugins = []) {
        this.version = "8.4.35";
        this.plugins = this.normalize(plugins);
      }
      normalize(plugins) {
        let normalized = [];
        for (let i5 of plugins) {
          if (i5.postcss === true) {
            i5 = i5();
          } else if (i5.postcss) {
            i5 = i5.postcss;
          }
          if (typeof i5 === "object" && Array.isArray(i5.plugins)) {
            normalized = normalized.concat(i5.plugins);
          } else if (typeof i5 === "object" && i5.postcssPlugin) {
            normalized.push(i5);
          } else if (typeof i5 === "function") {
            normalized.push(i5);
          } else if (typeof i5 === "object" && (i5.parse || i5.stringify)) {
            if (import_process.default.env.NODE_ENV !== "production") {
              throw new Error(
                "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
              );
            }
          } else {
            throw new Error(i5 + " is not a PostCSS plugin");
          }
        }
        return normalized;
      }
      process(css, opts = {}) {
        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
          return new NoWorkResult(this, css, opts);
        } else {
          return new LazyResult(this, css, opts);
        }
      }
      use(plugin2) {
        this.plugins = this.plugins.concat(this.normalize([plugin2]));
        return this;
      }
    };
    module.exports = Processor3;
    Processor3.default = Processor3;
    Root2.registerProcessor(Processor3);
    Document2.registerProcessor(Processor3);
  }
});

// node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS({
  "node_modules/postcss/lib/fromJSON.js"(exports, module) {
    "use strict";
    init_shim();
    var Declaration2 = require_declaration();
    var PreviousMap = require_previous_map();
    var Comment2 = require_comment();
    var AtRule2 = require_at_rule();
    var Input2 = require_input();
    var Root2 = require_root();
    var Rule2 = require_rule();
    function fromJSON2(json, inputs) {
      if (Array.isArray(json))
        return json.map((n4) => fromJSON2(n4));
      let { inputs: ownInputs, ...defaults3 } = json;
      if (ownInputs) {
        inputs = [];
        for (let input of ownInputs) {
          let inputHydrated = { ...input, __proto__: Input2.prototype };
          if (inputHydrated.map) {
            inputHydrated.map = {
              ...inputHydrated.map,
              __proto__: PreviousMap.prototype
            };
          }
          inputs.push(inputHydrated);
        }
      }
      if (defaults3.nodes) {
        defaults3.nodes = json.nodes.map((n4) => fromJSON2(n4, inputs));
      }
      if (defaults3.source) {
        let { inputId, ...source } = defaults3.source;
        defaults3.source = source;
        if (inputId != null) {
          defaults3.source.input = inputs[inputId];
        }
      }
      if (defaults3.type === "root") {
        return new Root2(defaults3);
      } else if (defaults3.type === "decl") {
        return new Declaration2(defaults3);
      } else if (defaults3.type === "rule") {
        return new Rule2(defaults3);
      } else if (defaults3.type === "comment") {
        return new Comment2(defaults3);
      } else if (defaults3.type === "atrule") {
        return new AtRule2(defaults3);
      } else {
        throw new Error("Unknown node type: " + json.type);
      }
    }
    module.exports = fromJSON2;
    fromJSON2.default = fromJSON2;
  }
});

// node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS({
  "node_modules/postcss/lib/postcss.js"(exports, module) {
    "use strict";
    init_shim();
    var CssSyntaxError2 = require_css_syntax_error();
    var Declaration2 = require_declaration();
    var LazyResult = require_lazy_result();
    var Container2 = require_container();
    var Processor3 = require_processor();
    var stringify6 = require_stringify();
    var fromJSON2 = require_fromJSON();
    var Document2 = require_document();
    var Warning2 = require_warning();
    var Comment2 = require_comment();
    var AtRule2 = require_at_rule();
    var Result2 = require_result();
    var Input2 = require_input();
    var parse6 = require_parse();
    var list3 = require_list();
    var Rule2 = require_rule();
    var Root2 = require_root();
    var Node2 = require_node();
    function postcss2(...plugins) {
      if (plugins.length === 1 && Array.isArray(plugins[0])) {
        plugins = plugins[0];
      }
      return new Processor3(plugins);
    }
    postcss2.plugin = function plugin2(name, initializer) {
      let warningPrinted = false;
      function creator3(...args) {
        if (console && console.warn && !warningPrinted) {
          warningPrinted = true;
          console.warn(
            name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
          );
          if (import_process.default.env.LANG && import_process.default.env.LANG.startsWith("cn")) {
            console.warn(
              name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
            );
          }
        }
        let transformer = initializer(...args);
        transformer.postcssPlugin = name;
        transformer.postcssVersion = new Processor3().version;
        return transformer;
      }
      let cache2;
      Object.defineProperty(creator3, "postcss", {
        get() {
          if (!cache2)
            cache2 = creator3();
          return cache2;
        }
      });
      creator3.process = function(css, processOpts, pluginOpts) {
        return postcss2([creator3(pluginOpts)]).process(css, processOpts);
      };
      return creator3;
    };
    postcss2.stringify = stringify6;
    postcss2.parse = parse6;
    postcss2.fromJSON = fromJSON2;
    postcss2.list = list3;
    postcss2.comment = (defaults3) => new Comment2(defaults3);
    postcss2.atRule = (defaults3) => new AtRule2(defaults3);
    postcss2.decl = (defaults3) => new Declaration2(defaults3);
    postcss2.rule = (defaults3) => new Rule2(defaults3);
    postcss2.root = (defaults3) => new Root2(defaults3);
    postcss2.document = (defaults3) => new Document2(defaults3);
    postcss2.CssSyntaxError = CssSyntaxError2;
    postcss2.Declaration = Declaration2;
    postcss2.Container = Container2;
    postcss2.Processor = Processor3;
    postcss2.Document = Document2;
    postcss2.Comment = Comment2;
    postcss2.Warning = Warning2;
    postcss2.AtRule = AtRule2;
    postcss2.Result = Result2;
    postcss2.Input = Input2;
    postcss2.Rule = Rule2;
    postcss2.Root = Root2;
    postcss2.Node = Node2;
    LazyResult.registerPostcss(postcss2);
    module.exports = postcss2;
    postcss2.default = postcss2;
  }
});

// node_modules/postcss/lib/postcss.mjs
var postcss_exports = {};
__export(postcss_exports, {
  AtRule: () => AtRule,
  Comment: () => Comment,
  Container: () => Container,
  CssSyntaxError: () => CssSyntaxError,
  Declaration: () => Declaration,
  Document: () => Document,
  Input: () => Input,
  Node: () => Node,
  Processor: () => Processor,
  Result: () => Result,
  Root: () => Root,
  Rule: () => Rule,
  Warning: () => Warning,
  atRule: () => atRule,
  comment: () => comment,
  decl: () => decl,
  default: () => postcss_default,
  document: () => document,
  fromJSON: () => fromJSON,
  list: () => list,
  parse: () => parse4,
  plugin: () => plugin,
  root: () => root,
  rule: () => rule,
  stringify: () => stringify3
});
var import_postcss, postcss_default, stringify3, fromJSON, plugin, parse4, list, document, comment, atRule, rule, decl, root, CssSyntaxError, Declaration, Container, Processor, Document, Comment, Warning, AtRule, Result, Input, Rule, Root, Node;
var init_postcss = __esm({
  "node_modules/postcss/lib/postcss.mjs"() {
    "use strict";
    init_shim();
    import_postcss = __toESM(require_postcss(), 1);
    postcss_default = import_postcss.default;
    stringify3 = import_postcss.default.stringify;
    fromJSON = import_postcss.default.fromJSON;
    plugin = import_postcss.default.plugin;
    parse4 = import_postcss.default.parse;
    list = import_postcss.default.list;
    document = import_postcss.default.document;
    comment = import_postcss.default.comment;
    atRule = import_postcss.default.atRule;
    rule = import_postcss.default.rule;
    decl = import_postcss.default.decl;
    root = import_postcss.default.root;
    CssSyntaxError = import_postcss.default.CssSyntaxError;
    Declaration = import_postcss.default.Declaration;
    Container = import_postcss.default.Container;
    Processor = import_postcss.default.Processor;
    Document = import_postcss.default.Document;
    Comment = import_postcss.default.Comment;
    Warning = import_postcss.default.Warning;
    AtRule = import_postcss.default.AtRule;
    Result = import_postcss.default.Result;
    Input = import_postcss.default.Input;
    Rule = import_postcss.default.Rule;
    Root = import_postcss.default.Root;
    Node = import_postcss.default.Node;
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    init_shim();
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend() {
      var options, name, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i5 = 1;
      var length2 = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i5 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i5 < length2; ++i5) {
        options = arguments[i5];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/postcss-css-variables/lib/shallow-clone-node.js
var require_shallow_clone_node = __commonJS({
  "node_modules/postcss-css-variables/lib/shallow-clone-node.js"(exports, module) {
    "use strict";
    init_shim();
    var shallowCloneNode = function(obj, parent) {
      var cloned = new obj.constructor();
      Object.keys(obj).forEach(function(i5) {
        if (!obj.hasOwnProperty(i5)) {
          return;
        }
        var value2 = obj[i5];
        var type = typeof value2;
        if (i5 === "parent" && type === "object") {
          if (parent) {
            cloned[i5] = parent;
          }
        } else if (i5 === "source") {
          cloned[i5] = value2;
        } else if (value2 instanceof Array) {
          if (i5 === "nodes") {
            cloned[i5] = [];
          } else {
            cloned[i5] = value2.map(function(j2) {
              shallowCloneNode(j2, cloned);
            });
          }
        } else if (i5 !== "before" && i5 !== "after" && i5 !== "between" && i5 !== "semicolon") {
          if (type === "object") {
            value2 = shallowCloneNode(value2);
          }
          cloned[i5] = value2;
        }
      });
      return cloned;
    };
    module.exports = shallowCloneNode;
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = balanced;
    function balanced(a3, b3, str) {
      if (a3 instanceof RegExp)
        a3 = maybeMatch(a3, str);
      if (b3 instanceof RegExp)
        b3 = maybeMatch(b3, str);
      var r5 = range(a3, b3, str);
      return r5 && {
        start: r5[0],
        end: r5[1],
        pre: str.slice(0, r5[0]),
        body: str.slice(r5[0] + a3.length, r5[1]),
        post: str.slice(r5[1] + b3.length)
      };
    }
    function maybeMatch(reg, str) {
      var m2 = str.match(reg);
      return m2 ? m2[0] : null;
    }
    balanced.range = range;
    function range(a3, b3, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a3);
      var bi = str.indexOf(b3, ai + 1);
      var i5 = ai;
      if (ai >= 0 && bi > 0) {
        if (a3 === b3) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i5 >= 0 && !result) {
          if (i5 == ai) {
            begs.push(i5);
            ai = str.indexOf(a3, i5 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b3, i5 + 1);
          }
          i5 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/postcss-css-variables/lib/generate-descendant-pieces-from-selector.js
var require_generate_descendant_pieces_from_selector = __commonJS({
  "node_modules/postcss-css-variables/lib/generate-descendant-pieces-from-selector.js"(exports, module) {
    "use strict";
    init_shim();
    var RE_SELECTOR_DESCENDANT_SPLIT = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/;
    var generateDescendantPiecesFromSelector = function(selector) {
      return selector.split(RE_SELECTOR_DESCENDANT_SPLIT).filter(function(piece) {
        if (piece.length > 0) {
          return true;
        }
        return false;
      }).map(function(piece) {
        return piece.trim().replace(/\s*?>>\s*?/g, "");
      });
    };
    module.exports = generateDescendantPiecesFromSelector;
  }
});

// node_modules/postcss-css-variables/lib/generate-scope-list.js
var require_generate_scope_list = __commonJS({
  "node_modules/postcss-css-variables/lib/generate-scope-list.js"(exports, module) {
    "use strict";
    init_shim();
    var generateDescendantPiecesFromSelector = require_generate_descendant_pieces_from_selector();
    var generateScopeList = function(node, includeSelf) {
      includeSelf = includeSelf || false;
      var selectorScopeList = [
        // Start off with one branch
        []
      ];
      var currentNodeParent = includeSelf ? node : node.parent;
      while (currentNodeParent) {
        var scopePieces = (currentNodeParent.selectors || []).map(function(selectorPiece) {
          return {
            value: selectorPiece,
            type: "selector"
          };
        });
        if (currentNodeParent.type === "atrule") {
          scopePieces = [].concat(currentNodeParent.params).map(function(param) {
            return {
              value: "@" + currentNodeParent.name + " " + param,
              type: "atrule"
            };
          });
        }
        var branches = (scopePieces.length > 0 ? scopePieces : [1]).map(function() {
          return selectorScopeList.map(function(scopePieces2) {
            return scopePieces2.slice(0);
          });
        });
        scopePieces.forEach(function(scopeObject, index2) {
          branches[index2] = branches[index2].map(function(scopeStringPieces) {
            var descendantPieces = [scopeObject.value];
            if (scopeObject.type === "selector") {
              descendantPieces = generateDescendantPiecesFromSelector(scopeObject.value);
            }
            scopeStringPieces.unshift.apply(scopeStringPieces, descendantPieces);
            return scopeStringPieces;
          });
        });
        selectorScopeList = [];
        branches.forEach(function(branch) {
          selectorScopeList = selectorScopeList.concat(branch);
        });
        currentNodeParent = currentNodeParent.parent;
      }
      return selectorScopeList;
    };
    module.exports = generateScopeList;
  }
});

// node_modules/postcss-css-variables/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/postcss-css-variables/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    init_shim();
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/postcss-css-variables/lib/is-piece-always-ancestor-selector.js
var require_is_piece_always_ancestor_selector = __commonJS({
  "node_modules/postcss-css-variables/lib/is-piece-always-ancestor-selector.js"(exports, module) {
    "use strict";
    init_shim();
    var alwaysAncestorSelector = {
      "*": true,
      ":root": true,
      "html": true
    };
    var isPieceIsAlwaysAncestorSelector = function(piece) {
      return !!alwaysAncestorSelector[piece];
    };
    module.exports = isPieceIsAlwaysAncestorSelector;
  }
});

// node_modules/postcss-css-variables/lib/generate-direct-descendant-pieces-from-selector.js
var require_generate_direct_descendant_pieces_from_selector = __commonJS({
  "node_modules/postcss-css-variables/lib/generate-direct-descendant-pieces-from-selector.js"(exports, module) {
    "use strict";
    init_shim();
    var RE_SELECTOR_DIRECT_DESCENDANT_SPLIT = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/;
    var generateDirectDescendantPiecesFromSelector = function(selector) {
      return selector.split(RE_SELECTOR_DIRECT_DESCENDANT_SPLIT).filter(function(piece) {
        if (piece.length > 0) {
          return true;
        }
        return false;
      }).map(function(piece) {
        return piece.trim().replace(/\s*?>\s*?/g, "");
      });
    };
    module.exports = generateDirectDescendantPiecesFromSelector;
  }
});

// node_modules/postcss-css-variables/lib/is-under-scope.js
var require_is_under_scope = __commonJS({
  "node_modules/postcss-css-variables/lib/is-under-scope.js"(exports, module) {
    "use strict";
    init_shim();
    var escapeStringRegexp = require_escape_string_regexp();
    var isPieceAlwaysAncestorSelector = require_is_piece_always_ancestor_selector();
    var generateDirectDescendantPiecesFromSelector = require_generate_direct_descendant_pieces_from_selector();
    var RE_AT_RULE_SCOPE_PIECE = /^@.*/;
    var RE_PSEUDO_SELECTOR = /([^\s:]+)((?::|::)[^\s]*?)(\s+|$)/;
    function getScopeMatchResults(nodeScopeList, scopeNodeScopeList) {
      var currentPieceOffset;
      var scopePieceIndex;
      var doesMatchScope = scopeNodeScopeList.some(function(scopeNodeScopePieces) {
        return nodeScopeList.some(function(nodeScopePieces) {
          currentPieceOffset = null;
          var wasEveryPieceFound = true;
          for (scopePieceIndex = 0; scopePieceIndex < scopeNodeScopePieces.length; scopePieceIndex++) {
            var scopePiece = scopeNodeScopePieces[scopePieceIndex];
            var pieceOffset = currentPieceOffset || 0;
            var foundIndex = -1;
            var piecesWeCanMatch = nodeScopePieces.slice(pieceOffset);
            for (var nodeScopePieceIndex = 0; nodeScopePieceIndex < piecesWeCanMatch.length; nodeScopePieceIndex++) {
              var nodeScopePiece = piecesWeCanMatch[nodeScopePieceIndex];
              var overallIndex = pieceOffset + nodeScopePieceIndex;
              if (
                // If the part on the end of the piece itself matches:
                //		scopePiece `.bar` matches node `.bar`
                //		scopePiece `.bar` matches node `.foo + .bar`
                new RegExp(escapeStringRegexp(scopePiece) + "$").test(nodeScopePiece)
              ) {
                foundIndex = overallIndex;
                break;
              }
              if (isPieceAlwaysAncestorSelector(scopePiece) || isPieceAlwaysAncestorSelector(nodeScopePiece)) {
                foundIndex = overallIndex;
                break;
              }
              var directDescendantPieces = generateDirectDescendantPiecesFromSelector(nodeScopePiece);
              if (directDescendantPieces.length > 1) {
                var ddNodeScopeList = [].concat([directDescendantPieces]);
                var ddScopeList = [].concat([
                  scopeNodeScopePieces.slice(scopePieceIndex).reduce(function(prevScopePieces, scopePiece2) {
                    return prevScopePieces.concat(generateDirectDescendantPiecesFromSelector(scopePiece2));
                  }, [])
                ]);
                var result = getScopeMatchResults(ddNodeScopeList, ddScopeList);
                if (result.doesMatchScope || scopePieceIndex + 1 < scopeNodeScopePieces.length) {
                  foundIndex = overallIndex;
                  scopePieceIndex += result.scopePieceIndex - 1;
                }
                break;
              }
            }
            var isFurther = foundIndex >= pieceOffset;
            currentPieceOffset = foundIndex + 1;
            wasEveryPieceFound = wasEveryPieceFound && isFurther;
            if (!wasEveryPieceFound) {
              break;
            }
          }
          return wasEveryPieceFound;
        });
      });
      return {
        doesMatchScope,
        nodeScopePieceIndex: currentPieceOffset - 1,
        scopePieceIndex
      };
    }
    var stripPseudoSelectorsFromScopeList = function(scopeList) {
      return scopeList.map(function(scopePieces) {
        return scopePieces.map(function(descendantPiece) {
          if (!RE_AT_RULE_SCOPE_PIECE.test(descendantPiece)) {
            return descendantPiece.replace(new RegExp(RE_PSEUDO_SELECTOR.source, "g"), function(whole, baseSelector, pseudo, trailingWhitespace) {
              return baseSelector + trailingWhitespace;
            });
          }
          return descendantPiece;
        });
      });
    };
    var isUnderScope = function(nodeScopeList, scopeNodeScopeList, ignorePseudo) {
      nodeScopeList = stripPseudoSelectorsFromScopeList(nodeScopeList);
      if (ignorePseudo) {
        scopeNodeScopeList = stripPseudoSelectorsFromScopeList(scopeNodeScopeList);
      }
      return getScopeMatchResults(nodeScopeList, scopeNodeScopeList).doesMatchScope;
    };
    isUnderScope.RE_PSEUDO_SELECTOR = RE_PSEUDO_SELECTOR;
    module.exports = isUnderScope;
  }
});

// node_modules/postcss-css-variables/lib/is-node-under-scope.js
var require_is_node_under_scope = __commonJS({
  "node_modules/postcss-css-variables/lib/is-node-under-scope.js"(exports, module) {
    "use strict";
    init_shim();
    var isUnderScope = require_is_under_scope();
    var generateScopeList = require_generate_scope_list();
    var isNodeUnderScope = function(node, scopeNode, ignorePseudo) {
      var nodeScopeList = generateScopeList(node, true);
      var scopeNodeScopeList = generateScopeList(scopeNode, true);
      return isUnderScope(nodeScopeList, scopeNodeScopeList, ignorePseudo);
    };
    module.exports = isNodeUnderScope;
  }
});

// node_modules/postcss-css-variables/lib/gather-variable-dependencies.js
var require_gather_variable_dependencies = __commonJS({
  "node_modules/postcss-css-variables/lib/gather-variable-dependencies.js"(exports, module) {
    "use strict";
    init_shim();
    var gatherVariableDependencies = function(variablesUsed, map, _dependencyVariablesList) {
      _dependencyVariablesList = _dependencyVariablesList || [];
      var hasCircularOrSelfReference = false;
      if (variablesUsed) {
        _dependencyVariablesList = variablesUsed.reduce(function(dependencyVariablesList, variableUsedName) {
          var isVariableInMap = !!map[variableUsedName];
          var doesThisVarHaveCircularOrSelfReference = !isVariableInMap ? false : dependencyVariablesList.some(function(dep) {
            return map[variableUsedName].some(function(mapItem) {
              if (dep === mapItem) {
                return true;
              }
              return false;
            });
          });
          hasCircularOrSelfReference = hasCircularOrSelfReference || doesThisVarHaveCircularOrSelfReference;
          if (isVariableInMap && !hasCircularOrSelfReference) {
            dependencyVariablesList = dependencyVariablesList.concat(map[variableUsedName]);
            (map[variableUsedName] || []).forEach(function(mapItem) {
              var result = gatherVariableDependencies(mapItem.variablesUsed, map, dependencyVariablesList);
              dependencyVariablesList = result.deps;
              hasCircularOrSelfReference = hasCircularOrSelfReference || result.hasCircularOrSelfReference;
            });
          }
          return dependencyVariablesList;
        }, _dependencyVariablesList);
      }
      return {
        deps: _dependencyVariablesList,
        hasCircularOrSelfReference
      };
    };
    module.exports = gatherVariableDependencies;
  }
});

// node_modules/postcss-css-variables/lib/find-node-ancestor-with-selector.js
var require_find_node_ancestor_with_selector = __commonJS({
  "node_modules/postcss-css-variables/lib/find-node-ancestor-with-selector.js"(exports, module) {
    "use strict";
    init_shim();
    var generateScopeList = require_generate_scope_list();
    var findNodeAncestorWithSelector = function(selector, node) {
      var matchingNode;
      var currentNode = node;
      while (currentNode.parent && !matchingNode) {
        var currentNodeScopeList = generateScopeList(currentNode.clone(), true);
        currentNodeScopeList.some(function(scopePieces) {
          return scopePieces.some(function(scopePiece) {
            if (scopePiece === selector) {
              matchingNode = currentNode;
              return true;
            }
            return false;
          });
        });
        currentNode = currentNode.parent;
      }
      return matchingNode;
    };
    module.exports = findNodeAncestorWithSelector;
  }
});

// node_modules/postcss-css-variables/lib/clone-splice-parent-onto-node-when.js
var require_clone_splice_parent_onto_node_when = __commonJS({
  "node_modules/postcss-css-variables/lib/clone-splice-parent-onto-node-when.js"(exports, module) {
    "use strict";
    init_shim();
    var shallowCloneNode = require_shallow_clone_node();
    var cloneSpliceParentOntoNodeWhen = function(node, parent, whenCb) {
      whenCb = whenCb || function() {
        return true;
      };
      var cloneList = [];
      var current = node;
      var isWhenNow = false;
      while (current && !isWhenNow) {
        if (current.type === "decl") {
          cloneList.push(current.clone());
        } else {
          cloneList.push(shallowCloneNode(current));
        }
        isWhenNow = whenCb(current);
        current = current.parent;
      }
      var cloneParentList = [];
      var currentParent = parent;
      while (currentParent) {
        cloneParentList.push(shallowCloneNode(currentParent));
        currentParent = currentParent.parent;
      }
      cloneParentList.forEach(function(parentClone, index2, cloneParentList2) {
        if (index2 + 1 < cloneParentList2.length) {
          parentClone.parent = cloneParentList2[index2 + 1];
        }
      });
      cloneList.forEach(function(clone, index2, cloneList2) {
        if (index2 + 1 < cloneList2.length) {
          clone.parent = cloneList2[index2 + 1];
        } else {
          cloneParentList.slice(-1)[0].parent = current;
          clone.parent = cloneParentList[0];
        }
      });
      return cloneList[0];
    };
    module.exports = cloneSpliceParentOntoNodeWhen;
  }
});

// node_modules/postcss-css-variables/lib/resolve-value.js
var require_resolve_value = __commonJS({
  "node_modules/postcss-css-variables/lib/resolve-value.js"(exports, module) {
    "use strict";
    init_shim();
    var balanced = require_balanced_match();
    var generateScopeList = require_generate_scope_list();
    var isNodeUnderScope = require_is_node_under_scope();
    var gatherVariableDependencies = require_gather_variable_dependencies();
    var findNodeAncestorWithSelector = require_find_node_ancestor_with_selector();
    var cloneSpliceParentOntoNodeWhen = require_clone_splice_parent_onto_node_when();
    var RE_VAR_FUNC = /var\(\s*(--[^,\s)]+)/;
    function toString(value2) {
      return String(value2);
    }
    function balancedVar(value2) {
      var match = balanced("(", ")", value2);
      if (match) {
        if (/(?:^|[^\w-])var$/.test(match.pre)) {
          return {
            pre: match.pre.slice(0, -3),
            body: match.body,
            post: match.post
          };
        } else {
          var bodyMatch = balancedVar(match.body);
          if (bodyMatch) {
            return {
              pre: match.pre + "(" + bodyMatch.pre,
              body: bodyMatch.body,
              post: bodyMatch.post + ")" + match.post
            };
          } else {
            var postMatch = balancedVar(match.post);
            if (postMatch) {
              return {
                pre: match.pre + "(" + match.body + ")" + postMatch.pre,
                body: postMatch.body,
                post: postMatch.post
              };
            }
          }
        }
      }
    }
    var resolveValue2 = function(decl2, map, ignorePseudoScope, _debugIsInternal) {
      var debugIndent = _debugIsInternal ? "	" : "";
      var matchingVarDecl = void 0;
      var resultantValue = toString(decl2.value);
      var warnings = [];
      var variablesUsedInValueMap = {};
      var remainingVariableValue = resultantValue;
      while (matchingVarDecl = balancedVar(remainingVariableValue)) {
        var variableFallbackSplitPieces = matchingVarDecl.body.split(",");
        var variableName = variableFallbackSplitPieces[0].trim();
        variablesUsedInValueMap[variableName] = true;
        remainingVariableValue = (matchingVarDecl.pre || "") + matchingVarDecl.body.replace(variableName, "") + (matchingVarDecl.post || "");
      }
      remainingVariableValue = void 0;
      var variablesUsedInValue = Object.keys(variablesUsedInValueMap);
      var isResultantValueUndefined = false;
      while (matchingVarDecl = balancedVar(resultantValue)) {
        var matchingVarDeclMapItem = void 0;
        var variableFallbackSplitPieces = matchingVarDecl.body.split(",");
        var variableName = variableFallbackSplitPieces[0].trim();
        var fallback = variableFallbackSplitPieces.length > 1 ? variableFallbackSplitPieces.slice(1).join(",").trim() : void 0;
        (map[variableName] || []).forEach(function(varDeclMapItem) {
          var isRoot2 = varDeclMapItem.parent.type === "root" || varDeclMapItem.parent.selectors[0] === ":root";
          var underScope = isNodeUnderScope(decl2.parent, varDeclMapItem.parent);
          var underScsopeIgnorePseudo = isNodeUnderScope(decl2.parent, varDeclMapItem.parent, ignorePseudoScope);
          if (underScsopeIgnorePseudo && // And if the currently matched declaration is `!important`, it will take another `!important` to override it
          (!(matchingVarDeclMapItem || {}).isImportant || varDeclMapItem.isImportant)) {
            matchingVarDeclMapItem = varDeclMapItem;
          }
        });
        var replaceValue = (matchingVarDeclMapItem || {}).calculatedInPlaceValue || function() {
          var fallbackValue = fallback;
          if (fallback) {
            var fallbackDecl = decl2.clone({ parent: decl2.parent, value: fallback });
            fallbackValue = resolveValue2(
              fallbackDecl,
              map,
              false,
              /*internal*/
              true
            ).value;
          }
          return fallbackValue;
        }();
        if (matchingVarDeclMapItem !== void 0 && !gatherVariableDependencies(variablesUsedInValue, map).hasCircularOrSelfReference) {
          var varDeclScopeList = generateScopeList(decl2.parent.parent, true);
          var innerMostAtRuleSelector = varDeclScopeList[0].slice(-1)[0];
          var nodeToSpliceParentOnto = findNodeAncestorWithSelector(innerMostAtRuleSelector, matchingVarDeclMapItem.decl.parent);
          var matchingMimicDecl = cloneSpliceParentOntoNodeWhen(matchingVarDeclMapItem.decl, decl2.parent.parent, function(ancestor) {
            return ancestor === nodeToSpliceParentOnto;
          });
          replaceValue = resolveValue2(
            matchingMimicDecl,
            map,
            false,
            /*internal*/
            true
          ).value;
        }
        isResultantValueUndefined = replaceValue === void 0;
        if (isResultantValueUndefined) {
          warnings.push(["variable " + variableName + " is undefined and used without a fallback", { node: decl2 }]);
        }
        resultantValue = (matchingVarDecl.pre || "") + replaceValue + (matchingVarDecl.post || "");
      }
      return {
        // The resolved value
        value: !isResultantValueUndefined ? resultantValue : void 0,
        // Array of variable names used in resolving this value
        variablesUsed: variablesUsedInValue,
        // Any warnings generated from parsing this value
        warnings
      };
    };
    resolveValue2.RE_VAR_FUNC = RE_VAR_FUNC;
    module.exports = resolveValue2;
  }
});

// node_modules/postcss-css-variables/lib/resolve-decl.js
var require_resolve_decl = __commonJS({
  "node_modules/postcss-css-variables/lib/resolve-decl.js"(exports, module) {
    "use strict";
    init_shim();
    var resolveValue2 = require_resolve_value();
    var generateScopeList = require_generate_scope_list();
    var gatherVariableDependencies = require_gather_variable_dependencies();
    var isUnderScope = require_is_under_scope();
    var isNodeUnderScope = require_is_node_under_scope();
    var shallowCloneNode = require_shallow_clone_node();
    var findNodeAncestorWithSelector = require_find_node_ancestor_with_selector();
    var cloneSpliceParentOntoNodeWhen = require_clone_splice_parent_onto_node_when();
    function eachMapItemDependencyOfDecl(variablesUsedList, map, decl2, cb) {
      variablesUsedList.forEach(function(variableUsedName) {
        gatherVariableDependencies(variablesUsedList, map).deps.forEach(function(mapItem) {
          var mimicDecl;
          if (mapItem.isUnderAtRule) {
            var varDeclScopeList = generateScopeList(mapItem.parent, true);
            var innerMostAtRuleSelector = varDeclScopeList[0].slice(-1)[0];
            var nodeToSpliceParentOnto = findNodeAncestorWithSelector(innerMostAtRuleSelector, decl2.parent);
            var varDeclAtRule = mapItem.parent.parent;
            mimicDecl = cloneSpliceParentOntoNodeWhen(decl2, varDeclAtRule, function(ancestor) {
              return ancestor === nodeToSpliceParentOnto;
            });
          } else if (isUnderScope.RE_PSEUDO_SELECTOR.test(mapItem.parent.selector)) {
            var ruleClone = shallowCloneNode(decl2.parent);
            ruleClone.parent = decl2.parent.parent;
            mimicDecl = decl2.clone();
            ruleClone.append(mimicDecl);
            var lastPseudoSelectorMatches = mapItem.parent.selector.match(new RegExp(isUnderScope.RE_PSEUDO_SELECTOR.source + "$"));
            var lastPseudoSelector = lastPseudoSelectorMatches ? lastPseudoSelectorMatches[2] : "";
            ruleClone.selector += lastPseudoSelector;
          }
          if (mimicDecl && isNodeUnderScope(mimicDecl, mapItem.parent, true)) {
            cb(mimicDecl, mapItem);
          }
        });
      });
    }
    function resolveDecl(decl2, map, shouldPreserve, preserveAtRulesOrder, logResolveValueResult) {
      shouldPreserve = (typeof shouldPreserve === "function" ? shouldPreserve(decl2) : shouldPreserve) || false;
      preserveAtRulesOrder = preserveAtRulesOrder || false;
      var _logResolveValueResult = function(valueResults2) {
        if (logResolveValueResult) {
          logResolveValueResult(valueResults2);
        }
        return valueResults2;
      };
      var valueResults = _logResolveValueResult(resolveValue2(decl2, map));
      var previousAtRuleNode;
      eachMapItemDependencyOfDecl(valueResults.variablesUsed, map, decl2, function(mimicDecl, mapItem) {
        var ruleClone = shallowCloneNode(decl2.parent);
        var declClone = decl2.clone();
        ruleClone.append(declClone);
        let preserveVariable;
        if (typeof shouldPreserve === "function") {
          preserveVariable = shouldPreserve(decl2);
        } else {
          preserveVariable = shouldPreserve;
        }
        if (preserveVariable === true) {
          declClone.cloneAfter();
        }
        declClone.value = _logResolveValueResult(resolveValue2(mimicDecl, map, true)).value;
        if (mapItem.isUnderAtRule) {
          var atRuleNode = shallowCloneNode(mapItem.parent.parent);
          atRuleNode.append(ruleClone);
          var parentAtRuleNode = atRuleNode;
          var currentAtRuleNode = mapItem.parent.parent;
          while (currentAtRuleNode.parent.type === "atrule") {
            var newParentAtRuleNode = shallowCloneNode(currentAtRuleNode.parent);
            newParentAtRuleNode.append(parentAtRuleNode);
            parentAtRuleNode = newParentAtRuleNode;
            currentAtRuleNode = currentAtRuleNode.parent;
          }
          decl2.parent.parent.insertAfter(preserveAtRulesOrder && previousAtRuleNode || decl2.parent, parentAtRuleNode);
          previousAtRuleNode = parentAtRuleNode;
        } else {
          ruleClone.selector = mimicDecl.parent.selector;
          decl2.parent.parent.insertAfter(preserveAtRulesOrder && previousAtRuleNode || decl2.parent, ruleClone);
        }
      });
      if (shouldPreserve === true && decl2.value !== valueResults.value) {
        decl2.cloneAfter();
      }
      if (valueResults.value === void 0) {
        valueResults.value = "undefined";
      }
      decl2.value = valueResults.value;
    }
    module.exports = resolveDecl;
  }
});

// node_modules/postcss-css-variables/index.js
var require_postcss_css_variables = __commonJS({
  "node_modules/postcss-css-variables/index.js"(exports, module) {
    "use strict";
    init_shim();
    var extend = require_extend();
    var shallowCloneNode = require_shallow_clone_node();
    var resolveValue2 = require_resolve_value();
    var resolveDecl = require_resolve_decl();
    var RE_VAR_PROP = /(--(.+))/;
    function eachCssVariableDeclaration(css, cb) {
      css.walkDecls(function(decl2) {
        if (RE_VAR_PROP.test(decl2.prop)) {
          cb(decl2);
        }
      });
    }
    function cleanUpNode(node) {
      var nodeToPossiblyCleanUp = node;
      while (nodeToPossiblyCleanUp && nodeToPossiblyCleanUp.nodes.length <= 0) {
        var nodeToRemove = nodeToPossiblyCleanUp.type !== "root" ? nodeToPossiblyCleanUp : null;
        if (nodeToRemove) {
          nodeToPossiblyCleanUp = nodeToRemove.parent;
          nodeToRemove.remove();
        } else {
          nodeToPossiblyCleanUp = null;
        }
      }
    }
    var defaults3 = {
      // Allows you to preserve custom properties & var() usage in output.
      // `true`, `false`, or `'computed'`
      preserve: false,
      // Define variables via JS
      // Simple key-value pair
      // or an object with a `value` property and an optional `isImportant` bool property
      variables: {},
      // Preserve variables injected via JS with the `variables` option above
      // before serializing to CSS (`false` will remove these variables from output)
      preserveInjectedVariables: true,
      // Will write media queries in the same order as in the original file.
      // Currently defaulted to false for legacy behavior. We can update to `true` in a major version
      preserveAtRulesOrder: false
    };
    module.exports = (options = {}) => {
      var opts = extend({}, defaults3, options);
      return {
        postcssPlugin: "postcss-css-variables",
        Once(css, { decl: decl2, result, rule: rule2 }) {
          var nodesToRemoveAtEnd = [];
          var injectedDeclsToRemoveAtEnd = [];
          var map = {};
          map = extend(
            map,
            Object.keys(opts.variables).reduce(
              function(prevVariableMap, variableName) {
                var variableEntry = opts.variables[variableName];
                variableName = variableName.slice(0, 2) === "--" ? variableName : "--" + variableName;
                var variableValue = (variableEntry || {}).value || variableEntry;
                var isImportant = (variableEntry || {}).isImportant || false;
                var variableRootRule = rule2({ selector: ":root" });
                css.root().prepend(variableRootRule);
                var varDecl = decl2({
                  prop: variableName,
                  value: variableValue,
                  important: isImportant
                });
                variableRootRule.append(varDecl);
                if (!opts.preserveInjectedVariables) {
                  injectedDeclsToRemoveAtEnd.push(varDecl);
                }
                prevVariableMap[variableName] = (prevVariableMap[variableName] || []).concat({
                  decl: varDecl,
                  prop: variableName,
                  calculatedInPlaceValue: variableValue,
                  isImportant,
                  variablesUsed: [],
                  parent: variableRootRule,
                  isUnderAtRule: false
                });
                return prevVariableMap;
              },
              {}
            )
          );
          var logResolveValueResult = function(valueResult) {
            var warningList = [].concat(valueResult.warnings);
            warningList.forEach(function(warningArgs) {
              warningArgs = [].concat(warningArgs);
              result.warn.apply(result, warningArgs);
            });
            return valueResult;
          };
          eachCssVariableDeclaration(css, function(decl3) {
            var declParentRule = decl3.parent;
            var valueResults = logResolveValueResult(resolveValue2(decl3, map));
            decl3.parent.selectors.forEach(function(selector) {
              var splitOutRule = shallowCloneNode(decl3.parent);
              splitOutRule.selector = selector;
              splitOutRule.parent = decl3.parent.parent;
              var declClone = decl3.clone();
              splitOutRule.append(declClone);
              var prop = decl3.prop;
              map[prop] = (map[prop] || []).concat({
                decl: declClone,
                prop,
                calculatedInPlaceValue: valueResults.value,
                isImportant: decl3.important || false,
                variablesUsed: valueResults.variablesUsed,
                parent: splitOutRule,
                // variables inside root or at-rules (eg. @media, @support)
                isUnderAtRule: splitOutRule.parent.type === "atrule"
              });
            });
            let preserveDecl;
            if (typeof opts.preserve === "function") {
              preserveDecl = opts.preserve(decl3);
            } else {
              preserveDecl = opts.preserve;
            }
            if (!preserveDecl) {
              decl3.remove();
            } else if (preserveDecl === "computed") {
              decl3.value = valueResults.value;
            }
            if (declParentRule.nodes.length <= 0) {
              nodesToRemoveAtEnd.push(declParentRule);
            }
          });
          var rulesThatHaveDeclarationsWithVariablesList = [];
          css.walk(function(rule3) {
            if (rule3.nodes === void 0)
              return;
            var doesRuleUseVariables = rule3.nodes.some(function(node) {
              if (node.type === "decl") {
                var decl3 = node;
                if (resolveValue2.RE_VAR_FUNC.test(decl3.value) && !RE_VAR_PROP.test(decl3.prop)) {
                  return true;
                }
              }
              return false;
            });
            if (doesRuleUseVariables) {
              if (rule3.type === "rule" && rule3.selectors.length > 1) {
                rule3.selectors.reverse().forEach(function(selector) {
                  var ruleClone = rule3.cloneAfter();
                  ruleClone.selector = selector;
                  return ruleClone;
                });
                rule3.remove();
              } else {
                rulesThatHaveDeclarationsWithVariablesList.push(rule3);
              }
            }
          });
          rulesThatHaveDeclarationsWithVariablesList.forEach(function(rule3) {
            rule3.nodes.slice(0).forEach(function(node) {
              if (node.type === "decl") {
                var decl3 = node;
                resolveDecl(
                  decl3,
                  map,
                  opts.preserve,
                  opts.preserveAtRulesOrder,
                  logResolveValueResult
                );
              }
            });
          });
          nodesToRemoveAtEnd.forEach(cleanUpNode);
          injectedDeclsToRemoveAtEnd.forEach(function(injectedDecl) {
            injectedDecl.remove();
          });
        }
      };
    };
    module.exports.postcss = true;
  }
});

// node_modules/postcss-value-parser/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/postcss-value-parser/lib/parse.js"(exports, module) {
    "use strict";
    init_shim();
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote = '"'.charCodeAt(0);
    var backslash = "\\".charCodeAt(0);
    var slash = "/".charCodeAt(0);
    var comma = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    module.exports = function(input) {
      var tokens = [];
      var value2 = input;
      var next, quote, prev, token, escape3, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value2.charCodeAt(pos);
      var max3 = value2.length;
      var stack = [{ nodes: tokens }];
      var balanced = 0;
      var parent;
      var name = "";
      var before = "";
      var after = "";
      while (pos < max3) {
        if (code <= 32) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          token = value2.slice(pos, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
            prev.sourceEndIndex += token.length;
          } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        } else if (code === singleQuote || code === doubleQuote) {
          next = pos;
          quote = code === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote
          };
          do {
            escape3 = false;
            next = value2.indexOf(quote, next + 1);
            if (~next) {
              escapePos = next;
              while (value2.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape3 = !escape3;
              }
            } else {
              value2 += quote;
              next = value2.length - 1;
              token.unclosed = true;
            }
          } while (escape3);
          token.value = value2.slice(pos + 1, next);
          token.sourceEndIndex = token.unclosed ? next : next + 1;
          tokens.push(token);
          pos = next + 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
          next = value2.indexOf("*/", pos);
          token = {
            type: "comment",
            sourceIndex: pos,
            sourceEndIndex: next + 2
          };
          if (next === -1) {
            token.unclosed = true;
            next = value2.length;
            token.sourceEndIndex = next;
          }
          token.value = value2.slice(pos + 2, next);
          tokens.push(token);
          pos = next + 2;
          code = value2.charCodeAt(pos);
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
          token = value2[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token
          });
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash || code === comma || code === colon) {
          token = value2[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (openParentheses === code) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name.length,
            value: name,
            before: value2.slice(parenthesesOpenPos + 1, next)
          };
          pos = next;
          if (name === "url" && code !== singleQuote && code !== doubleQuote) {
            next -= 1;
            do {
              escape3 = false;
              next = value2.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape3 = !escape3;
                }
              } else {
                value2 += ")";
                next = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape3);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value2.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value2.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next,
                  value: value2.slice(whitespacePos + 1, next)
                });
              } else {
                token.after = value2.slice(whitespacePos + 1, next);
                token.sourceEndIndex = next;
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next + 1;
            token.sourceEndIndex = token.unclosed ? next : pos;
            code = value2.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced += 1;
            token.after = "";
            token.sourceEndIndex = pos + 1;
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name = "";
        } else if (closeParentheses === code && balanced) {
          pos += 1;
          code = value2.charCodeAt(pos);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced -= 1;
          stack[stack.length - 1].sourceEndIndex = pos;
          stack.pop();
          parent = stack[balanced];
          tokens = parent.nodes;
        } else {
          next = pos;
          do {
            if (code === backslash) {
              next += 1;
            }
            next += 1;
            code = value2.charCodeAt(next);
          } while (next < max3 && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
          token = value2.slice(pos, next);
          if (openParentheses === code) {
            name = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value2.length;
      }
      return stack[0].nodes;
    };
  }
});

// node_modules/postcss-value-parser/lib/walk.js
var require_walk = __commonJS({
  "node_modules/postcss-value-parser/lib/walk.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function walk2(nodes, cb, bubble) {
      var i5, max3, node, result;
      for (i5 = 0, max3 = nodes.length; i5 < max3; i5 += 1) {
        node = nodes[i5];
        if (!bubble) {
          result = cb(node, i5, nodes);
        }
        if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
          walk2(node.nodes, cb, bubble);
        }
        if (bubble) {
          cb(node, i5, nodes);
        }
      }
    };
  }
});

// node_modules/postcss-value-parser/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/postcss-value-parser/lib/stringify.js"(exports, module) {
    "use strict";
    init_shim();
    function stringifyNode(node, custom) {
      var type = node.type;
      var value2 = node.value;
      var buf;
      var customResult;
      if (custom && (customResult = custom(node)) !== void 0) {
        return customResult;
      } else if (type === "word" || type === "space") {
        return value2;
      } else if (type === "string") {
        buf = node.quote || "";
        return buf + value2 + (node.unclosed ? "" : buf);
      } else if (type === "comment") {
        return "/*" + value2 + (node.unclosed ? "" : "*/");
      } else if (type === "div") {
        return (node.before || "") + value2 + (node.after || "");
      } else if (Array.isArray(node.nodes)) {
        buf = stringify6(node.nodes, custom);
        if (type !== "function") {
          return buf;
        }
        return value2 + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
      }
      return value2;
    }
    function stringify6(nodes, custom) {
      var result, i5;
      if (Array.isArray(nodes)) {
        result = "";
        for (i5 = nodes.length - 1; ~i5; i5 -= 1) {
          result = stringifyNode(nodes[i5], custom) + result;
        }
        return result;
      }
      return stringifyNode(nodes, custom);
    }
    module.exports = stringify6;
  }
});

// node_modules/postcss-value-parser/lib/unit.js
var require_unit = __commonJS({
  "node_modules/postcss-value-parser/lib/unit.js"(exports, module) {
    "use strict";
    init_shim();
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp2 = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value2) {
      var code = value2.charCodeAt(0);
      var nextCode;
      if (code === plus || code === minus) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value2.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code === dot) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code >= 48 && code <= 57) {
        return true;
      }
      return false;
    }
    module.exports = function(value2) {
      var pos = 0;
      var length2 = value2.length;
      var code;
      var nextCode;
      var nextNextCode;
      if (length2 === 0 || !likeNumber(value2)) {
        return false;
      }
      code = value2.charCodeAt(pos);
      if (code === plus || code === minus) {
        pos++;
      }
      while (pos < length2) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while (pos < length2) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      nextNextCode = value2.charCodeAt(pos + 2);
      if ((code === exp2 || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos < length2) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      return {
        number: value2.slice(0, pos),
        unit: value2.slice(pos)
      };
    };
  }
});

// node_modules/postcss-value-parser/lib/index.js
var require_lib = __commonJS({
  "node_modules/postcss-value-parser/lib/index.js"(exports, module) {
    "use strict";
    init_shim();
    var parse6 = require_parse2();
    var walk2 = require_walk();
    var stringify6 = require_stringify2();
    function ValueParser(value2) {
      if (this instanceof ValueParser) {
        this.nodes = parse6(value2);
        return this;
      }
      return new ValueParser(value2);
    }
    ValueParser.prototype.toString = function() {
      return Array.isArray(this.nodes) ? stringify6(this.nodes) : "";
    };
    ValueParser.prototype.walk = function(cb, bubble) {
      walk2(this.nodes, cb, bubble);
      return this;
    };
    ValueParser.unit = require_unit();
    ValueParser.walk = walk2;
    ValueParser.stringify = stringify6;
    module.exports = ValueParser;
  }
});

// node_modules/postcss-logical/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  default: () => creator
});
function directionFlowToAxes(r5) {
  switch (r5) {
    case t.TopToBottom:
      return [i.Top, i.Bottom];
    case t.BottomToTop:
      return [i.Bottom, i.Top];
    case t.RightToLeft:
      return [i.Right, i.Left];
    case t.LeftToRight:
      return [i.Left, i.Right];
  }
}
function cloneDeclaration(r5, e4, n4) {
  return r5.parent && r5.parent.some((r6) => "decl" == r6.type && r6.prop === n4 && r6.value === e4) ? [] : [r5.clone({ value: e4, prop: n4 })];
}
function transformTransition(e4, n4, o5) {
  const { prop: t5, value: i5 } = e4, l2 = (0, import_postcss_value_parser.default)(i5), a3 = [];
  let s2 = [];
  l2.nodes.forEach((r5) => {
    if ("div" === r5.type && "," === r5.value)
      return a3.push(s2), void (s2 = []);
    s2.push(r5);
  }), a3.push(s2);
  for (let r5 = 0; r5 < a3.length; r5++) {
    const e5 = a3[r5];
    for (let t6 = 0; t6 < e5.length; t6++) {
      const i6 = e5[t6];
      if ("word" !== i6.type)
        continue;
      const l3 = i6.value.toLowerCase(), s3 = o5[l3];
      if (!s3)
        continue;
      const d4 = s3(n4.decl({ prop: l3, value: "initial" }));
      if (0 !== d4.length) {
        for (let n5 = d4.length - 1; n5 >= 0; n5--) {
          const o6 = JSON.parse(JSON.stringify(e5));
          o6[t6].value = d4[n5].prop, a3.splice(r5 + 1, 0, o6);
        }
        a3.splice(r5, 1), r5++;
      }
    }
  }
  const d3 = [];
  for (let r5 = 0; r5 < a3.length; r5++) {
    const e5 = a3[r5];
    d3.push(...e5), r5 !== a3.length - 1 && d3.push({ type: "div", value: ",", sourceIndex: 0, sourceEndIndex: 0, before: "", after: " " });
  }
  const c2 = import_postcss_value_parser.default.stringify(d3);
  return c2 !== i5 ? cloneDeclaration(e4, c2, t5) : [];
}
function parseValueCouple(e4) {
  const n4 = (0, import_postcss_value_parser.default)(e4.value).nodes.filter((r5) => "space" !== r5.type);
  if (n4.length > 2 || 0 === n4.length) {
    const r5 = `[postcss-logical] Invalid number of values for ${e4.prop}. Found ${n4.length} values, expected 1 or 2.`;
    throw e4.error(r5);
  }
  let o5, t5;
  return 1 === n4.length ? (o5 = import_postcss_value_parser.default.stringify(n4[0]), t5 = o5) : (o5 = import_postcss_value_parser.default.stringify(n4[0]), t5 = import_postcss_value_parser.default.stringify(n4[1])), [o5, t5];
}
function transformBorder(r5, e4) {
  return (n4) => cloneDeclaration(n4, n4.value, `border-${e4}-${r5}`);
}
function transformBorderProperty(r5, e4) {
  return (n4) => {
    const [o5, t5] = e4, [i5, l2] = parseValueCouple(n4);
    return [...cloneDeclaration(n4, i5, `border-${o5}-${r5}`), ...cloneDeclaration(n4, l2, `border-${t5}-${r5}`)];
  };
}
function transformBorderShorthand(r5) {
  return (e4) => r5.flatMap((r6) => cloneDeclaration(e4, e4.value, `border-${r6}`));
}
function transformBorderRadius(r5) {
  return (e4) => {
    let n4;
    switch (e4.prop.toLowerCase()) {
      case "border-start-start-radius":
        n4 = `border-${r5.inlineIsHorizontal ? `${r5.block[0]}-${r5.inline[0]}` : `${r5.inline[0]}-${r5.block[0]}`}-radius`;
        break;
      case "border-start-end-radius":
        n4 = `border-${r5.inlineIsHorizontal ? `${r5.block[0]}-${r5.inline[1]}` : `${r5.inline[1]}-${r5.block[0]}`}-radius`;
        break;
      case "border-end-start-radius":
        n4 = `border-${r5.inlineIsHorizontal ? `${r5.block[1]}-${r5.inline[0]}` : `${r5.inline[0]}-${r5.block[1]}`}-radius`;
        break;
      case "border-end-end-radius":
        n4 = `border-${r5.inlineIsHorizontal ? `${r5.block[1]}-${r5.inline[1]}` : `${r5.inline[1]}-${r5.block[1]}`}-radius`;
        break;
    }
    return n4 ? cloneDeclaration(e4, e4.value, n4) : [];
  };
}
function transformLogicalSize(r5) {
  return (e4) => {
    const { value: n4 } = e4, o5 = r5.inlineIsHorizontal ? "width" : "height", t5 = r5.inlineIsHorizontal ? "height" : "width", i5 = e4.prop.toLowerCase().replace("inline-size", o5).replace("block-size", t5);
    return cloneDeclaration(e4, n4, i5);
  };
}
function transformOffset(r5) {
  return (e4) => cloneDeclaration(e4, e4.value, r5);
}
function transformOffsetShorthand(r5) {
  return (e4) => {
    const [n4, o5] = r5, [t5, i5] = parseValueCouple(e4);
    return [...cloneDeclaration(e4, t5, n4), ...cloneDeclaration(e4, i5, o5)];
  };
}
function transformSide(r5, e4) {
  return (n4) => cloneDeclaration(n4, n4.value, `${r5}-${e4}`);
}
function transformSideShorthand(r5, e4) {
  return (n4) => {
    const [o5, t5] = e4, [i5, l2] = parseValueCouple(n4);
    return [...cloneDeclaration(n4, i5, `${r5}-${o5}`), ...cloneDeclaration(n4, l2, `${r5}-${t5}`)];
  };
}
function logicalToPhysical(r5, e4) {
  const [n4, t5] = e4.block, [i5, l2] = e4.inline;
  switch (r5) {
    case o.BlockStart:
      return n4;
    case o.BlockEnd:
      return t5;
    case o.InlineStart:
      return i5;
    case o.InlineEnd:
      return l2;
    default:
      throw new Error("Unsupported logical direction");
  }
}
function doTransform(e4, n4, o5) {
  const { prop: t5, value: i5 } = e4, l2 = (0, import_postcss_value_parser.default)(i5);
  l2.nodes.forEach((r5) => {
    if ("word" === r5.type) {
      const e5 = r5.value.toLowerCase();
      n4.includes(e5) && (r5.value = logicalToPhysical(e5, o5));
    }
  });
  const a3 = l2.toString();
  return a3 !== i5 ? cloneDeclaration(e4, a3, t5) : [];
}
function prepareTransforms(e4, t5, i5, l2, a3) {
  return { "caption-side": (d3 = e4, (r5) => doTransform(r5, Object.values(o), d3)), "text-align": e4.inlineIsHorizontal ? (s2 = e4.inline, (e5) => {
    const { prop: o5, value: t6 } = e5, i6 = (0, import_postcss_value_parser.default)(t6), [l3, a4] = s2;
    i6.nodes.forEach((r5) => {
      if ("word" === r5.type) {
        const e6 = r5.value.toLowerCase();
        if (e6 === n.End)
          return void (r5.value = a4);
        e6 === n.Start && (r5.value = l3);
      }
    });
    const d4 = i6.toString();
    return d4 !== t6 ? cloneDeclaration(e5, d4, o5) : [];
  }) : null, "block-size": transformLogicalSize(e4), "inline-size": transformLogicalSize(e4), "min-block-size": transformLogicalSize(e4), "max-block-size": transformLogicalSize(e4), "min-inline-size": transformLogicalSize(e4), "max-inline-size": transformLogicalSize(e4), "margin-block-start": transformSide("margin", t5), "margin-block-end": transformSide("margin", i5), "margin-inline-start": transformSide("margin", l2), "margin-inline-end": transformSide("margin", a3), "margin-block": transformSideShorthand("margin", e4.block), "margin-inline": transformSideShorthand("margin", e4.inline), "inset-block": transformOffsetShorthand(e4.block), "inset-block-start": transformOffset(t5), "inset-block-end": transformOffset(i5), "inset-inline": transformOffsetShorthand(e4.inline), "inset-inline-start": transformOffset(l2), "inset-inline-end": transformOffset(a3), inset: (e5) => {
    const n4 = (0, import_postcss_value_parser.default)(e5.value).nodes.filter((r5) => "space" !== r5.type && "comment" !== r5.type);
    if (n4.length > 4) {
      const r5 = `[postcss-logical] Invalid number of values for ${e5.prop}. Found ${n4.length} values, expected up to 4 values.`;
      throw e5.error(r5);
    }
    let o5, t6, i6, l3;
    if (1 === n4.length)
      o5 = import_postcss_value_parser.default.stringify(n4[0]), t6 = o5, i6 = o5, l3 = o5;
    else if (2 === n4.length)
      o5 = import_postcss_value_parser.default.stringify(n4[0]), t6 = import_postcss_value_parser.default.stringify(n4[1]), i6 = o5, l3 = t6;
    else if (3 === n4.length)
      o5 = import_postcss_value_parser.default.stringify(n4[0]), t6 = import_postcss_value_parser.default.stringify(n4[1]), l3 = t6, i6 = import_postcss_value_parser.default.stringify(n4[2]);
    else {
      if (4 !== n4.length)
        return [];
      o5 = import_postcss_value_parser.default.stringify(n4[0]), t6 = import_postcss_value_parser.default.stringify(n4[1]), i6 = import_postcss_value_parser.default.stringify(n4[2]), l3 = import_postcss_value_parser.default.stringify(n4[3]);
    }
    return [...cloneDeclaration(e5, o5, "top"), ...cloneDeclaration(e5, t6, "right"), ...cloneDeclaration(e5, i6, "bottom"), ...cloneDeclaration(e5, l3, "left")];
  }, "padding-block-start": transformSide("padding", t5), "padding-block-end": transformSide("padding", i5), "padding-inline-start": transformSide("padding", l2), "padding-inline-end": transformSide("padding", a3), "padding-block": transformSideShorthand("padding", e4.block), "padding-inline": transformSideShorthand("padding", e4.inline), "border-block-start-width": transformBorder("width", t5), "border-block-end-width": transformBorder("width", i5), "border-inline-start-width": transformBorder("width", l2), "border-inline-end-width": transformBorder("width", a3), "border-block-width": transformBorderProperty("width", e4.block), "border-inline-width": transformBorderProperty("width", e4.inline), "border-block-start-style": transformBorder("style", t5), "border-block-end-style": transformBorder("style", i5), "border-inline-start-style": transformBorder("style", l2), "border-inline-end-style": transformBorder("style", a3), "border-block-style": transformBorderProperty("style", e4.block), "border-inline-style": transformBorderProperty("style", e4.inline), "border-block-start-color": transformBorder("color", t5), "border-block-end-color": transformBorder("color", i5), "border-inline-start-color": transformBorder("color", l2), "border-inline-end-color": transformBorder("color", a3), "border-block-color": transformBorderProperty("color", e4.block), "border-inline-color": transformBorderProperty("color", e4.inline), "border-block": transformBorderShorthand(e4.block), "border-block-start": transformBorderShorthand([t5]), "border-block-end": transformBorderShorthand([i5]), "border-inline": transformBorderShorthand(e4.inline), "border-inline-start": transformBorderShorthand([l2]), "border-inline-end": transformBorderShorthand([a3]), "border-start-start-radius": transformBorderRadius(e4), "border-start-end-radius": transformBorderRadius(e4), "border-end-start-radius": transformBorderRadius(e4), "border-end-end-radius": transformBorderRadius(e4) };
  var s2, d3;
}
var import_postcss_value_parser, e, n, o, t, i, creator;
var init_dist = __esm({
  "node_modules/postcss-logical/dist/index.mjs"() {
    "use strict";
    init_shim();
    import_postcss_value_parser = __toESM(require_lib(), 1);
    !function(r5) {
      r5.Block = "block", r5.Inline = "inline";
    }(e || (e = {})), function(r5) {
      r5.Start = "start", r5.End = "end";
    }(n || (n = {}));
    o = { BlockStart: "block-start", BlockEnd: "block-end", InlineStart: "inline-start", InlineEnd: "inline-end" };
    !function(r5) {
      r5.TopToBottom = "top-to-bottom", r5.BottomToTop = "bottom-to-top", r5.RightToLeft = "right-to-left", r5.LeftToRight = "left-to-right";
    }(t || (t = {})), function(r5) {
      r5.Top = "top", r5.Right = "right", r5.Bottom = "bottom", r5.Left = "left";
    }(i || (i = {}));
    creator = (r5) => {
      const e4 = Object.assign({ blockDirection: t.TopToBottom, inlineDirection: t.LeftToRight }, r5), n4 = Object.values(t);
      if (!n4.includes(e4.blockDirection))
        throw new Error(`[postcss-logical] "blockDirection" must be one of ${n4.join(", ")}`);
      if (!n4.includes(e4.inlineDirection))
        throw new Error(`[postcss-logical] "inlineDirection" must be one of ${n4.join(", ")}`);
      const [o5, l2] = directionFlowToAxes(e4.blockDirection), [a3, s2] = directionFlowToAxes(e4.inlineDirection);
      if (!Object.values(i).every((r6) => [o5, l2, a3, s2].includes(r6)))
        throw new Error('[postcss-logical] "blockDirection" and "inlineDirection" must be on separate axes');
      const makeTransform = (r6) => (e5, { result: n5 }) => {
        if (!r6)
          return;
        let o6 = [];
        try {
          o6 = r6(e5);
        } catch (r7) {
          return void e5.warn(n5, r7 instanceof Error ? r7.message : String(r7));
        }
        o6?.length && (o6.forEach((r7) => {
          e5.cloneBefore(r7);
        }), e5.remove());
      }, d3 = prepareTransforms({ block: [o5, l2], inline: [a3, s2], inlineIsHorizontal: [t.LeftToRight, t.RightToLeft].includes(e4.inlineDirection) }, o5, l2, a3, s2);
      return { postcssPlugin: "postcss-logical", Declaration: { "caption-side": makeTransform(d3["caption-side"]), "text-align": makeTransform(d3["text-align"]), "block-size": makeTransform(d3["block-size"]), "inline-size": makeTransform(d3["inline-size"]), "min-block-size": makeTransform(d3["min-block-size"]), "max-block-size": makeTransform(d3["max-block-size"]), "min-inline-size": makeTransform(d3["min-inline-size"]), "max-inline-size": makeTransform(d3["max-inline-size"]), "margin-block-start": makeTransform(d3["margin-block-start"]), "margin-block-end": makeTransform(d3["margin-block-end"]), "margin-inline-start": makeTransform(d3["margin-inline-start"]), "margin-inline-end": makeTransform(d3["margin-inline-end"]), "margin-block": makeTransform(d3["margin-block"]), "margin-inline": makeTransform(d3["margin-inline"]), "inset-block": makeTransform(d3["inset-block"]), "inset-block-start": makeTransform(d3["inset-block-start"]), "inset-block-end": makeTransform(d3["inset-block-end"]), "inset-inline": makeTransform(d3["inset-inline"]), "inset-inline-start": makeTransform(d3["inset-inline-start"]), "inset-inline-end": makeTransform(d3["inset-inline-end"]), inset: makeTransform(d3.inset), "padding-block-start": makeTransform(d3["padding-block-start"]), "padding-block-end": makeTransform(d3["padding-block-end"]), "padding-inline-start": makeTransform(d3["padding-inline-start"]), "padding-inline-end": makeTransform(d3["padding-inline-end"]), "padding-block": makeTransform(d3["padding-block"]), "padding-inline": makeTransform(d3["padding-inline"]), "border-block-start-width": makeTransform(d3["border-block-start-width"]), "border-block-end-width": makeTransform(d3["border-block-end-width"]), "border-inline-start-width": makeTransform(d3["border-inline-start-width"]), "border-inline-end-width": makeTransform(d3["border-inline-end-width"]), "border-block-width": makeTransform(d3["border-block-width"]), "border-inline-width": makeTransform(d3["border-inline-width"]), "border-block-start-style": makeTransform(d3["border-block-start-style"]), "border-block-end-style": makeTransform(d3["border-block-end-style"]), "border-inline-start-style": makeTransform(d3["border-inline-start-style"]), "border-inline-end-style": makeTransform(d3["border-inline-end-style"]), "border-block-style": makeTransform(d3["border-block-style"]), "border-inline-style": makeTransform(d3["border-inline-style"]), "border-block-start-color": makeTransform(d3["border-block-start-color"]), "border-block-end-color": makeTransform(d3["border-block-end-color"]), "border-inline-start-color": makeTransform(d3["border-inline-start-color"]), "border-inline-end-color": makeTransform(d3["border-inline-end-color"]), "border-block-color": makeTransform(d3["border-block-color"]), "border-inline-color": makeTransform(d3["border-inline-color"]), "border-block": makeTransform(d3["border-block"]), "border-block-start": makeTransform(d3["border-block-start"]), "border-block-end": makeTransform(d3["border-block-end"]), "border-inline": makeTransform(d3["border-inline"]), "border-inline-start": makeTransform(d3["border-inline-start"]), "border-inline-end": makeTransform(d3["border-inline-end"]), "border-start-start-radius": makeTransform(d3["border-start-start-radius"]), "border-start-end-radius": makeTransform(d3["border-start-end-radius"]), "border-end-start-radius": makeTransform(d3["border-end-start-radius"]), "border-end-end-radius": makeTransform(d3["border-end-end-radius"]), transition: (r6, { result: e5, postcss: n5 }) => {
        let o6 = [];
        try {
          o6 = transformTransition(r6, n5, d3);
        } catch (n6) {
          return void r6.warn(e5, n6 instanceof Error ? n6.message : String(n6));
        }
        o6?.length && (o6.forEach((e6) => {
          r6.cloneBefore(e6);
        }), r6.remove());
      } } };
    };
    creator.postcss = true;
  }
});

// node_modules/quick-lru/index.js
var require_quick_lru = __commonJS({
  "node_modules/quick-lru/index.js"(exports, module) {
    "use strict";
    init_shim();
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value2) {
        this.cache.set(key, value2);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value3] of this.oldCache.entries()) {
              this.onEviction(key2, value3);
            }
          }
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value2 = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value2);
          return value2;
        }
      }
      set(key, value2) {
        if (this.cache.has(key)) {
          this.cache.set(key, value2);
        } else {
          this._set(key, value2);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value2] of this) {
          yield value2;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module.exports = QuickLRU;
  }
});

// node_modules/postcss-selector-parser/dist/util/unesc.js
var require_unesc = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/unesc.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = unesc;
    function gobbleHex(str) {
      var lower = str.toLowerCase();
      var hex2 = "";
      var spaceTerminated = false;
      for (var i5 = 0; i5 < 6 && lower[i5] !== void 0; i5++) {
        var code = lower.charCodeAt(i5);
        var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
        spaceTerminated = code === 32;
        if (!valid) {
          break;
        }
        hex2 += lower[i5];
      }
      if (hex2.length === 0) {
        return void 0;
      }
      var codePoint = parseInt(hex2, 16);
      var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
      if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
        return ["\uFFFD", hex2.length + (spaceTerminated ? 1 : 0)];
      }
      return [String.fromCodePoint(codePoint), hex2.length + (spaceTerminated ? 1 : 0)];
    }
    var CONTAINS_ESCAPE = /\\/;
    function unesc(str) {
      var needToProcess = CONTAINS_ESCAPE.test(str);
      if (!needToProcess) {
        return str;
      }
      var ret = "";
      for (var i5 = 0; i5 < str.length; i5++) {
        if (str[i5] === "\\") {
          var gobbled = gobbleHex(str.slice(i5 + 1, i5 + 7));
          if (gobbled !== void 0) {
            ret += gobbled[0];
            i5 += gobbled[1];
            continue;
          }
          if (str[i5 + 1] === "\\") {
            ret += "\\";
            i5++;
            continue;
          }
          if (str.length === i5 + 1) {
            ret += str[i5];
          }
          continue;
        }
        ret += str[i5];
      }
      return ret;
    }
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/getProp.js
var require_getProp = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/getProp.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = getProp;
    function getProp(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          return void 0;
        }
        obj = obj[prop];
      }
      return obj;
    }
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/ensureObject.js
var require_ensureObject = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/ensureObject.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = ensureObject;
    function ensureObject(obj) {
      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        props[_key - 1] = arguments[_key];
      }
      while (props.length > 0) {
        var prop = props.shift();
        if (!obj[prop]) {
          obj[prop] = {};
        }
        obj = obj[prop];
      }
    }
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/stripComments.js
var require_stripComments = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/stripComments.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = stripComments;
    function stripComments(str) {
      var s2 = "";
      var commentStart = str.indexOf("/*");
      var lastEnd = 0;
      while (commentStart >= 0) {
        s2 = s2 + str.slice(lastEnd, commentStart);
        var commentEnd = str.indexOf("*/", commentStart + 2);
        if (commentEnd < 0) {
          return s2;
        }
        lastEnd = commentEnd + 2;
        commentStart = str.indexOf("/*", lastEnd);
      }
      s2 = s2 + str.slice(lastEnd);
      return s2;
    }
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/util/index.js
var require_util = __commonJS({
  "node_modules/postcss-selector-parser/dist/util/index.js"(exports) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports.unesc = exports.stripComments = exports.getProp = exports.ensureObject = void 0;
    var _unesc = _interopRequireDefault(require_unesc());
    exports.unesc = _unesc["default"];
    var _getProp = _interopRequireDefault(require_getProp());
    exports.getProp = _getProp["default"];
    var _ensureObject = _interopRequireDefault(require_ensureObject());
    exports.ensureObject = _ensureObject["default"];
    var _stripComments = _interopRequireDefault(require_stripComments());
    exports.stripComments = _stripComments["default"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});

// node_modules/postcss-selector-parser/dist/selectors/node.js
var require_node2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/node.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _util = require_util();
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var cloneNode = function cloneNode2(obj, parent) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      var cloned = new obj.constructor();
      for (var i5 in obj) {
        if (!obj.hasOwnProperty(i5)) {
          continue;
        }
        var value2 = obj[i5];
        var type = typeof value2;
        if (i5 === "parent" && type === "object") {
          if (parent) {
            cloned[i5] = parent;
          }
        } else if (value2 instanceof Array) {
          cloned[i5] = value2.map(function(j2) {
            return cloneNode2(j2, cloned);
          });
        } else {
          cloned[i5] = cloneNode2(value2, cloned);
        }
      }
      return cloned;
    };
    var Node2 = /* @__PURE__ */ function() {
      function Node3(opts) {
        if (opts === void 0) {
          opts = {};
        }
        Object.assign(this, opts);
        this.spaces = this.spaces || {};
        this.spaces.before = this.spaces.before || "";
        this.spaces.after = this.spaces.after || "";
      }
      var _proto = Node3.prototype;
      _proto.remove = function remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      };
      _proto.replaceWith = function replaceWith() {
        if (this.parent) {
          for (var index2 in arguments) {
            this.parent.insertBefore(this, arguments[index2]);
          }
          this.remove();
        }
        return this;
      };
      _proto.next = function next() {
        return this.parent.at(this.parent.index(this) + 1);
      };
      _proto.prev = function prev() {
        return this.parent.at(this.parent.index(this) - 1);
      };
      _proto.clone = function clone(overrides) {
        if (overrides === void 0) {
          overrides = {};
        }
        var cloned = cloneNode(this);
        for (var name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      };
      _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value2, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        var originalValue = this[name];
        var originalEscaped = this.raws[name];
        this[name] = originalValue + value2;
        if (originalEscaped || valueEscaped !== value2) {
          this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
        } else {
          delete this.raws[name];
        }
      };
      _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value2, valueEscaped) {
        if (!this.raws) {
          this.raws = {};
        }
        this[name] = value2;
        this.raws[name] = valueEscaped;
      };
      _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value2) {
        this[name] = value2;
        if (this.raws) {
          delete this.raws[name];
        }
      };
      _proto.isAtPosition = function isAtPosition(line, column) {
        if (this.source && this.source.start && this.source.end) {
          if (this.source.start.line > line) {
            return false;
          }
          if (this.source.end.line < line) {
            return false;
          }
          if (this.source.start.line === line && this.source.start.column > column) {
            return false;
          }
          if (this.source.end.line === line && this.source.end.column < column) {
            return false;
          }
          return true;
        }
        return void 0;
      };
      _proto.stringifyProperty = function stringifyProperty(name) {
        return this.raws && this.raws[name] || this[name];
      };
      _proto.valueToString = function valueToString() {
        return String(this.stringifyProperty("value"));
      };
      _proto.toString = function toString() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      };
      _createClass(Node3, [{
        key: "rawSpaceBefore",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
          if (rawSpace === void 0) {
            rawSpace = this.spaces && this.spaces.before;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.before = raw;
        }
      }, {
        key: "rawSpaceAfter",
        get: function get() {
          var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
          if (rawSpace === void 0) {
            rawSpace = this.spaces.after;
          }
          return rawSpace || "";
        },
        set: function set(raw) {
          (0, _util.ensureObject)(this, "raws", "spaces");
          this.raws.spaces.after = raw;
        }
      }]);
      return Node3;
    }();
    exports["default"] = Node2;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/types.js
var require_types = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/types.js"(exports) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports.UNIVERSAL = exports.TAG = exports.STRING = exports.SELECTOR = exports.ROOT = exports.PSEUDO = exports.NESTING = exports.ID = exports.COMMENT = exports.COMBINATOR = exports.CLASS = exports.ATTRIBUTE = void 0;
    var TAG = "tag";
    exports.TAG = TAG;
    var STRING = "string";
    exports.STRING = STRING;
    var SELECTOR = "selector";
    exports.SELECTOR = SELECTOR;
    var ROOT = "root";
    exports.ROOT = ROOT;
    var PSEUDO = "pseudo";
    exports.PSEUDO = PSEUDO;
    var NESTING = "nesting";
    exports.NESTING = NESTING;
    var ID = "id";
    exports.ID = ID;
    var COMMENT = "comment";
    exports.COMMENT = COMMENT;
    var COMBINATOR = "combinator";
    exports.COMBINATOR = COMBINATOR;
    var CLASS = "class";
    exports.CLASS = CLASS;
    var ATTRIBUTE = "attribute";
    exports.ATTRIBUTE = ATTRIBUTE;
    var UNIVERSAL = "universal";
    exports.UNIVERSAL = UNIVERSAL;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/container.js
var require_container2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/container.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node2());
    var types2 = _interopRequireWildcard(require_types());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _createForOfIteratorHelperLoose(o5, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o5[Symbol.iterator] || o5["@@iterator"];
      if (it)
        return (it = it.call(o5)).next.bind(it);
      if (Array.isArray(o5) || (it = _unsupportedIterableToArray(o5)) || allowArrayLike && o5 && typeof o5.length === "number") {
        if (it)
          o5 = it;
        var i5 = 0;
        return function() {
          if (i5 >= o5.length)
            return { done: true };
          return { done: false, value: o5[i5++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o5, minLen) {
      if (!o5)
        return;
      if (typeof o5 === "string")
        return _arrayLikeToArray(o5, minLen);
      var n4 = Object.prototype.toString.call(o5).slice(8, -1);
      if (n4 === "Object" && o5.constructor)
        n4 = o5.constructor.name;
      if (n4 === "Map" || n4 === "Set")
        return Array.from(o5);
      if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
        return _arrayLikeToArray(o5, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i5 = 0, arr2 = new Array(len); i5 < len; i5++) {
        arr2[i5] = arr[i5];
      }
      return arr2;
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Container2 = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Container3, _Node);
      function Container3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        if (!_this.nodes) {
          _this.nodes = [];
        }
        return _this;
      }
      var _proto = Container3.prototype;
      _proto.append = function append(selector) {
        selector.parent = this;
        this.nodes.push(selector);
        return this;
      };
      _proto.prepend = function prepend(selector) {
        selector.parent = this;
        this.nodes.unshift(selector);
        return this;
      };
      _proto.at = function at(index2) {
        return this.nodes[index2];
      };
      _proto.index = function index2(child) {
        if (typeof child === "number") {
          return child;
        }
        return this.nodes.indexOf(child);
      };
      _proto.removeChild = function removeChild(child) {
        child = this.index(child);
        this.at(child).parent = void 0;
        this.nodes.splice(child, 1);
        var index2;
        for (var id in this.indexes) {
          index2 = this.indexes[id];
          if (index2 >= child) {
            this.indexes[id] = index2 - 1;
          }
        }
        return this;
      };
      _proto.removeAll = function removeAll() {
        for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
          var node = _step.value;
          node.parent = void 0;
        }
        this.nodes = [];
        return this;
      };
      _proto.empty = function empty2() {
        return this.removeAll();
      };
      _proto.insertAfter = function insertAfter(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex + 1, 0, newNode);
        newNode.parent = this;
        var index2;
        for (var id in this.indexes) {
          index2 = this.indexes[id];
          if (oldIndex <= index2) {
            this.indexes[id] = index2 + 1;
          }
        }
        return this;
      };
      _proto.insertBefore = function insertBefore(oldNode, newNode) {
        newNode.parent = this;
        var oldIndex = this.index(oldNode);
        this.nodes.splice(oldIndex, 0, newNode);
        newNode.parent = this;
        var index2;
        for (var id in this.indexes) {
          index2 = this.indexes[id];
          if (index2 <= oldIndex) {
            this.indexes[id] = index2 + 1;
          }
        }
        return this;
      };
      _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
        var found = void 0;
        this.each(function(node) {
          if (node.atPosition) {
            var foundChild = node.atPosition(line, col);
            if (foundChild) {
              found = foundChild;
              return false;
            }
          } else if (node.isAtPosition(line, col)) {
            found = node;
            return false;
          }
        });
        return found;
      };
      _proto.atPosition = function atPosition(line, col) {
        if (this.isAtPosition(line, col)) {
          return this._findChildAtPosition(line, col) || this;
        } else {
          return void 0;
        }
      };
      _proto._inferEndPosition = function _inferEndPosition() {
        if (this.last && this.last.source && this.last.source.end) {
          this.source = this.source || {};
          this.source.end = this.source.end || {};
          Object.assign(this.source.end, this.last.source.end);
        }
      };
      _proto.each = function each(callback) {
        if (!this.lastEach) {
          this.lastEach = 0;
        }
        if (!this.indexes) {
          this.indexes = {};
        }
        this.lastEach++;
        var id = this.lastEach;
        this.indexes[id] = 0;
        if (!this.length) {
          return void 0;
        }
        var index2, result;
        while (this.indexes[id] < this.length) {
          index2 = this.indexes[id];
          result = callback(this.at(index2), index2);
          if (result === false) {
            break;
          }
          this.indexes[id] += 1;
        }
        delete this.indexes[id];
        if (result === false) {
          return false;
        }
      };
      _proto.walk = function walk2(callback) {
        return this.each(function(node, i5) {
          var result = callback(node, i5);
          if (result !== false && node.length) {
            result = node.walk(callback);
          }
          if (result === false) {
            return false;
          }
        });
      };
      _proto.walkAttributes = function walkAttributes(callback) {
        var _this2 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.ATTRIBUTE) {
            return callback.call(_this2, selector);
          }
        });
      };
      _proto.walkClasses = function walkClasses(callback) {
        var _this3 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.CLASS) {
            return callback.call(_this3, selector);
          }
        });
      };
      _proto.walkCombinators = function walkCombinators(callback) {
        var _this4 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.COMBINATOR) {
            return callback.call(_this4, selector);
          }
        });
      };
      _proto.walkComments = function walkComments(callback) {
        var _this5 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.COMMENT) {
            return callback.call(_this5, selector);
          }
        });
      };
      _proto.walkIds = function walkIds(callback) {
        var _this6 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.ID) {
            return callback.call(_this6, selector);
          }
        });
      };
      _proto.walkNesting = function walkNesting(callback) {
        var _this7 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.NESTING) {
            return callback.call(_this7, selector);
          }
        });
      };
      _proto.walkPseudos = function walkPseudos(callback) {
        var _this8 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.PSEUDO) {
            return callback.call(_this8, selector);
          }
        });
      };
      _proto.walkTags = function walkTags(callback) {
        var _this9 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.TAG) {
            return callback.call(_this9, selector);
          }
        });
      };
      _proto.walkUniversals = function walkUniversals(callback) {
        var _this10 = this;
        return this.walk(function(selector) {
          if (selector.type === types2.UNIVERSAL) {
            return callback.call(_this10, selector);
          }
        });
      };
      _proto.split = function split(callback) {
        var _this11 = this;
        var current = [];
        return this.reduce(function(memo, node, index2) {
          var split2 = callback.call(_this11, node);
          current.push(node);
          if (split2) {
            memo.push(current);
            current = [];
          } else if (index2 === _this11.length - 1) {
            memo.push(current);
          }
          return memo;
        }, []);
      };
      _proto.map = function map(callback) {
        return this.nodes.map(callback);
      };
      _proto.reduce = function reduce(callback, memo) {
        return this.nodes.reduce(callback, memo);
      };
      _proto.every = function every(callback) {
        return this.nodes.every(callback);
      };
      _proto.some = function some(callback) {
        return this.nodes.some(callback);
      };
      _proto.filter = function filter2(callback) {
        return this.nodes.filter(callback);
      };
      _proto.sort = function sort(callback) {
        return this.nodes.sort(callback);
      };
      _proto.toString = function toString() {
        return this.map(String).join("");
      };
      _createClass(Container3, [{
        key: "first",
        get: function get() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function get() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function get() {
          return this.nodes.length;
        }
      }]);
      return Container3;
    }(_node["default"]);
    exports["default"] = Container2;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/root.js
var require_root2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/root.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Root2 = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Root3, _Container);
      function Root3(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.ROOT;
        return _this;
      }
      var _proto = Root3.prototype;
      _proto.toString = function toString() {
        var str = this.reduce(function(memo, selector) {
          memo.push(String(selector));
          return memo;
        }, []).join(",");
        return this.trailingComma ? str + "," : str;
      };
      _proto.error = function error(message, options) {
        if (this._error) {
          return this._error(message, options);
        } else {
          return new Error(message);
        }
      };
      _createClass(Root3, [{
        key: "errorGenerator",
        set: function set(handler) {
          this._error = handler;
        }
      }]);
      return Root3;
    }(_container["default"]);
    exports["default"] = Root2;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/selector.js
var require_selector = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/selector.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Selector = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Selector2, _Container);
      function Selector2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.SELECTOR;
        return _this;
      }
      return Selector2;
    }(_container["default"]);
    exports["default"] = Selector;
    module.exports = exports.default;
  }
});

// node_modules/cssesc/cssesc.js
var require_cssesc = __commonJS({
  "node_modules/cssesc/cssesc.js"(exports, module) {
    "use strict";
    init_shim();
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var merge = function merge2(options, defaults3) {
      if (!options) {
        return defaults3;
      }
      var result = {};
      for (var key in defaults3) {
        result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults3[key];
      }
      return result;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc = function cssesc2(string, options) {
      options = merge(options, cssesc2.options);
      if (options.quotes != "single" && options.quotes != "double") {
        options.quotes = "single";
      }
      var quote = options.quotes == "double" ? '"' : "'";
      var isIdentifier = options.isIdentifier;
      var firstChar = string.charAt(0);
      var output = "";
      var counter = 0;
      var length2 = string.length;
      while (counter < length2) {
        var character = string.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value2 = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length2) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value2 = "\\" + character;
            } else {
              value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
            value2 = "\\" + character;
          } else {
            value2 = character;
          }
        }
        output += value2;
      }
      if (isIdentifier) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier && options.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    module.exports = cssesc;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/className.js
var require_className = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/className.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util();
    var _node = _interopRequireDefault(require_node2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var ClassName = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ClassName2, _Node);
      function ClassName2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.CLASS;
        _this._constructed = true;
        return _this;
      }
      var _proto = ClassName2.prototype;
      _proto.valueToString = function valueToString() {
        return "." + _Node.prototype.valueToString.call(this);
      };
      _createClass(ClassName2, [{
        key: "value",
        get: function get() {
          return this._value;
        },
        set: function set(v2) {
          if (this._constructed) {
            var escaped = (0, _cssesc["default"])(v2, {
              isIdentifier: true
            });
            if (escaped !== v2) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.value = escaped;
            } else if (this.raws) {
              delete this.raws.value;
            }
          }
          this._value = v2;
        }
      }]);
      return ClassName2;
    }(_node["default"]);
    exports["default"] = ClassName;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/comment.js
var require_comment2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/comment.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Comment2 = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Comment3, _Node);
      function Comment3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMMENT;
        return _this;
      }
      return Comment3;
    }(_node["default"]);
    exports["default"] = Comment2;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/id.js
var require_id = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/id.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var ID = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(ID2, _Node);
      function ID2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.ID;
        return _this;
      }
      var _proto = ID2.prototype;
      _proto.valueToString = function valueToString() {
        return "#" + _Node.prototype.valueToString.call(this);
      };
      return ID2;
    }(_node["default"]);
    exports["default"] = ID;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/namespace.js
var require_namespace = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/namespace.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _util = require_util();
    var _node = _interopRequireDefault(require_node2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Namespace = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Namespace2, _Node);
      function Namespace2() {
        return _Node.apply(this, arguments) || this;
      }
      var _proto = Namespace2.prototype;
      _proto.qualifiedName = function qualifiedName(value2) {
        if (this.namespace) {
          return this.namespaceString + "|" + value2;
        } else {
          return value2;
        }
      };
      _proto.valueToString = function valueToString() {
        return this.qualifiedName(_Node.prototype.valueToString.call(this));
      };
      _createClass(Namespace2, [{
        key: "namespace",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          if (namespace === true || namespace === "*" || namespace === "&") {
            this._namespace = namespace;
            if (this.raws) {
              delete this.raws.namespace;
            }
            return;
          }
          var escaped = (0, _cssesc["default"])(namespace, {
            isIdentifier: true
          });
          this._namespace = namespace;
          if (escaped !== namespace) {
            (0, _util.ensureObject)(this, "raws");
            this.raws.namespace = escaped;
          } else if (this.raws) {
            delete this.raws.namespace;
          }
        }
      }, {
        key: "ns",
        get: function get() {
          return this._namespace;
        },
        set: function set(namespace) {
          this.namespace = namespace;
        }
      }, {
        key: "namespaceString",
        get: function get() {
          if (this.namespace) {
            var ns = this.stringifyProperty("namespace");
            if (ns === true) {
              return "";
            } else {
              return ns;
            }
          } else {
            return "";
          }
        }
      }]);
      return Namespace2;
    }(_node["default"]);
    exports["default"] = Namespace;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/tag.js
var require_tag = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/tag.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Tag = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Tag2, _Namespace);
      function Tag2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.TAG;
        return _this;
      }
      return Tag2;
    }(_namespace["default"]);
    exports["default"] = Tag;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/string.js
var require_string = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/string.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var String2 = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(String3, _Node);
      function String3(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.STRING;
        return _this;
      }
      return String3;
    }(_node["default"]);
    exports["default"] = String2;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/pseudo.js
var require_pseudo = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _container = _interopRequireDefault(require_container2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Pseudo = /* @__PURE__ */ function(_Container) {
      _inheritsLoose(Pseudo2, _Container);
      function Pseudo2(opts) {
        var _this;
        _this = _Container.call(this, opts) || this;
        _this.type = _types.PSEUDO;
        return _this;
      }
      var _proto = Pseudo2.prototype;
      _proto.toString = function toString() {
        var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
      };
      return Pseudo2;
    }(_container["default"]);
    exports["default"] = Pseudo;
    module.exports = exports.default;
  }
});

// node_modules/util-deprecate/browser.js
var require_browser2 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!_global.localStorage)
          return false;
      } catch (_3) {
        return false;
      }
      var val = _global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/postcss-selector-parser/dist/selectors/attribute.js
var require_attribute = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/attribute.js"(exports) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    exports.unescapeValue = unescapeValue;
    var _cssesc = _interopRequireDefault(require_cssesc());
    var _unesc = _interopRequireDefault(require_unesc());
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    var _CSSESC_QUOTE_OPTIONS;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var deprecate = require_browser2();
    var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
    var warnOfDeprecatedValueAssignment = deprecate(function() {
    }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
    var warnOfDeprecatedQuotedAssignment = deprecate(function() {
    }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
    var warnOfDeprecatedConstructor = deprecate(function() {
    }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function unescapeValue(value2) {
      var deprecatedUsage = false;
      var quoteMark = null;
      var unescaped = value2;
      var m2 = unescaped.match(WRAPPED_IN_QUOTES);
      if (m2) {
        quoteMark = m2[1];
        unescaped = m2[2];
      }
      unescaped = (0, _unesc["default"])(unescaped);
      if (unescaped !== value2) {
        deprecatedUsage = true;
      }
      return {
        deprecatedUsage,
        unescaped,
        quoteMark
      };
    }
    function handleDeprecatedContructorOpts(opts) {
      if (opts.quoteMark !== void 0) {
        return opts;
      }
      if (opts.value === void 0) {
        return opts;
      }
      warnOfDeprecatedConstructor();
      var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
      if (!opts.raws) {
        opts.raws = {};
      }
      if (opts.raws.value === void 0) {
        opts.raws.value = opts.value;
      }
      opts.value = unescaped;
      opts.quoteMark = quoteMark;
      return opts;
    }
    var Attribute = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Attribute2, _Namespace);
      function Attribute2(opts) {
        var _this;
        if (opts === void 0) {
          opts = {};
        }
        _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
        _this.type = _types.ATTRIBUTE;
        _this.raws = _this.raws || {};
        Object.defineProperty(_this.raws, "unquoted", {
          get: deprecate(function() {
            return _this.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: deprecate(function() {
            return _this.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        });
        _this._constructed = true;
        return _this;
      }
      var _proto = Attribute2.prototype;
      _proto.getQuotedValue = function getQuotedValue(options) {
        if (options === void 0) {
          options = {};
        }
        var quoteMark = this._determineQuoteMark(options);
        var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
        var escaped = (0, _cssesc["default"])(this._value, cssescopts);
        return escaped;
      };
      _proto._determineQuoteMark = function _determineQuoteMark(options) {
        return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
      };
      _proto.setValue = function setValue(value2, options) {
        if (options === void 0) {
          options = {};
        }
        this._value = value2;
        this._quoteMark = this._determineQuoteMark(options);
        this._syncRawValue();
      };
      _proto.smartQuoteMark = function smartQuoteMark(options) {
        var v2 = this.value;
        var numSingleQuotes = v2.replace(/[^']/g, "").length;
        var numDoubleQuotes = v2.replace(/[^"]/g, "").length;
        if (numSingleQuotes + numDoubleQuotes === 0) {
          var escaped = (0, _cssesc["default"])(v2, {
            isIdentifier: true
          });
          if (escaped === v2) {
            return Attribute2.NO_QUOTE;
          } else {
            var pref = this.preferredQuoteMark(options);
            if (pref === Attribute2.NO_QUOTE) {
              var quote = this.quoteMark || options.quoteMark || Attribute2.DOUBLE_QUOTE;
              var opts = CSSESC_QUOTE_OPTIONS[quote];
              var quoteValue = (0, _cssesc["default"])(v2, opts);
              if (quoteValue.length < escaped.length) {
                return quote;
              }
            }
            return pref;
          }
        } else if (numDoubleQuotes === numSingleQuotes) {
          return this.preferredQuoteMark(options);
        } else if (numDoubleQuotes < numSingleQuotes) {
          return Attribute2.DOUBLE_QUOTE;
        } else {
          return Attribute2.SINGLE_QUOTE;
        }
      };
      _proto.preferredQuoteMark = function preferredQuoteMark(options) {
        var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
        if (quoteMark === void 0) {
          quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
        }
        if (quoteMark === void 0) {
          quoteMark = Attribute2.DOUBLE_QUOTE;
        }
        return quoteMark;
      };
      _proto._syncRawValue = function _syncRawValue() {
        var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
        if (rawValue === this._value) {
          if (this.raws) {
            delete this.raws.value;
          }
        } else {
          this.raws.value = rawValue;
        }
      };
      _proto._handleEscapes = function _handleEscapes(prop, value2) {
        if (this._constructed) {
          var escaped = (0, _cssesc["default"])(value2, {
            isIdentifier: true
          });
          if (escaped !== value2) {
            this.raws[prop] = escaped;
          } else {
            delete this.raws[prop];
          }
        }
      };
      _proto._spacesFor = function _spacesFor(name) {
        var attrSpaces = {
          before: "",
          after: ""
        };
        var spaces = this.spaces[name] || {};
        var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
        return Object.assign(attrSpaces, spaces, rawSpaces);
      };
      _proto._stringFor = function _stringFor(name, spaceName, concat) {
        if (spaceName === void 0) {
          spaceName = name;
        }
        if (concat === void 0) {
          concat = defaultAttrConcat;
        }
        var attrSpaces = this._spacesFor(spaceName);
        return concat(this.stringifyProperty(name), attrSpaces);
      };
      _proto.offsetOf = function offsetOf(name) {
        var count = 1;
        var attributeSpaces = this._spacesFor("attribute");
        count += attributeSpaces.before.length;
        if (name === "namespace" || name === "ns") {
          return this.namespace ? count : -1;
        }
        if (name === "attributeNS") {
          return count;
        }
        count += this.namespaceString.length;
        if (this.namespace) {
          count += 1;
        }
        if (name === "attribute") {
          return count;
        }
        count += this.stringifyProperty("attribute").length;
        count += attributeSpaces.after.length;
        var operatorSpaces = this._spacesFor("operator");
        count += operatorSpaces.before.length;
        var operator = this.stringifyProperty("operator");
        if (name === "operator") {
          return operator ? count : -1;
        }
        count += operator.length;
        count += operatorSpaces.after.length;
        var valueSpaces = this._spacesFor("value");
        count += valueSpaces.before.length;
        var value2 = this.stringifyProperty("value");
        if (name === "value") {
          return value2 ? count : -1;
        }
        count += value2.length;
        count += valueSpaces.after.length;
        var insensitiveSpaces = this._spacesFor("insensitive");
        count += insensitiveSpaces.before.length;
        if (name === "insensitive") {
          return this.insensitive ? count : -1;
        }
        return -1;
      };
      _proto.toString = function toString() {
        var _this2 = this;
        var selector = [this.rawSpaceBefore, "["];
        selector.push(this._stringFor("qualifiedAttribute", "attribute"));
        if (this.operator && (this.value || this.value === "")) {
          selector.push(this._stringFor("operator"));
          selector.push(this._stringFor("value"));
          selector.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
            if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
              attrSpaces.before = " ";
            }
            return defaultAttrConcat(attrValue, attrSpaces);
          }));
        }
        selector.push("]");
        selector.push(this.rawSpaceAfter);
        return selector.join("");
      };
      _createClass(Attribute2, [{
        key: "quoted",
        get: function get() {
          var qm = this.quoteMark;
          return qm === "'" || qm === '"';
        },
        set: function set(value2) {
          warnOfDeprecatedQuotedAssignment();
        }
        /**
         * returns a single (`'`) or double (`"`) quote character if the value is quoted.
         * returns `null` if the value is not quoted.
         * returns `undefined` if the quotation state is unknown (this can happen when
         * the attribute is constructed without specifying a quote mark.)
         */
      }, {
        key: "quoteMark",
        get: function get() {
          return this._quoteMark;
        },
        set: function set(quoteMark) {
          if (!this._constructed) {
            this._quoteMark = quoteMark;
            return;
          }
          if (this._quoteMark !== quoteMark) {
            this._quoteMark = quoteMark;
            this._syncRawValue();
          }
        }
      }, {
        key: "qualifiedAttribute",
        get: function get() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function get() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        },
        set: (
          /**
           * Before 3.0, the value had to be set to an escaped value including any wrapped
           * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
           * is unescaped during parsing and any quote marks are removed.
           *
           * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
           * a deprecation warning is raised when the new value contains any characters that would
           * require escaping (including if it contains wrapped quotes).
           *
           * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
           * how the new value is quoted.
           */
          function set(v2) {
            if (this._constructed) {
              var _unescapeValue2 = unescapeValue(v2), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
              if (deprecatedUsage) {
                warnOfDeprecatedValueAssignment();
              }
              if (unescaped === this._value && quoteMark === this._quoteMark) {
                return;
              }
              this._value = unescaped;
              this._quoteMark = quoteMark;
              this._syncRawValue();
            } else {
              this._value = v2;
            }
          }
        )
      }, {
        key: "insensitive",
        get: function get() {
          return this._insensitive;
        },
        set: function set(insensitive) {
          if (!insensitive) {
            this._insensitive = false;
            if (this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i")) {
              this.raws.insensitiveFlag = void 0;
            }
          }
          this._insensitive = insensitive;
        }
      }, {
        key: "attribute",
        get: function get() {
          return this._attribute;
        },
        set: function set(name) {
          this._handleEscapes("attribute", name);
          this._attribute = name;
        }
      }]);
      return Attribute2;
    }(_namespace["default"]);
    exports["default"] = Attribute;
    Attribute.NO_QUOTE = null;
    Attribute.SINGLE_QUOTE = "'";
    Attribute.DOUBLE_QUOTE = '"';
    var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, _CSSESC_QUOTE_OPTIONS[null] = {
      isIdentifier: true
    }, _CSSESC_QUOTE_OPTIONS);
    function defaultAttrConcat(attrValue, attrSpaces) {
      return "" + attrSpaces.before + attrValue + attrSpaces.after;
    }
  }
});

// node_modules/postcss-selector-parser/dist/selectors/universal.js
var require_universal = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/universal.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _namespace = _interopRequireDefault(require_namespace());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Universal = /* @__PURE__ */ function(_Namespace) {
      _inheritsLoose(Universal2, _Namespace);
      function Universal2(opts) {
        var _this;
        _this = _Namespace.call(this, opts) || this;
        _this.type = _types.UNIVERSAL;
        _this.value = "*";
        return _this;
      }
      return Universal2;
    }(_namespace["default"]);
    exports["default"] = Universal;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/combinator.js
var require_combinator = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/combinator.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Combinator = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Combinator2, _Node);
      function Combinator2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.COMBINATOR;
        return _this;
      }
      return Combinator2;
    }(_node["default"]);
    exports["default"] = Combinator;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/nesting.js
var require_nesting = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/nesting.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _node = _interopRequireDefault(require_node2());
    var _types = require_types();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o5, p3) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p4) {
        o6.__proto__ = p4;
        return o6;
      };
      return _setPrototypeOf(o5, p3);
    }
    var Nesting = /* @__PURE__ */ function(_Node) {
      _inheritsLoose(Nesting2, _Node);
      function Nesting2(opts) {
        var _this;
        _this = _Node.call(this, opts) || this;
        _this.type = _types.NESTING;
        _this.value = "&";
        return _this;
      }
      return Nesting2;
    }(_node["default"]);
    exports["default"] = Nesting;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/sortAscending.js
var require_sortAscending = __commonJS({
  "node_modules/postcss-selector-parser/dist/sortAscending.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = sortAscending;
    function sortAscending(list3) {
      return list3.sort(function(a3, b3) {
        return a3 - b3;
      });
    }
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/tokenTypes.js
var require_tokenTypes = __commonJS({
  "node_modules/postcss-selector-parser/dist/tokenTypes.js"(exports) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports.word = exports.tilde = exports.tab = exports.str = exports.space = exports.slash = exports.singleQuote = exports.semicolon = exports.plus = exports.pipe = exports.openSquare = exports.openParenthesis = exports.newline = exports.greaterThan = exports.feed = exports.equals = exports.doubleQuote = exports.dollar = exports.cr = exports.comment = exports.comma = exports.combinator = exports.colon = exports.closeSquare = exports.closeParenthesis = exports.caret = exports.bang = exports.backslash = exports.at = exports.asterisk = exports.ampersand = void 0;
    var ampersand = 38;
    exports.ampersand = ampersand;
    var asterisk = 42;
    exports.asterisk = asterisk;
    var at = 64;
    exports.at = at;
    var comma = 44;
    exports.comma = comma;
    var colon = 58;
    exports.colon = colon;
    var semicolon = 59;
    exports.semicolon = semicolon;
    var openParenthesis = 40;
    exports.openParenthesis = openParenthesis;
    var closeParenthesis = 41;
    exports.closeParenthesis = closeParenthesis;
    var openSquare = 91;
    exports.openSquare = openSquare;
    var closeSquare = 93;
    exports.closeSquare = closeSquare;
    var dollar = 36;
    exports.dollar = dollar;
    var tilde = 126;
    exports.tilde = tilde;
    var caret = 94;
    exports.caret = caret;
    var plus = 43;
    exports.plus = plus;
    var equals = 61;
    exports.equals = equals;
    var pipe = 124;
    exports.pipe = pipe;
    var greaterThan = 62;
    exports.greaterThan = greaterThan;
    var space = 32;
    exports.space = space;
    var singleQuote = 39;
    exports.singleQuote = singleQuote;
    var doubleQuote = 34;
    exports.doubleQuote = doubleQuote;
    var slash = 47;
    exports.slash = slash;
    var bang = 33;
    exports.bang = bang;
    var backslash = 92;
    exports.backslash = backslash;
    var cr = 13;
    exports.cr = cr;
    var feed = 12;
    exports.feed = feed;
    var newline = 10;
    exports.newline = newline;
    var tab = 9;
    exports.tab = tab;
    var str = singleQuote;
    exports.str = str;
    var comment2 = -1;
    exports.comment = comment2;
    var word = -2;
    exports.word = word;
    var combinator = -3;
    exports.combinator = combinator;
  }
});

// node_modules/postcss-selector-parser/dist/tokenize.js
var require_tokenize2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/tokenize.js"(exports) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports.FIELDS = void 0;
    exports["default"] = tokenize2;
    var t5 = _interopRequireWildcard(require_tokenTypes());
    var _unescapable;
    var _wordDelimiters;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    var unescapable = (_unescapable = {}, _unescapable[t5.tab] = true, _unescapable[t5.newline] = true, _unescapable[t5.cr] = true, _unescapable[t5.feed] = true, _unescapable);
    var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t5.space] = true, _wordDelimiters[t5.tab] = true, _wordDelimiters[t5.newline] = true, _wordDelimiters[t5.cr] = true, _wordDelimiters[t5.feed] = true, _wordDelimiters[t5.ampersand] = true, _wordDelimiters[t5.asterisk] = true, _wordDelimiters[t5.bang] = true, _wordDelimiters[t5.comma] = true, _wordDelimiters[t5.colon] = true, _wordDelimiters[t5.semicolon] = true, _wordDelimiters[t5.openParenthesis] = true, _wordDelimiters[t5.closeParenthesis] = true, _wordDelimiters[t5.openSquare] = true, _wordDelimiters[t5.closeSquare] = true, _wordDelimiters[t5.singleQuote] = true, _wordDelimiters[t5.doubleQuote] = true, _wordDelimiters[t5.plus] = true, _wordDelimiters[t5.pipe] = true, _wordDelimiters[t5.tilde] = true, _wordDelimiters[t5.greaterThan] = true, _wordDelimiters[t5.equals] = true, _wordDelimiters[t5.dollar] = true, _wordDelimiters[t5.caret] = true, _wordDelimiters[t5.slash] = true, _wordDelimiters);
    var hex2 = {};
    var hexChars = "0123456789abcdefABCDEF";
    for (i5 = 0; i5 < hexChars.length; i5++) {
      hex2[hexChars.charCodeAt(i5)] = true;
    }
    var i5;
    function consumeWord(css, start) {
      var next = start;
      var code;
      do {
        code = css.charCodeAt(next);
        if (wordDelimiters[code]) {
          return next - 1;
        } else if (code === t5.backslash) {
          next = consumeEscape(css, next) + 1;
        } else {
          next++;
        }
      } while (next < css.length);
      return next - 1;
    }
    function consumeEscape(css, start) {
      var next = start;
      var code = css.charCodeAt(next + 1);
      if (unescapable[code]) {
      } else if (hex2[code]) {
        var hexDigits = 0;
        do {
          next++;
          hexDigits++;
          code = css.charCodeAt(next + 1);
        } while (hex2[code] && hexDigits < 6);
        if (hexDigits < 6 && code === t5.space) {
          next++;
        }
      } else {
        next++;
      }
      return next;
    }
    var FIELDS = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    exports.FIELDS = FIELDS;
    function tokenize2(input) {
      var tokens = [];
      var css = input.css.valueOf();
      var _css = css, length2 = _css.length;
      var offset = -1;
      var line = 1;
      var start = 0;
      var end = 0;
      var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
      function unclosed(what, fix) {
        if (input.safe) {
          css += fix;
          next = css.length - 1;
        } else {
          throw input.error("Unclosed " + what, line, start - offset, start);
        }
      }
      while (start < length2) {
        code = css.charCodeAt(start);
        if (code === t5.newline) {
          offset = start;
          line += 1;
        }
        switch (code) {
          case t5.space:
          case t5.tab:
          case t5.newline:
          case t5.cr:
          case t5.feed:
            next = start;
            do {
              next += 1;
              code = css.charCodeAt(next);
              if (code === t5.newline) {
                offset = next;
                line += 1;
              }
            } while (code === t5.space || code === t5.newline || code === t5.tab || code === t5.cr || code === t5.feed);
            tokenType = t5.space;
            endLine = line;
            endColumn = next - offset - 1;
            end = next;
            break;
          case t5.plus:
          case t5.greaterThan:
          case t5.tilde:
          case t5.pipe:
            next = start;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === t5.plus || code === t5.greaterThan || code === t5.tilde || code === t5.pipe);
            tokenType = t5.combinator;
            endLine = line;
            endColumn = start - offset;
            end = next;
            break;
          case t5.asterisk:
          case t5.ampersand:
          case t5.bang:
          case t5.comma:
          case t5.equals:
          case t5.dollar:
          case t5.caret:
          case t5.openSquare:
          case t5.closeSquare:
          case t5.colon:
          case t5.semicolon:
          case t5.openParenthesis:
          case t5.closeParenthesis:
            next = start;
            tokenType = code;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
            break;
          case t5.singleQuote:
          case t5.doubleQuote:
            quote = code === t5.singleQuote ? "'" : '"';
            next = start;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                unclosed("quote", quote);
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === t5.backslash) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            tokenType = t5.str;
            endLine = line;
            endColumn = start - offset;
            end = next + 1;
            break;
          default:
            if (code === t5.slash && css.charCodeAt(start + 1) === t5.asterisk) {
              next = css.indexOf("*/", start + 2) + 1;
              if (next === 0) {
                unclosed("comment", "*/");
              }
              content = css.slice(start, next + 1);
              lines = content.split("\n");
              last = lines.length - 1;
              if (last > 0) {
                nextLine = line + last;
                nextOffset = next - lines[last].length;
              } else {
                nextLine = line;
                nextOffset = offset;
              }
              tokenType = t5.comment;
              line = nextLine;
              endLine = nextLine;
              endColumn = next - nextOffset;
            } else if (code === t5.slash) {
              next = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
            } else {
              next = consumeWord(css, start);
              tokenType = t5.word;
              endLine = line;
              endColumn = next - offset;
            }
            end = next + 1;
            break;
        }
        tokens.push([
          tokenType,
          // [0] Token type
          line,
          // [1] Starting line
          start - offset,
          // [2] Starting column
          endLine,
          // [3] Ending line
          endColumn,
          // [4] Ending column
          start,
          // [5] Start position / Source index
          end
          // [6] End position
        ]);
        if (nextOffset) {
          offset = nextOffset;
          nextOffset = null;
        }
        start = end;
      }
      return tokens;
    }
  }
});

// node_modules/postcss-selector-parser/dist/parser.js
var require_parser2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/parser.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _root = _interopRequireDefault(require_root2());
    var _selector = _interopRequireDefault(require_selector());
    var _className = _interopRequireDefault(require_className());
    var _comment = _interopRequireDefault(require_comment2());
    var _id = _interopRequireDefault(require_id());
    var _tag = _interopRequireDefault(require_tag());
    var _string = _interopRequireDefault(require_string());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _attribute = _interopRequireWildcard(require_attribute());
    var _universal = _interopRequireDefault(require_universal());
    var _combinator = _interopRequireDefault(require_combinator());
    var _nesting = _interopRequireDefault(require_nesting());
    var _sortAscending = _interopRequireDefault(require_sortAscending());
    var _tokenize = _interopRequireWildcard(require_tokenize2());
    var tokens = _interopRequireWildcard(require_tokenTypes());
    var types2 = _interopRequireWildcard(require_types());
    var _util = require_util();
    var _WHITESPACE_TOKENS;
    var _Object$assign;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _defineProperties(target, props) {
      for (var i5 = 0; i5 < props.length; i5++) {
        var descriptor = props[i5];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
    var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
    function tokenStart(token) {
      return {
        line: token[_tokenize.FIELDS.START_LINE],
        column: token[_tokenize.FIELDS.START_COL]
      };
    }
    function tokenEnd(token) {
      return {
        line: token[_tokenize.FIELDS.END_LINE],
        column: token[_tokenize.FIELDS.END_COL]
      };
    }
    function getSource(startLine, startColumn, endLine, endColumn) {
      return {
        start: {
          line: startLine,
          column: startColumn
        },
        end: {
          line: endLine,
          column: endColumn
        }
      };
    }
    function getTokenSource(token) {
      return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
    }
    function getTokenSourceSpan(startToken, endToken) {
      if (!startToken) {
        return void 0;
      }
      return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
    }
    function unescapeProp(node, prop) {
      var value2 = node[prop];
      if (typeof value2 !== "string") {
        return;
      }
      if (value2.indexOf("\\") !== -1) {
        (0, _util.ensureObject)(node, "raws");
        node[prop] = (0, _util.unesc)(value2);
        if (node.raws[prop] === void 0) {
          node.raws[prop] = value2;
        }
      }
      return node;
    }
    function indexesOf(array, item) {
      var i5 = -1;
      var indexes = [];
      while ((i5 = array.indexOf(item, i5 + 1)) !== -1) {
        indexes.push(i5);
      }
      return indexes;
    }
    function uniqs() {
      var list3 = Array.prototype.concat.apply([], arguments);
      return list3.filter(function(item, i5) {
        return i5 === list3.indexOf(item);
      });
    }
    var Parser = /* @__PURE__ */ function() {
      function Parser2(rule2, options) {
        if (options === void 0) {
          options = {};
        }
        this.rule = rule2;
        this.options = Object.assign({
          lossy: false,
          safe: false
        }, options);
        this.position = 0;
        this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
        this.tokens = (0, _tokenize["default"])({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new _root["default"]({
          source: rootSource
        });
        this.root.errorGenerator = this._errorGenerator();
        var selector = new _selector["default"]({
          source: {
            start: {
              line: 1,
              column: 1
            }
          }
        });
        this.root.append(selector);
        this.current = selector;
        this.loop();
      }
      var _proto = Parser2.prototype;
      _proto._errorGenerator = function _errorGenerator() {
        var _this = this;
        return function(message, errorOptions) {
          if (typeof _this.rule === "string") {
            return new Error(message);
          }
          return _this.rule.error(message, errorOptions);
        };
      };
      _proto.attribute = function attribute() {
        var attr = [];
        var startingToken = this.currToken;
        this.position++;
        while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          attr.push(this.currToken);
          this.position++;
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
          return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        }
        var len = attr.length;
        var node = {
          source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        };
        if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
          return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
        }
        var pos = 0;
        var spaceBefore = "";
        var commentBefore = "";
        var lastAdded = null;
        var spaceAfterMeaningfulToken = false;
        while (pos < len) {
          var token = attr[pos];
          var content = this.content(token);
          var next = attr[pos + 1];
          switch (token[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              spaceAfterMeaningfulToken = true;
              if (this.options.lossy) {
                break;
              }
              if (lastAdded) {
                (0, _util.ensureObject)(node, "spaces", lastAdded);
                var prevContent = node.spaces[lastAdded].after || "";
                node.spaces[lastAdded].after = prevContent + content;
                var existingComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || null;
                if (existingComment) {
                  node.raws.spaces[lastAdded].after = existingComment + content;
                }
              } else {
                spaceBefore = spaceBefore + content;
                commentBefore = commentBefore + content;
              }
              break;
            case tokens.asterisk:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = spaceBefore;
                  commentBefore = "";
                }
                node.namespace = (node.namespace || "") + content;
                var rawValue = (0, _util.getProp)(node, "raws", "namespace") || null;
                if (rawValue) {
                  node.raws.namespace += content;
                }
                lastAdded = "namespace";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.dollar:
              if (lastAdded === "value") {
                var oldRawValue = (0, _util.getProp)(node, "raws", "value");
                node.value += "$";
                if (oldRawValue) {
                  node.raws.value = oldRawValue + "$";
                }
                break;
              }
            case tokens.caret:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.combinator:
              if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              }
              if (content !== "|") {
                spaceAfterMeaningfulToken = false;
                break;
              }
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                node.operator = content;
                lastAdded = "operator";
              } else if (!node.namespace && !node.attribute) {
                node.namespace = true;
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.word:
              if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
              !node.operator && !node.namespace) {
                node.namespace = content;
                lastAdded = "namespace";
              } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                if (spaceBefore) {
                  (0, _util.ensureObject)(node, "spaces", "attribute");
                  node.spaces.attribute.before = spaceBefore;
                  spaceBefore = "";
                }
                if (commentBefore) {
                  (0, _util.ensureObject)(node, "raws", "spaces", "attribute");
                  node.raws.spaces.attribute.before = commentBefore;
                  commentBefore = "";
                }
                node.attribute = (node.attribute || "") + content;
                var _rawValue = (0, _util.getProp)(node, "raws", "attribute") || null;
                if (_rawValue) {
                  node.raws.attribute += content;
                }
                lastAdded = "attribute";
              } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
                var _unescaped = (0, _util.unesc)(content);
                var _oldRawValue = (0, _util.getProp)(node, "raws", "value") || "";
                var oldValue = node.value || "";
                node.value = oldValue + _unescaped;
                node.quoteMark = null;
                if (_unescaped !== content || _oldRawValue) {
                  (0, _util.ensureObject)(node, "raws");
                  node.raws.value = (_oldRawValue || oldValue) + content;
                }
                lastAdded = "value";
              } else {
                var insensitive = content === "i" || content === "I";
                if ((node.value || node.value === "") && (node.quoteMark || spaceAfterMeaningfulToken)) {
                  node.insensitive = insensitive;
                  if (!insensitive || content === "I") {
                    (0, _util.ensureObject)(node, "raws");
                    node.raws.insensitiveFlag = content;
                  }
                  lastAdded = "insensitive";
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node, "spaces", "insensitive");
                    node.spaces.insensitive.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node, "raws", "spaces", "insensitive");
                    node.raws.spaces.insensitive.before = commentBefore;
                    commentBefore = "";
                  }
                } else if (node.value || node.value === "") {
                  lastAdded = "value";
                  node.value += content;
                  if (node.raws.value) {
                    node.raws.value += content;
                  }
                }
              }
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.str:
              if (!node.attribute || !node.operator) {
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
              node.value = unescaped;
              node.quoteMark = quoteMark;
              lastAdded = "value";
              (0, _util.ensureObject)(node, "raws");
              node.raws.value = content;
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.equals:
              if (!node.attribute) {
                return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
              }
              if (node.value) {
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
              }
              node.operator = node.operator ? node.operator + content : content;
              lastAdded = "operator";
              spaceAfterMeaningfulToken = false;
              break;
            case tokens.comment:
              if (lastAdded) {
                if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                  var lastComment = (0, _util.getProp)(node, "spaces", lastAdded, "after") || "";
                  var rawLastComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || lastComment;
                  (0, _util.ensureObject)(node, "raws", "spaces", lastAdded);
                  node.raws.spaces[lastAdded].after = rawLastComment + content;
                } else {
                  var lastValue = node[lastAdded] || "";
                  var rawLastValue = (0, _util.getProp)(node, "raws", lastAdded) || lastValue;
                  (0, _util.ensureObject)(node, "raws");
                  node.raws[lastAdded] = rawLastValue + content;
                }
              } else {
                commentBefore = commentBefore + content;
              }
              break;
            default:
              return this.error('Unexpected "' + content + '" found.', {
                index: token[_tokenize.FIELDS.START_POS]
              });
          }
          pos++;
        }
        unescapeProp(node, "attribute");
        unescapeProp(node, "namespace");
        this.newNode(new _attribute["default"](node));
        this.position++;
      };
      _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
        if (stopPosition < 0) {
          stopPosition = this.tokens.length;
        }
        var startPosition = this.position;
        var nodes = [];
        var space = "";
        var lastComment = void 0;
        do {
          if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
            if (!this.options.lossy) {
              space += this.content();
            }
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
            var spaces = {};
            if (space) {
              spaces.before = space;
              space = "";
            }
            lastComment = new _comment["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              spaces
            });
            nodes.push(lastComment);
          }
        } while (++this.position < stopPosition);
        if (space) {
          if (lastComment) {
            lastComment.spaces.after = space;
          } else if (!this.options.lossy) {
            var firstToken = this.tokens[startPosition];
            var lastToken = this.tokens[this.position - 1];
            nodes.push(new _string["default"]({
              value: "",
              source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: {
                before: space,
                after: ""
              }
            }));
          }
        }
        return nodes;
      };
      _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
        var _this2 = this;
        if (requiredSpace === void 0) {
          requiredSpace = false;
        }
        var space = "";
        var rawSpace = "";
        nodes.forEach(function(n4) {
          var spaceBefore = _this2.lossySpace(n4.spaces.before, requiredSpace);
          var rawSpaceBefore = _this2.lossySpace(n4.rawSpaceBefore, requiredSpace);
          space += spaceBefore + _this2.lossySpace(n4.spaces.after, requiredSpace && spaceBefore.length === 0);
          rawSpace += spaceBefore + n4.value + _this2.lossySpace(n4.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
        });
        if (rawSpace === space) {
          rawSpace = void 0;
        }
        var result = {
          space,
          rawSpace
        };
        return result;
      };
      _proto.isNamedCombinator = function isNamedCombinator(position2) {
        if (position2 === void 0) {
          position2 = this.position;
        }
        return this.tokens[position2 + 0] && this.tokens[position2 + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position2 + 1] && this.tokens[position2 + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position2 + 2] && this.tokens[position2 + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
      };
      _proto.namedCombinator = function namedCombinator() {
        if (this.isNamedCombinator()) {
          var nameRaw = this.content(this.tokens[this.position + 1]);
          var name = (0, _util.unesc)(nameRaw).toLowerCase();
          var raws = {};
          if (name !== nameRaw) {
            raws.value = "/" + nameRaw + "/";
          }
          var node = new _combinator["default"]({
            value: "/" + name + "/",
            source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
            raws
          });
          this.position = this.position + 3;
          return node;
        } else {
          this.unexpected();
        }
      };
      _proto.combinator = function combinator() {
        var _this3 = this;
        if (this.content() === "|") {
          return this.namespace();
        }
        var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
          var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          if (nodes.length > 0) {
            var last = this.current.last;
            if (last) {
              var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
              if (rawSpace !== void 0) {
                last.rawSpaceAfter += rawSpace;
              }
              last.spaces.after += space;
            } else {
              nodes.forEach(function(n4) {
                return _this3.newNode(n4);
              });
            }
          }
          return;
        }
        var firstToken = this.currToken;
        var spaceOrDescendantSelectorNodes = void 0;
        if (nextSigTokenPos > this.position) {
          spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
        }
        var node;
        if (this.isNamedCombinator()) {
          node = this.namedCombinator();
        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
          node = new _combinator["default"]({
            value: this.content(),
            source: getTokenSource(this.currToken),
            sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
          });
          this.position++;
        } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        } else if (!spaceOrDescendantSelectorNodes) {
          this.unexpected();
        }
        if (node) {
          if (spaceOrDescendantSelectorNodes) {
            var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
            node.spaces.before = _space;
            node.rawSpaceBefore = _rawSpace;
          }
        } else {
          var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
          if (!_rawSpace2) {
            _rawSpace2 = _space2;
          }
          var spaces = {};
          var raws = {
            spaces: {}
          };
          if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
            spaces.before = _space2.slice(0, _space2.length - 1);
            raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
          } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
            spaces.after = _space2.slice(1);
            raws.spaces.after = _rawSpace2.slice(1);
          } else {
            raws.value = _rawSpace2;
          }
          node = new _combinator["default"]({
            value: " ",
            source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
            sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
            spaces,
            raws
          });
        }
        if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
          node.spaces.after = this.optionalSpace(this.content());
          this.position++;
        }
        return this.newNode(node);
      };
      _proto.comma = function comma() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true;
          this.position++;
          return;
        }
        this.current._inferEndPosition();
        var selector = new _selector["default"]({
          source: {
            start: tokenStart(this.tokens[this.position + 1])
          }
        });
        this.current.parent.append(selector);
        this.current = selector;
        this.position++;
      };
      _proto.comment = function comment2() {
        var current = this.currToken;
        this.newNode(new _comment["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.error = function error(message, opts) {
        throw this.root.error(message, opts);
      };
      _proto.missingBackslash = function missingBackslash() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[_tokenize.FIELDS.START_POS]
        });
      };
      _proto.missingParenthesis = function missingParenthesis() {
        return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.missingSquareBracket = function missingSquareBracket() {
        return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.unexpected = function unexpected() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.unexpectedPipe = function unexpectedPipe() {
        return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
      };
      _proto.namespace = function namespace() {
        var before = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.position++;
          return this.word(before);
        } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
          this.position++;
          return this.universal(before);
        }
        this.unexpectedPipe();
      };
      _proto.nesting = function nesting() {
        if (this.nextToken) {
          var nextContent = this.content(this.nextToken);
          if (nextContent === "|") {
            this.position++;
            return;
          }
        }
        var current = this.currToken;
        this.newNode(new _nesting["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.parentheses = function parentheses() {
        var last = this.current.last;
        var unbalanced = 1;
        this.position++;
        if (last && last.type === types2.PSEUDO) {
          var selector = new _selector["default"]({
            source: {
              start: tokenStart(this.tokens[this.position - 1])
            }
          });
          var cache2 = this.current;
          last.append(selector);
          this.current = selector;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            if (unbalanced) {
              this.parse();
            } else {
              this.current.source.end = tokenEnd(this.currToken);
              this.current.parent.source.end = tokenEnd(this.currToken);
              this.position++;
            }
          }
          this.current = cache2;
        } else {
          var parenStart = this.currToken;
          var parenValue = "(";
          var parenEnd;
          while (this.position < this.tokens.length && unbalanced) {
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              unbalanced++;
            }
            if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
              unbalanced--;
            }
            parenEnd = this.currToken;
            parenValue += this.parseParenthesisToken(this.currToken);
            this.position++;
          }
          if (last) {
            last.appendToPropertyAndEscape("value", parenValue, parenValue);
          } else {
            this.newNode(new _string["default"]({
              value: parenValue,
              source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
              sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
            }));
          }
        }
        if (unbalanced) {
          return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.pseudo = function pseudo() {
        var _this4 = this;
        var pseudoStr = "";
        var startingToken = this.currToken;
        while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
          pseudoStr += this.content();
          this.position++;
        }
        if (!this.currToken) {
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        }
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
          this.splitWord(false, function(first, length2) {
            pseudoStr += first;
            _this4.newNode(new _pseudo["default"]({
              value: pseudoStr,
              source: getTokenSourceSpan(startingToken, _this4.currToken),
              sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
            }));
            if (length2 > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
              _this4.error("Misplaced parenthesis.", {
                index: _this4.nextToken[_tokenize.FIELDS.START_POS]
              });
            }
          });
        } else {
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
        }
      };
      _proto.space = function space() {
        var content = this.content();
        if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node) {
          return node.type === "comment";
        })) {
          this.spaces = this.optionalSpace(content);
          this.position++;
        } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          this.current.last.spaces.after = this.optionalSpace(content);
          this.position++;
        } else {
          this.combinator();
        }
      };
      _proto.string = function string() {
        var current = this.currToken;
        this.newNode(new _string["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }));
        this.position++;
      };
      _proto.universal = function universal(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        var current = this.currToken;
        this.newNode(new _universal["default"]({
          value: this.content(),
          source: getTokenSource(current),
          sourceIndex: current[_tokenize.FIELDS.START_POS]
        }), namespace);
        this.position++;
      };
      _proto.splitWord = function splitWord(namespace, firstCallback) {
        var _this5 = this;
        var nextToken = this.nextToken;
        var word = this.content();
        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
          this.position++;
          var current = this.content();
          word += current;
          if (current.lastIndexOf("\\") === current.length - 1) {
            var next = this.nextToken;
            if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
              word += this.requiredSpace(this.content(next));
              this.position++;
            }
          }
          nextToken = this.nextToken;
        }
        var hasClass = indexesOf(word, ".").filter(function(i5) {
          var escapedDot = word[i5 - 1] === "\\";
          var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
          return !escapedDot && !isKeyframesPercent;
        });
        var hasId = indexesOf(word, "#").filter(function(i5) {
          return word[i5 - 1] !== "\\";
        });
        var interpolations = indexesOf(word, "#{");
        if (interpolations.length) {
          hasId = hasId.filter(function(hashIndex) {
            return !~interpolations.indexOf(hashIndex);
          });
        }
        var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
        indices.forEach(function(ind, i5) {
          var index2 = indices[i5 + 1] || word.length;
          var value2 = word.slice(ind, index2);
          if (i5 === 0 && firstCallback) {
            return firstCallback.call(_this5, value2, indices.length);
          }
          var node;
          var current2 = _this5.currToken;
          var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i5];
          var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index2 - 1));
          if (~hasClass.indexOf(ind)) {
            var classNameOpts = {
              value: value2.slice(1),
              source,
              sourceIndex
            };
            node = new _className["default"](unescapeProp(classNameOpts, "value"));
          } else if (~hasId.indexOf(ind)) {
            var idOpts = {
              value: value2.slice(1),
              source,
              sourceIndex
            };
            node = new _id["default"](unescapeProp(idOpts, "value"));
          } else {
            var tagOpts = {
              value: value2,
              source,
              sourceIndex
            };
            unescapeProp(tagOpts, "value");
            node = new _tag["default"](tagOpts);
          }
          _this5.newNode(node, namespace);
          namespace = null;
        });
        this.position++;
      };
      _proto.word = function word(namespace) {
        var nextToken = this.nextToken;
        if (nextToken && this.content(nextToken) === "|") {
          this.position++;
          return this.namespace();
        }
        return this.splitWord(namespace);
      };
      _proto.loop = function loop() {
        while (this.position < this.tokens.length) {
          this.parse(true);
        }
        this.current._inferEndPosition();
        return this.root;
      };
      _proto.parse = function parse6(throwOnParenthesis) {
        switch (this.currToken[_tokenize.FIELDS.TYPE]) {
          case tokens.space:
            this.space();
            break;
          case tokens.comment:
            this.comment();
            break;
          case tokens.openParenthesis:
            this.parentheses();
            break;
          case tokens.closeParenthesis:
            if (throwOnParenthesis) {
              this.missingParenthesis();
            }
            break;
          case tokens.openSquare:
            this.attribute();
            break;
          case tokens.dollar:
          case tokens.caret:
          case tokens.equals:
          case tokens.word:
            this.word();
            break;
          case tokens.colon:
            this.pseudo();
            break;
          case tokens.comma:
            this.comma();
            break;
          case tokens.asterisk:
            this.universal();
            break;
          case tokens.ampersand:
            this.nesting();
            break;
          case tokens.slash:
          case tokens.combinator:
            this.combinator();
            break;
          case tokens.str:
            this.string();
            break;
          case tokens.closeSquare:
            this.missingSquareBracket();
          case tokens.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      };
      _proto.expected = function expected(description, index2, found) {
        if (Array.isArray(description)) {
          var last = description.pop();
          description = description.join(", ") + " or " + last;
        }
        var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
        if (!found) {
          return this.error("Expected " + an + " " + description + ".", {
            index: index2
          });
        }
        return this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
          index: index2
        });
      };
      _proto.requiredSpace = function requiredSpace(space) {
        return this.options.lossy ? " " : space;
      };
      _proto.optionalSpace = function optionalSpace(space) {
        return this.options.lossy ? "" : space;
      };
      _proto.lossySpace = function lossySpace(space, required) {
        if (this.options.lossy) {
          return required ? " " : "";
        } else {
          return space;
        }
      };
      _proto.parseParenthesisToken = function parseParenthesisToken(token) {
        var content = this.content(token);
        if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
          return this.requiredSpace(content);
        } else {
          return content;
        }
      };
      _proto.newNode = function newNode(node, namespace) {
        if (namespace) {
          if (/^ +$/.test(namespace)) {
            if (!this.options.lossy) {
              this.spaces = (this.spaces || "") + namespace;
            }
            namespace = true;
          }
          node.namespace = namespace;
          unescapeProp(node, "namespace");
        }
        if (this.spaces) {
          node.spaces.before = this.spaces;
          this.spaces = "";
        }
        return this.current.append(node);
      };
      _proto.content = function content(token) {
        if (token === void 0) {
          token = this.currToken;
        }
        return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
      };
      _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
        if (startPosition === void 0) {
          startPosition = this.position + 1;
        }
        var searchPosition = startPosition;
        while (searchPosition < this.tokens.length) {
          if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
            searchPosition++;
            continue;
          } else {
            return searchPosition;
          }
        }
        return -1;
      };
      _createClass(Parser2, [{
        key: "currToken",
        get: function get() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function get() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function get() {
          return this.tokens[this.position - 1];
        }
      }]);
      return Parser2;
    }();
    exports["default"] = Parser;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/processor.js
var require_processor2 = __commonJS({
  "node_modules/postcss-selector-parser/dist/processor.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _parser = _interopRequireDefault(require_parser2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var Processor3 = /* @__PURE__ */ function() {
      function Processor4(func, options) {
        this.func = func || function noop2() {
        };
        this.funcRes = null;
        this.options = options;
      }
      var _proto = Processor4.prototype;
      _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule2, options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.updateSelector === false) {
          return false;
        } else {
          return typeof rule2 !== "string";
        }
      };
      _proto._isLossy = function _isLossy(options) {
        if (options === void 0) {
          options = {};
        }
        var merged = Object.assign({}, this.options, options);
        if (merged.lossless === false) {
          return true;
        } else {
          return false;
        }
      };
      _proto._root = function _root(rule2, options) {
        if (options === void 0) {
          options = {};
        }
        var parser4 = new _parser["default"](rule2, this._parseOptions(options));
        return parser4.root;
      };
      _proto._parseOptions = function _parseOptions(options) {
        return {
          lossy: this._isLossy(options)
        };
      };
      _proto._run = function _run(rule2, options) {
        var _this = this;
        if (options === void 0) {
          options = {};
        }
        return new Promise(function(resolve2, reject) {
          try {
            var root2 = _this._root(rule2, options);
            Promise.resolve(_this.func(root2)).then(function(transform) {
              var string = void 0;
              if (_this._shouldUpdateSelector(rule2, options)) {
                string = root2.toString();
                rule2.selector = string;
              }
              return {
                transform,
                root: root2,
                string
              };
            }).then(resolve2, reject);
          } catch (e4) {
            reject(e4);
            return;
          }
        });
      };
      _proto._runSync = function _runSync(rule2, options) {
        if (options === void 0) {
          options = {};
        }
        var root2 = this._root(rule2, options);
        var transform = this.func(root2);
        if (transform && typeof transform.then === "function") {
          throw new Error("Selector processor returned a promise to a synchronous call.");
        }
        var string = void 0;
        if (options.updateSelector && typeof rule2 !== "string") {
          string = root2.toString();
          rule2.selector = string;
        }
        return {
          transform,
          root: root2,
          string
        };
      };
      _proto.ast = function ast(rule2, options) {
        return this._run(rule2, options).then(function(result) {
          return result.root;
        });
      };
      _proto.astSync = function astSync(rule2, options) {
        return this._runSync(rule2, options).root;
      };
      _proto.transform = function transform(rule2, options) {
        return this._run(rule2, options).then(function(result) {
          return result.transform;
        });
      };
      _proto.transformSync = function transformSync(rule2, options) {
        return this._runSync(rule2, options).transform;
      };
      _proto.process = function process2(rule2, options) {
        return this._run(rule2, options).then(function(result) {
          return result.string || result.root.toString();
        });
      };
      _proto.processSync = function processSync(rule2, options) {
        var result = this._runSync(rule2, options);
        return result.string || result.root.toString();
      };
      return Processor4;
    }();
    exports["default"] = Processor3;
    module.exports = exports.default;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/constructors.js
var require_constructors = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/constructors.js"(exports) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;
    var _attribute = _interopRequireDefault(require_attribute());
    var _className = _interopRequireDefault(require_className());
    var _combinator = _interopRequireDefault(require_combinator());
    var _comment = _interopRequireDefault(require_comment2());
    var _id = _interopRequireDefault(require_id());
    var _nesting = _interopRequireDefault(require_nesting());
    var _pseudo = _interopRequireDefault(require_pseudo());
    var _root = _interopRequireDefault(require_root2());
    var _selector = _interopRequireDefault(require_selector());
    var _string = _interopRequireDefault(require_string());
    var _tag = _interopRequireDefault(require_tag());
    var _universal = _interopRequireDefault(require_universal());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var attribute = function attribute2(opts) {
      return new _attribute["default"](opts);
    };
    exports.attribute = attribute;
    var className = function className2(opts) {
      return new _className["default"](opts);
    };
    exports.className = className;
    var combinator = function combinator2(opts) {
      return new _combinator["default"](opts);
    };
    exports.combinator = combinator;
    var comment2 = function comment3(opts) {
      return new _comment["default"](opts);
    };
    exports.comment = comment2;
    var id = function id2(opts) {
      return new _id["default"](opts);
    };
    exports.id = id;
    var nesting = function nesting2(opts) {
      return new _nesting["default"](opts);
    };
    exports.nesting = nesting;
    var pseudo = function pseudo2(opts) {
      return new _pseudo["default"](opts);
    };
    exports.pseudo = pseudo;
    var root2 = function root3(opts) {
      return new _root["default"](opts);
    };
    exports.root = root2;
    var selector = function selector2(opts) {
      return new _selector["default"](opts);
    };
    exports.selector = selector;
    var string = function string2(opts) {
      return new _string["default"](opts);
    };
    exports.string = string;
    var tag = function tag2(opts) {
      return new _tag["default"](opts);
    };
    exports.tag = tag;
    var universal = function universal2(opts) {
      return new _universal["default"](opts);
    };
    exports.universal = universal;
  }
});

// node_modules/postcss-selector-parser/dist/selectors/guards.js
var require_guards = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/guards.js"(exports) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;
    exports.isContainer = isContainer;
    exports.isIdentifier = void 0;
    exports.isNamespace = isNamespace;
    exports.isNesting = void 0;
    exports.isNode = isNode;
    exports.isPseudo = void 0;
    exports.isPseudoClass = isPseudoClass;
    exports.isPseudoElement = isPseudoElement2;
    exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = void 0;
    var _types = require_types();
    var _IS_TYPE;
    var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
    function isNode(node) {
      return typeof node === "object" && IS_TYPE[node.type];
    }
    function isNodeType(type, node) {
      return isNode(node) && node.type === type;
    }
    var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
    exports.isAttribute = isAttribute;
    var isClassName = isNodeType.bind(null, _types.CLASS);
    exports.isClassName = isClassName;
    var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
    exports.isCombinator = isCombinator;
    var isComment = isNodeType.bind(null, _types.COMMENT);
    exports.isComment = isComment;
    var isIdentifier = isNodeType.bind(null, _types.ID);
    exports.isIdentifier = isIdentifier;
    var isNesting = isNodeType.bind(null, _types.NESTING);
    exports.isNesting = isNesting;
    var isPseudo = isNodeType.bind(null, _types.PSEUDO);
    exports.isPseudo = isPseudo;
    var isRoot2 = isNodeType.bind(null, _types.ROOT);
    exports.isRoot = isRoot2;
    var isSelector = isNodeType.bind(null, _types.SELECTOR);
    exports.isSelector = isSelector;
    var isString = isNodeType.bind(null, _types.STRING);
    exports.isString = isString;
    var isTag = isNodeType.bind(null, _types.TAG);
    exports.isTag = isTag;
    var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
    exports.isUniversal = isUniversal;
    function isPseudoElement2(node) {
      return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
    }
    function isPseudoClass(node) {
      return isPseudo(node) && !isPseudoElement2(node);
    }
    function isContainer(node) {
      return !!(isNode(node) && node.walk);
    }
    function isNamespace(node) {
      return isAttribute(node) || isTag(node);
    }
  }
});

// node_modules/postcss-selector-parser/dist/selectors/index.js
var require_selectors = __commonJS({
  "node_modules/postcss-selector-parser/dist/selectors/index.js"(exports) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _types[key])
        return;
      exports[key] = _types[key];
    });
    var _constructors = require_constructors();
    Object.keys(_constructors).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _constructors[key])
        return;
      exports[key] = _constructors[key];
    });
    var _guards = require_guards();
    Object.keys(_guards).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _guards[key])
        return;
      exports[key] = _guards[key];
    });
  }
});

// node_modules/postcss-selector-parser/dist/index.js
var require_dist = __commonJS({
  "node_modules/postcss-selector-parser/dist/index.js"(exports, module) {
    "use strict";
    init_shim();
    exports.__esModule = true;
    exports["default"] = void 0;
    var _processor = _interopRequireDefault(require_processor2());
    var selectors = _interopRequireWildcard(require_selectors());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var parser4 = function parser5(processor) {
      return new _processor["default"](processor);
    };
    Object.assign(parser4, selectors);
    delete parser4.__esModule;
    var _default = parser4;
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/@mhsdesign/jit-browser-tailwindcss/node_modules/postcss-nested/index.js
var require_postcss_nested = __commonJS({
  "node_modules/@mhsdesign/jit-browser-tailwindcss/node_modules/postcss-nested/index.js"(exports, module) {
    "use strict";
    init_shim();
    var parser4 = require_dist();
    function parse6(str, rule2) {
      let nodes;
      let saver = parser4((parsed) => {
        nodes = parsed;
      });
      try {
        saver.processSync(str);
      } catch (e4) {
        if (str.includes(":")) {
          throw rule2 ? rule2.error("Missed semicolon") : e4;
        } else {
          throw rule2 ? rule2.error(e4.message) : e4;
        }
      }
      return nodes.at(0);
    }
    function replace(nodes, parent) {
      let replaced = false;
      nodes.each((i5) => {
        if (i5.type === "nesting") {
          let clonedParent = parent.clone();
          if (i5.value !== "&") {
            i5.replaceWith(parse6(i5.value.replace("&", clonedParent.toString())));
          } else {
            i5.replaceWith(clonedParent);
          }
          replaced = true;
        } else if (i5.nodes) {
          if (replace(i5, parent)) {
            replaced = true;
          }
        }
      });
      return replaced;
    }
    function selectors(parent, child) {
      let result = [];
      parent.selectors.forEach((i5) => {
        let parentNode = parse6(i5, parent);
        child.selectors.forEach((j2) => {
          if (j2.length) {
            let node = parse6(j2, child);
            let replaced = replace(node, parentNode);
            if (!replaced) {
              node.prepend(parser4.combinator({ value: " " }));
              node.prepend(parentNode.clone());
            }
            result.push(node.toString());
          }
        });
      });
      return result;
    }
    function pickComment(comment2, after) {
      if (comment2 && comment2.type === "comment") {
        after.after(comment2);
        return comment2;
      } else {
        return after;
      }
    }
    function createFnAtruleChilds(bubble) {
      return function atruleChilds(rule2, atrule, bubbling) {
        let children = [];
        atrule.each((child) => {
          if (child.type === "comment") {
            children.push(child);
          } else if (child.type === "decl") {
            children.push(child);
          } else if (child.type === "rule" && bubbling) {
            child.selectors = selectors(rule2, child);
          } else if (child.type === "atrule") {
            if (child.nodes && bubble[child.name]) {
              atruleChilds(rule2, child, true);
            } else {
              children.push(child);
            }
          }
        });
        if (bubbling) {
          if (children.length) {
            let clone = rule2.clone({ nodes: [] });
            for (let child of children) {
              clone.append(child);
            }
            atrule.prepend(clone);
          }
        }
      };
    }
    function pickDeclarations(selector, declarations, after, Rule2) {
      let parent = new Rule2({
        selector,
        nodes: []
      });
      for (let declaration of declarations) {
        parent.append(declaration);
      }
      after.after(parent);
      return parent;
    }
    function atruleNames(defaults3, custom) {
      let list3 = {};
      for (let i5 of defaults3) {
        list3[i5] = true;
      }
      if (custom) {
        for (let i5 of custom) {
          let name = i5.replace(/^@/, "");
          list3[name] = true;
        }
      }
      return list3;
    }
    module.exports = (opts = {}) => {
      let bubble = atruleNames(["media", "supports"], opts.bubble);
      let atruleChilds = createFnAtruleChilds(bubble);
      let unwrap = atruleNames(
        [
          "document",
          "font-face",
          "keyframes",
          "-webkit-keyframes",
          "-moz-keyframes"
        ],
        opts.unwrap
      );
      let preserveEmpty = opts.preserveEmpty;
      return {
        postcssPlugin: "postcss-nested",
        Rule(rule2, { Rule: Rule2 }) {
          let unwrapped = false;
          let after = rule2;
          let copyDeclarations = false;
          let declarations = [];
          rule2.each((child) => {
            if (child.type === "rule") {
              if (declarations.length) {
                after = pickDeclarations(rule2.selector, declarations, after, Rule2);
                declarations = [];
              }
              copyDeclarations = true;
              unwrapped = true;
              child.selectors = selectors(rule2, child);
              after = pickComment(child.prev(), after);
              after.after(child);
              after = child;
            } else if (child.type === "atrule") {
              if (declarations.length) {
                after = pickDeclarations(rule2.selector, declarations, after, Rule2);
                declarations = [];
              }
              if (child.name === "at-root") {
                unwrapped = true;
                atruleChilds(rule2, child, false);
                let nodes = child.nodes;
                if (child.params) {
                  nodes = new Rule2({ selector: child.params, nodes });
                }
                after.after(nodes);
                after = nodes;
                child.remove();
              } else if (bubble[child.name]) {
                copyDeclarations = true;
                unwrapped = true;
                atruleChilds(rule2, child, true);
                after = pickComment(child.prev(), after);
                after.after(child);
                after = child;
              } else if (unwrap[child.name]) {
                copyDeclarations = true;
                unwrapped = true;
                atruleChilds(rule2, child, false);
                after = pickComment(child.prev(), after);
                after.after(child);
                after = child;
              } else if (copyDeclarations) {
                declarations.push(child);
              }
            } else if (child.type === "decl" && copyDeclarations) {
              declarations.push(child);
            }
          });
          if (declarations.length) {
            after = pickDeclarations(rule2.selector, declarations, after, Rule2);
          }
          if (unwrapped && preserveEmpty !== true) {
            rule2.raws.semicolon = true;
            if (rule2.nodes.length === 0)
              rule2.remove();
          }
        }
      };
    };
    module.exports.postcss = true;
  }
});

// node_modules/camelcase-css/index-es5.js
var require_index_es5 = __commonJS({
  "node_modules/camelcase-css/index-es5.js"(exports, module) {
    "use strict";
    init_shim();
    var pattern2 = /-(\w|$)/g;
    var callback = function callback2(dashChar, char) {
      return char.toUpperCase();
    };
    var camelCaseCSS = function camelCaseCSS2(property) {
      property = property.toLowerCase();
      if (property === "float") {
        return "cssFloat";
      } else if (property.charCodeAt(0) === 45 && property.charCodeAt(1) === 109 && property.charCodeAt(2) === 115 && property.charCodeAt(3) === 45) {
        return property.substr(1).replace(pattern2, callback);
      } else {
        return property.replace(pattern2, callback);
      }
    };
    module.exports = camelCaseCSS;
  }
});

// node_modules/postcss-js/objectifier.js
var require_objectifier = __commonJS({
  "node_modules/postcss-js/objectifier.js"(exports, module) {
    "use strict";
    init_shim();
    var camelcase = require_index_es5();
    var UNITLESS = {
      boxFlex: true,
      boxFlexGroup: true,
      columnCount: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      strokeDashoffset: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    function atRule2(node) {
      if (typeof node.nodes === "undefined") {
        return true;
      } else {
        return process2(node);
      }
    }
    function process2(node) {
      let name;
      let result = {};
      node.each((child) => {
        if (child.type === "atrule") {
          name = "@" + child.name;
          if (child.params)
            name += " " + child.params;
          if (typeof result[name] === "undefined") {
            result[name] = atRule2(child);
          } else if (Array.isArray(result[name])) {
            result[name].push(atRule2(child));
          } else {
            result[name] = [result[name], atRule2(child)];
          }
        } else if (child.type === "rule") {
          let body = process2(child);
          if (result[child.selector]) {
            for (let i5 in body) {
              result[child.selector][i5] = body[i5];
            }
          } else {
            result[child.selector] = body;
          }
        } else if (child.type === "decl") {
          if (child.prop[0] === "-" && child.prop[1] === "-") {
            name = child.prop;
          } else if (child.parent && child.parent.selector === ":export") {
            name = child.prop;
          } else {
            name = camelcase(child.prop);
          }
          let value2 = child.value;
          if (!isNaN(child.value) && UNITLESS[name]) {
            value2 = parseFloat(child.value);
          }
          if (child.important)
            value2 += " !important";
          if (typeof result[name] === "undefined") {
            result[name] = value2;
          } else if (Array.isArray(result[name])) {
            result[name].push(value2);
          } else {
            result[name] = [result[name], value2];
          }
        }
      });
      return result;
    }
    module.exports = process2;
  }
});

// node_modules/postcss-js/parser.js
var require_parser3 = __commonJS({
  "node_modules/postcss-js/parser.js"(exports, module) {
    "use strict";
    init_shim();
    var postcss2 = require_postcss();
    var IMPORTANT = /\s*!important\s*$/i;
    var UNITLESS = {
      "box-flex": true,
      "box-flex-group": true,
      "column-count": true,
      "flex": true,
      "flex-grow": true,
      "flex-positive": true,
      "flex-shrink": true,
      "flex-negative": true,
      "font-weight": true,
      "line-clamp": true,
      "line-height": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "tab-size": true,
      "widows": true,
      "z-index": true,
      "zoom": true,
      "fill-opacity": true,
      "stroke-dashoffset": true,
      "stroke-opacity": true,
      "stroke-width": true
    };
    function dashify(str) {
      return str.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
    }
    function decl2(parent, name, value2) {
      if (value2 === false || value2 === null)
        return;
      if (!name.startsWith("--")) {
        name = dashify(name);
      }
      if (typeof value2 === "number") {
        if (value2 === 0 || UNITLESS[name]) {
          value2 = value2.toString();
        } else {
          value2 += "px";
        }
      }
      if (name === "css-float")
        name = "float";
      if (IMPORTANT.test(value2)) {
        value2 = value2.replace(IMPORTANT, "");
        parent.push(postcss2.decl({ prop: name, value: value2, important: true }));
      } else {
        parent.push(postcss2.decl({ prop: name, value: value2 }));
      }
    }
    function atRule2(parent, parts, value2) {
      let node = postcss2.atRule({ name: parts[1], params: parts[3] || "" });
      if (typeof value2 === "object") {
        node.nodes = [];
        parse6(value2, node);
      }
      parent.push(node);
    }
    function parse6(obj, parent) {
      let name, value2, node;
      for (name in obj) {
        value2 = obj[name];
        if (value2 === null || typeof value2 === "undefined") {
          continue;
        } else if (name[0] === "@") {
          let parts = name.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(value2)) {
            for (let i5 of value2) {
              atRule2(parent, parts, i5);
            }
          } else {
            atRule2(parent, parts, value2);
          }
        } else if (Array.isArray(value2)) {
          for (let i5 of value2) {
            decl2(parent, name, i5);
          }
        } else if (typeof value2 === "object") {
          node = postcss2.rule({ selector: name });
          parse6(value2, node);
          parent.push(node);
        } else {
          decl2(parent, name, value2);
        }
      }
    }
    module.exports = function(obj) {
      let root2 = postcss2.root();
      parse6(obj, root2);
      return root2;
    };
  }
});

// node_modules/postcss-js/process-result.js
var require_process_result = __commonJS({
  "node_modules/postcss-js/process-result.js"(exports, module) {
    "use strict";
    init_shim();
    var objectify2 = require_objectifier();
    module.exports = function processResult(result) {
      if (console && console.warn) {
        result.warnings().forEach((warn2) => {
          let source = warn2.plugin || "PostCSS";
          console.warn(source + ": " + warn2.text);
        });
      }
      return objectify2(result.root);
    };
  }
});

// node_modules/postcss-js/async.js
var require_async = __commonJS({
  "node_modules/postcss-js/async.js"(exports, module) {
    "use strict";
    init_shim();
    var postcss2 = require_postcss();
    var processResult = require_process_result();
    var parse6 = require_parser3();
    module.exports = function async2(plugins) {
      let processor = postcss2(plugins);
      return async (input) => {
        let result = await processor.process(input, {
          parser: parse6,
          from: void 0
        });
        return processResult(result);
      };
    };
  }
});

// node_modules/postcss-js/sync.js
var require_sync = __commonJS({
  "node_modules/postcss-js/sync.js"(exports, module) {
    "use strict";
    init_shim();
    var postcss2 = require_postcss();
    var processResult = require_process_result();
    var parse6 = require_parser3();
    module.exports = function(plugins) {
      let processor = postcss2(plugins);
      return (input) => {
        let result = processor.process(input, { parser: parse6, from: void 0 });
        return processResult(result);
      };
    };
  }
});

// node_modules/postcss-js/index.js
var require_postcss_js = __commonJS({
  "node_modules/postcss-js/index.js"(exports, module) {
    "use strict";
    init_shim();
    var objectify2 = require_objectifier();
    var parse6 = require_parser3();
    var async2 = require_async();
    var sync2 = require_sync();
    module.exports = {
      objectify: objectify2,
      parse: parse6,
      async: async2,
      sync: sync2
    };
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/dlv/dist/dlv.umd.js
var require_dlv_umd = __commonJS({
  "node_modules/dlv/dist/dlv.umd.js"(exports, module) {
    "use strict";
    init_shim();
    !function(t5, n4) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = function(t6, n5, e4, i5, o5) {
        for (n5 = n5.split ? n5.split(".") : n5, i5 = 0; i5 < n5.length; i5++)
          t6 = t6 ? t6[n5[i5]] : o5;
        return t6 === o5 ? e4 : t6;
      } : "function" == typeof define && define.amd ? define(function() {
        return function(t6, n5, e4, i5, o5) {
          for (n5 = n5.split ? n5.split(".") : n5, i5 = 0; i5 < n5.length; i5++)
            t6 = t6 ? t6[n5[i5]] : o5;
          return t6 === o5 ? e4 : t6;
        };
      }) : t5.dlv = function(t6, n5, e4, i5, o5) {
        for (n5 = n5.split ? n5.split(".") : n5, i5 = 0; i5 < n5.length; i5++)
          t6 = t6 ? t6[n5[i5]] : o5;
        return t6 === o5 ? e4 : t6;
      };
    }(exports);
  }
});

// node_modules/didyoumean/didYouMean-1.2.1.js
var require_didYouMean_1_2_1 = __commonJS({
  "node_modules/didyoumean/didYouMean-1.2.1.js"(exports, module) {
    "use strict";
    init_shim();
    (function() {
      "use strict";
      function didYouMean2(str, list3, key) {
        if (!str)
          return null;
        if (!didYouMean2.caseSensitive) {
          str = str.toLowerCase();
        }
        var thresholdRelative = didYouMean2.threshold === null ? null : didYouMean2.threshold * str.length, thresholdAbsolute = didYouMean2.thresholdAbsolute, winningVal;
        if (thresholdRelative !== null && thresholdAbsolute !== null)
          winningVal = Math.min(thresholdRelative, thresholdAbsolute);
        else if (thresholdRelative !== null)
          winningVal = thresholdRelative;
        else if (thresholdAbsolute !== null)
          winningVal = thresholdAbsolute;
        else
          winningVal = null;
        var winner, candidate, testCandidate, val, i5, len = list3.length;
        for (i5 = 0; i5 < len; i5++) {
          candidate = list3[i5];
          if (key) {
            candidate = candidate[key];
          }
          if (!candidate) {
            continue;
          }
          if (!didYouMean2.caseSensitive) {
            testCandidate = candidate.toLowerCase();
          } else {
            testCandidate = candidate;
          }
          val = getEditDistance(str, testCandidate, winningVal);
          if (winningVal === null || val < winningVal) {
            winningVal = val;
            if (key && didYouMean2.returnWinningObject)
              winner = list3[i5];
            else
              winner = candidate;
            if (didYouMean2.returnFirstMatch)
              return winner;
          }
        }
        return winner || didYouMean2.nullResultValue;
      }
      didYouMean2.threshold = 0.4;
      didYouMean2.thresholdAbsolute = 20;
      didYouMean2.caseSensitive = false;
      didYouMean2.nullResultValue = null;
      didYouMean2.returnWinningObject = null;
      didYouMean2.returnFirstMatch = false;
      if (typeof module !== "undefined" && module.exports) {
        module.exports = didYouMean2;
      } else {
        window.didYouMean = didYouMean2;
      }
      var MAX_INT = Math.pow(2, 32) - 1;
      function getEditDistance(a3, b3, max3) {
        max3 = max3 || max3 === 0 ? max3 : MAX_INT;
        var lena = a3.length;
        var lenb = b3.length;
        if (lena === 0)
          return Math.min(max3 + 1, lenb);
        if (lenb === 0)
          return Math.min(max3 + 1, lena);
        if (Math.abs(lena - lenb) > max3)
          return max3 + 1;
        var matrix = [], i5, j2, colMin, minJ, maxJ;
        for (i5 = 0; i5 <= lenb; i5++) {
          matrix[i5] = [i5];
        }
        for (j2 = 0; j2 <= lena; j2++) {
          matrix[0][j2] = j2;
        }
        for (i5 = 1; i5 <= lenb; i5++) {
          colMin = MAX_INT;
          minJ = 1;
          if (i5 > max3)
            minJ = i5 - max3;
          maxJ = lenb + 1;
          if (maxJ > max3 + i5)
            maxJ = max3 + i5;
          for (j2 = 1; j2 <= lena; j2++) {
            if (j2 < minJ || j2 > maxJ) {
              matrix[i5][j2] = max3 + 1;
            } else {
              if (b3.charAt(i5 - 1) === a3.charAt(j2 - 1)) {
                matrix[i5][j2] = matrix[i5 - 1][j2 - 1];
              } else {
                matrix[i5][j2] = Math.min(
                  matrix[i5 - 1][j2 - 1] + 1,
                  // Substitute
                  Math.min(
                    matrix[i5][j2 - 1] + 1,
                    // Insert
                    matrix[i5 - 1][j2] + 1
                  )
                );
              }
            }
            if (matrix[i5][j2] < colMin)
              colMin = matrix[i5][j2];
          }
          if (colMin > max3)
            return max3 + 1;
        }
        return matrix[lenb][lena];
      }
    })();
  }
});

// src/index.ts
init_shim();

// src/server.ts
init_shim();

// src/client.ts
init_shim();

// src/variables/variables.tsx
init_shim();
import React2 from "react";

// src/shell/shell.tsx
init_shim();
import React from "react";
var PageTop = (props) => {
  return /* @__PURE__ */ React.createElement("div", { ...props, className: `--onedoc-page-top ${props?.className || ""}` });
};
var CurrentPageTop = (props) => {
  return /* @__PURE__ */ React.createElement(
    "div",
    {
      ...props,
      className: `--onedoc-current-page-top ${props?.className || ""}`
    }
  );
};
var PageBottom = (props) => {
  return /* @__PURE__ */ React.createElement(
    "div",
    {
      ...props,
      className: `--onedoc-page-bottom ${props?.className || ""}`
    }
  );
};
var PageBreak = (props) => {
  return /* @__PURE__ */ React.createElement(
    "div",
    {
      ...props,
      className: `--onedoc-page-break ${props?.className || ""}`
    }
  );
};
var NoBreak = (props) => {
  return /* @__PURE__ */ React.createElement("div", { ...props, className: `--onedoc-no-break ${props?.className || ""}` });
};
var FloatBottom = (props) => {
  return /* @__PURE__ */ React.createElement(
    "div",
    {
      ...props,
      style: {
        PrinceFloat: "bottom"
      }
    },
    props.children
  );
};

// src/variables/variables.tsx
var PageNumber = ({
  counterStyle = "decimal"
}) => {
  return /* @__PURE__ */ React2.createElement(
    "span",
    {
      style: {
        content: `counter(page, ${counterStyle})`
      }
    }
  );
};
var PagesNumber = ({
  counterStyle = "decimal"
}) => {
  return /* @__PURE__ */ React2.createElement(
    "span",
    {
      style: {
        content: `counter(pages, ${counterStyle})`
      }
    }
  );
};
var RunningHeader = (level) => {
  return ({ before = "", after = "" }) => {
    return /* @__PURE__ */ React2.createElement(
      "span",
      {
        className: `--onedoc-heading-contents --onedoc-h${level}-contents`,
        "data-before": before,
        "data-after": after
      }
    );
  };
};
var RunningH1 = RunningHeader(1);
var RunningH2 = RunningHeader(2);
var RunningH3 = RunningHeader(3);
var RunningH4 = RunningHeader(4);
var RunningH5 = RunningHeader(5);
var RunningH6 = RunningHeader(6);
var __docConfig = {
  name: "Variables",
  icon: "subscript",
  description: "Display dynamic values based on your document, such as page numbers and running headers.",
  components: {
    PageNumber: {
      server: true,
      client: true,
      examples: {
        default: {
          template: /* @__PURE__ */ React2.createElement(PageNumber, { counterStyle: "decimal" })
        },
        customStyle: {
          description: "You can use a custom CSS counter-style, by passing a known name or a custom counter style.",
          template: /* @__PURE__ */ React2.createElement(PageNumber, { counterStyle: "lower-roman" })
        }
      }
    },
    PagesNumber: {
      server: true,
      client: true,
      examples: {
        default: {
          imports: ["PageNumber"],
          template: /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(PageNumber, { counterStyle: "decimal" }), " of ", /* @__PURE__ */ React2.createElement(PagesNumber, { counterStyle: "decimal" }))
        }
      }
    },
    RunningH1: {
      server: true,
      client: true,
      examples: {
        default: {
          description: "Show the current running header of level 1 in the page header. All running headers are reset when any of their parent headings are encountered (e.g. a level 2 heading resets the level 3, 4, 5 and 6 headings).",
          template: /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(PageTop, { style: { paddingTop: "1rem" } }, /* @__PURE__ */ React2.createElement(RunningH1, null)), /* @__PURE__ */ React2.createElement("h1", null, "Heading of level 1"))
        }
      }
    },
    RunningH2: {
      server: true,
      client: true
    },
    RunningH3: {
      server: true,
      client: true
    },
    RunningH4: {
      server: true,
      client: true
    },
    RunningH5: {
      server: true,
      client: true
    },
    RunningH6: {
      server: true,
      client: true
    }
  }
};

// src/footnote/footnote.tsx
init_shim();
import React3 from "react";
var Footnote = ({
  children,
  ...props
}) => {
  return /* @__PURE__ */ React3.createElement(
    "span",
    {
      className: "--onedoc-footnote text-left text-xs font-normal",
      ...props
    },
    children
  );
};

// src/compile/compile.tsx
init_shim();
import React5 from "react";

// raw-loader:../../dist/index.css?raw
var dist_default = '/* src/generic.css */\n.hyphenate {\n  hyphens: auto;\n}\ninput,\nselect option {\n  -prince-pdf-form: enable;\n}\n\n/* src/variables/headings.css */\nh1 {\n  string-set: onedocH1Contents contents onedocH2Contents "" onedocH3Contents "" onedocH4Contents "" onedocH5Contents "" onedocH6Contents "";\n}\nh2 {\n  string-set: onedocH2Contents contents onedocH3Contents "" onedocH4Contents "" onedocH5Contents "" onedocH6Contents "";\n}\nh3 {\n  string-set: onedocH3Contents contents onedocH4Contents "" onedocH5Contents "" onedocH6Contents "";\n}\nh4 {\n  string-set: onedocH4Contents contents onedocH5Contents "" onedocH6Contents "";\n}\nh5 {\n  string-set: onedocH5Contents contents onedocH6Contents "";\n}\nh6 {\n  string-set: onedocH6Contents contents;\n}\n.--onedoc-heading-contents:not(:empty)::before {\n  content: attr(data-before);\n}\n.--onedoc-heading-contents:not(:empty)::after {\n  content: attr(data-after);\n}\n.--onedoc-h1-contents {\n  content: string(onedocH1Contents);\n}\n.--onedoc-h2-contents {\n  content: string(onedocH2Contents);\n}\n.--onedoc-h3-contents {\n  content: string(onedocH3Contents);\n}\n.--onedoc-h4-contents {\n  content: string(onedocH4Contents);\n}\n.--onedoc-h5-contents {\n  content: string(onedocH5Contents);\n}\n.--onedoc-h6-contents {\n  content: string(onedocH6Contents);\n}\n\n/* src/variables/variables.css */\n\n/* src/shell/shell.css */\n@page {\n  @top-left {\n    content: flow(--onedoc-page-top);\n    position: relative;\n  }\n  @bottom-left {\n    content: flow(--onedoc-page-bottom);\n    position: relative;\n  }\n}\n.--onedoc-page-top {\n  -prince-flow: static(--onedoc-page-top);\n  width: 100%;\n  height: 100%;\n}\n.--onedoc-current-page-top {\n  position: --onedoc-page-top;\n  width: 100%;\n  height: 100%;\n}\n.--onedoc-page-bottom {\n  -prince-flow: static(--onedoc-page-bottom);\n  width: 100%;\n  height: 100%;\n}\n.--onedoc-page-break {\n  page-break-after: always;\n}\n.--onedoc-no-break {\n  page-break-inside: avoid;\n}\n\n/* src/footnote/footnote.css */\n.--onedoc-footnote {\n  float: footnote;\n  footnote-style-position: inside;\n}\n/*# sourceMappingURL=index.css.map */';

// src/css/css.tsx
init_shim();
import React4 from "react";
import { encode } from "html-entities";
var allowedEntities = {
  "&apos;": "'",
  "&quot;": '"'
};
var CSS = ({ children }) => {
  let contents = encode(children);
  for (const [entity, value2] of Object.entries(allowedEntities)) {
    contents = contents.replace(new RegExp(entity, "g"), value2);
  }
  return /* @__PURE__ */ React4.createElement("style", { dangerouslySetInnerHTML: { __html: contents } });
};
var __docConfig2 = {
  name: "CSS",
  icon: "css3-alt",
  description: `Allows adding CSS to the document while securely parsing and escaping it.

NB: While you can add regular CSS with the \`<style>\` tag, it's recommended to use the \`CSS\` component to ensure that the CSS is properly escaped, most notably when using URLs or other potentially unsafe content.`,
  components: {
    CSS: {
      server: true,
      client: true,
      examples: {
        default: {
          description: "Use a simple CSS print property to set the page size.",
          template: /* @__PURE__ */ React4.createElement(CSS, null, `@page { size: a4 landscape; }`)
        },
        loadFont: {
          name: "Load a Google Font",
          description: "Load a Google Font using the `@import` rule.",
          template: /* @__PURE__ */ React4.createElement(React4.Fragment, null, /* @__PURE__ */ React4.createElement(CSS, null, `@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap');`), /* @__PURE__ */ React4.createElement("p", { style: { fontFamily: "Roboto, sans-serif" } }, "This text uses the Roboto Light font."))
        },
        layout: {
          name: "Layout",
          description: "You can use the `@page` at-rule in CSS to manage all aspects of printed pages. More on this [here](https://developer.mozilla.org/en-US/docs/Web/CSS/@page).",
          template: /* @__PURE__ */ React4.createElement(React4.Fragment, null, /* @__PURE__ */ React4.createElement(CSS, null, `@page {size: A4;margin-top:1cm;margin-right:1cm;margin-left:1cm;margin-bottom:1cm;`), /* @__PURE__ */ React4.createElement("div", null, "Hello world!"))
        }
      }
    }
  }
};

// src/compile/compile.tsx
var compile = async (node, options) => {
  const { emotion } = Object.assign(
    {
      emotion: false
    },
    options || {}
  );
  const ReactDOMServer = await import("react-dom/server");
  let Element = /* @__PURE__ */ React5.createElement(React5.Fragment, null, /* @__PURE__ */ React5.createElement(CSS, null, dist_default), node);
  if (!emotion) {
    return ReactDOMServer.renderToString(Element);
  }
  const { CacheProvider } = await import("@emotion/react");
  const { default: createCache } = await import("@emotion/cache");
  const { default: createEmotionServer } = await import("@emotion/server/create-instance");
  const cache2 = createCache({ key: "css" });
  const { extractCriticalToChunks, constructStyleTagsFromChunks } = createEmotionServer(cache2);
  Element = /* @__PURE__ */ React5.createElement(CacheProvider, { value: cache2 }, Element);
  const html = ReactDOMServer.renderToString(Element);
  const chunks = extractCriticalToChunks(html);
  const styles = constructStyleTagsFromChunks(chunks);
  const mergedStylesheet = styles.replace(
    /<\/?style( data-emotion="[a-z0-9- ]+")?>/gm,
    ""
  );
  const { default: postcss2 } = await Promise.resolve().then(() => (init_postcss(), postcss_exports));
  const { default: cssvariables } = await Promise.resolve().then(() => __toESM(require_postcss_css_variables()));
  const { default: logical } = await Promise.resolve().then(() => (init_dist(), dist_exports));
  const result = await postcss2([cssvariables(), logical()]).process(
    mergedStylesheet,
    {
      from: void 0
    }
  );
  return `<style>${result.css}</style>${html}`;
};

// src/markdown/markdown.tsx
init_shim();
import MarkdownJSX from "markdown-to-jsx";
import React6 from "react";
var Markdown = MarkdownJSX;

// src/latex/latex.tsx
init_shim();
import React7 from "react";
import katex from "katex";
var Latex = ({ children }) => {
  const html = katex.renderToString(children, {
    throwOnError: false
  });
  return /* @__PURE__ */ React7.createElement(React7.Fragment, null, /* @__PURE__ */ React7.createElement(
    "link",
    {
      rel: "stylesheet",
      href: "https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.css",
      integrity: "sha384-OH8qNTHoMMVNVcKdKewlipV4SErXqccxxlg6HC9Cwjr5oZu2AdBej1TndeCirael",
      crossOrigin: "anonymous"
    }
  ), /* @__PURE__ */ React7.createElement("span", { dangerouslySetInnerHTML: { __html: html } }));
};
var __docConfig3 = {
  name: "LaTeX",
  icon: "square-root-variable",
  description: `Render LaTeX formulas right in your React components.

<Warning>
LaTeX rendering is still in beta. Please report any issues you encounter on our [Discord](https://discord.com/invite/uRJE6e2rgr).
</Warning>

<Note>Rendering LaTeX using KaTeX requires pulling a remote stylesshet hosted by jsdelivr. This is done to prevent the styles from being purged.</Note>

<Tip>You can use \`String.raw\` to avoid escaping LaTeX backslashes.</Tip>`,
  components: {
    Latex: {
      server: true,
      client: true,
      examples: {
        default: {
          template: /* @__PURE__ */ React7.createElement(Latex, null, String.raw`\frac{1}{2}`)
        },
        complex: {
          template: /* @__PURE__ */ React7.createElement(Latex, null, String.raw`% \f is defined as #1f(#2) using the macro
\f\relax{x} = \int_{-\infty}^\infty
    \f\hat\xi\,e^{2 \pi i \xi x}
    \,d\xi`)
        }
      }
    }
  }
};

// src/tailwind/tailwind.tsx
init_shim();
init_postcss();
import React9 from "react";

// node_modules/postcss-color-functional-notation/dist/index.mjs
init_shim();

// node_modules/@csstools/postcss-progressive-custom-properties/dist/index.mjs
init_shim();
var import_postcss_value_parser2 = __toESM(require_lib(), 1);
var a = ["at", "bottom", "center", "circle", "closest-corner", "closest-side", "ellipse", "farthest-corner", "farthest-side", "from", "in", "left", "right", "to", "top"];
function doublePositionGradients(e4) {
  const r5 = [], p3 = e4.value.toLowerCase();
  if ("function" === e4.type && ("conic-gradient" === p3 || "linear-gradient" === p3 || "radial-gradient" === p3 || "repeating-conic-gradient" === p3 || "repeating-linear-gradient" === p3 || "repeating-radial-gradient" === p3)) {
    let p4 = 0, t5 = false, i5 = false;
    e:
      for (let o5 = 0; o5 < e4.nodes.length; o5++) {
        const s2 = e4.nodes[o5];
        if ("word" === s2.type && a.includes(s2.value.toLowerCase()) && (t5 = true), "div" !== s2.type || "," !== s2.value.trim())
          if ("word" !== s2.type || "in" !== s2.value.toLowerCase()) {
            if ("word" !== s2.type && "function" !== s2.type || p4++, i5)
              switch (e4.value.toLowerCase()) {
                case "conic-gradient":
                  r5.push("(background: conic-gradient(in oklch, red 0deg, red 0deg 1deg, red 2deg))");
                  break e;
                case "linear-gradient":
                  r5.push("(background: linear-gradient(in oklch, red 0%, red 0% 1%, red 2%))");
                  break e;
                case "radial-gradient":
                  r5.push("(background: radial-gradient(in oklch, red, red 1px 2px, red 3px))");
                  break e;
                case "repeating-conic-gradient":
                  r5.push("(background: repeating-conic-gradient(in oklch from 0deg, red 0deg, red 0deg 1deg, red 2deg))");
                  break e;
                case "repeating-linear-gradient":
                  r5.push("(background: repeating-linear-gradient(in oklch, red 0%, red 0% 1%, red 2%))");
                  break e;
                case "repeating-radial-gradient":
                  r5.push("(background: repeating-radial-gradient(in oklch, red, red 1px 2px, red 3px))");
                  break e;
              }
            if (!t5 && 3 === p4)
              switch (e4.value.toLowerCase()) {
                case "conic-gradient":
                  r5.push("(background: conic-gradient(red 0deg, red 0deg 1deg, red 2deg))");
                  break e;
                case "linear-gradient":
                  r5.push("(background: linear-gradient(red 0%, red 0% 1%, red 2%))");
                  break e;
                case "radial-gradient":
                  r5.push("(background: radial-gradient(red, red 1px 2px, red 3px))");
                  break e;
                case "repeating-conic-gradient":
                  r5.push("(background: repeating-conic-gradient(from 0deg, red 0deg, red 0deg 1deg, red 2deg))");
                  break e;
                case "repeating-linear-gradient":
                  r5.push("(background: repeating-linear-gradient(red 0%, red 0% 1%, red 2%))");
                  break e;
                case "repeating-radial-gradient":
                  r5.push("(background: repeating-radial-gradient(red, red 1px 2px, red 3px))");
                  break e;
              }
          } else
            i5 = true;
        else
          p4 = 0, t5 = false;
      }
  }
  return r5;
}
var r2 = [{ supports: "color-mix(in lch, red, blue)", property: "color", sniff: "color-mix", matchers: [{ type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color-mix", nodes: [{ type: "word", value: "in" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }] }, { supports: "rgb(from red r g b)", property: "color", sniff: "from ", matchers: [{ type: "function", value: "rgb", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "rgb", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "hsl", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "hsl", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "hwb", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "hwb", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "lch", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "lch", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklch", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklch", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "lab", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "lab", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklab", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklab", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "from" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(display-p3 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "srgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "srgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(display-p3 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "display-p3" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "display-p3" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "srgb-linear" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "srgb-linear" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "a98-rgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "a98-rgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "prophoto-rgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "prophoto-rgb" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "rec2020" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "rec2020" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "xyz-d50" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "xyz-d50" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "xyz-d65" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "xyz-d65" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "color(xyz 0 0 0)", property: "color", sniff: "color", matchers: [{ type: "function", value: "color", nodes: [{ type: "word", value: "xyz" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "color", nodes: [{ type: "word", value: "xyz" }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "hsl(0, 0%, 0%)", property: "color", sniff: "hsl", matchers: [{ type: "function", value: "hsl", nodes: [{ type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }] }, { supports: "hsl(0 0% 0% / 0)", property: "color", sniff: "hsl", matchers: [{ type: "function", value: "hsl", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "hsl", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "hsla(0 0% 0% / 0)", property: "color", sniff: "hsla", matchers: [{ type: "function", value: "hsla", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "hwb(0 0% 0%)", property: "color", sniff: "hwb", matchers: [{ type: "function", value: "hwb", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "hwb", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "lab(0% 0 0)", property: "color", sniff: "lab", matchers: [{ type: "function", value: "lab", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "lab", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "lab(0% 0 0)", property: "color", sniff: "lch", matchers: [{ type: "function", value: "lch", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "lch", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "oklab(0% 0 0)", property: "color", sniff: "oklab", matchers: [{ type: "function", value: "oklab", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklab", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "oklab(0% 0 0)", property: "color", sniff: "oklch", matchers: [{ type: "function", value: "oklch", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "oklch", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "rgb(0, 0, 0, 0)", property: "color", sniff: "rgb", matchers: [{ type: "function", value: "rgb", nodes: [{ type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }, { type: "div", value: "," }, { type: "word", isVariable: true }] }] }, { supports: "rgb(0 0 0 / 0)", property: "color", sniff: "rgb", matchers: [{ type: "function", value: "rgb", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }] }, { type: "function", value: "rgb", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "rgba(0 0 0 / 0)", property: "color", sniff: "rgba", matchers: [{ type: "function", value: "rgba", nodes: [{ type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "space" }, { type: "word", isVariable: true }, { type: "div", value: "/" }, { type: "word", isVariable: true }] }] }, { supports: "1ic", property: "font-size", sniff: "ic", matchers: [{ type: "word", value: "1ic", dimension: { unit: "ic" } }] }];
function matches(e4, a3) {
  if (e4.isVariable && a3 && ("word" === a3.type || "string" === a3.type || "function" === a3.type))
    return true;
  if (e4.type !== a3.type)
    return false;
  if (doesNotMatchValue(e4, a3))
    return false;
  if (e4.nodes && a3.nodes) {
    for (let r5 = 0; r5 < Math.max(e4.nodes.length, a3.nodes.length); r5++) {
      let p3 = r5, t5 = r5;
      for (; e4.nodes[p3] && "space" === e4.nodes[p3].type; )
        p3++;
      for (; a3.nodes[t5] && "space" === a3.nodes[t5].type; )
        t5++;
      if (!!e4.nodes[p3] != !!a3.nodes[t5])
        return false;
      if (!matches(e4.nodes[p3], a3.nodes[t5]))
        return false;
    }
    return true;
  }
  return true;
}
function doesNotMatchValue(e4, a3) {
  return ("space" !== e4.type || "space" !== a3.type || e4.value?.trim() !== a3.value?.trim()) && (e4.dimension && a3.dimension ? e4.dimension.unit !== a3.dimension.unit : "string" === e4.type ? e4.value !== a3.value : e4.value?.toLowerCase() !== a3.value?.toLowerCase());
}
var p = /^var$/i;
function conditionsFromValue(a3, t5 = false) {
  const i5 = [], o5 = r2.filter((e4) => a3.includes(e4.sniff));
  let s2 = false;
  try {
    (0, import_postcss_value_parser2.default)(a3).walk((a4) => {
      "function" === a4.type && p.test(a4.value) && (s2 = true);
      try {
        const r5 = import_postcss_value_parser2.default.unit(a4.value);
        false !== r5 && (a4.dimension = r5);
      } catch {
      }
      for (let e4 = 0; e4 < o5.length; e4++) {
        const r5 = o5[e4];
        for (let e5 = 0; e5 < r5.matchers.length; e5++) {
          if (matches(r5.matchers[e5], a4))
            return void i5.push(`(${r5.property}: ${r5.supports})`);
        }
      }
      i5.push(...doublePositionGradients(a4));
    });
  } catch (e4) {
  }
  return t5 && !s2 ? { support: [] } : { support: Array.from(new Set(i5)).sort() };
}
var t2 = /var\(/i;
var i2 = /^initial$/i;
var o2 = /^\s*$/;
var creator2 = () => ({ postcssPlugin: "postcss-progressive-custom-properties", prepare() {
  const e4 = /* @__PURE__ */ new WeakMap();
  return { OnceExit: (a3, { postcss: r5 }) => {
    a3.walkDecls((a4) => {
      if (!a4.parent)
        return;
      const p3 = e4.get(a4.parent) || { conditionalRules: [], propNames: /* @__PURE__ */ new Set(), lastConditionParams: { support: void 0 }, lastConditionalRule: void 0 };
      if (e4.set(a4.parent, p3), a4.variable) {
        if (!p3.propNames.has(a4.prop))
          return void p3.propNames.add(a4.prop);
      } else {
        const e5 = a4.prop.toLowerCase();
        if (!p3.propNames.has(e5))
          return void p3.propNames.add(e5);
      }
      if (!a4.variable && !t2.test(a4.value))
        return;
      if (i2.test(a4.value))
        return;
      if (o2.test(a4.value))
        return;
      const s2 = !a4.variable, l2 = conditionsFromValue(a4.value, s2).support.join(" and ");
      if (!l2)
        return;
      if (p3.lastConditionParams.support !== l2 && (p3.lastConditionalRule = void 0), p3.lastConditionalRule)
        return p3.lastConditionalRule.append(a4.clone()), void a4.remove();
      const y3 = [];
      if (l2 && y3.push(r5.atRule({ name: "supports", params: l2, source: a4.parent.source, raws: { before: "\n\n", after: "\n" } })), !y3.length)
        return;
      for (let e5 = 0; e5 < y3.length - 1; e5++) {
        const a5 = y3[e5], r6 = y3[e5 + 1];
        a5.append(r6);
      }
      const d3 = y3[0], c2 = y3[y3.length - 1], n4 = a4.parent.clone();
      n4.removeAll(), n4.raws.before = "\n", n4.append(a4.clone()), a4.remove(), p3.lastConditionParams.support = l2, p3.lastConditionalRule = n4, c2.append(n4), p3.conditionalRules.push(d3);
    }), a3.walk((a4) => {
      const r6 = e4.get(a4);
      r6 && 0 !== r6.conditionalRules.length && r6.conditionalRules.reverse().forEach((e5) => {
        a4.after(e5);
      });
    });
  } };
} });
creator2.postcss = true;

// node_modules/@csstools/css-tokenizer/dist/index.mjs
init_shim();
var ParseError = class extends Error {
  constructor(e4, n4, o5, r5) {
    super(e4);
    __publicField(this, "sourceStart");
    __publicField(this, "sourceEnd");
    __publicField(this, "parserState");
    this.name = "ParseError", this.sourceStart = n4, this.sourceEnd = o5, this.parserState = r5;
  }
};
var Reader = class {
  constructor(e4) {
    __publicField(this, "cursor", 0);
    __publicField(this, "source", "");
    __publicField(this, "codePointSource", []);
    __publicField(this, "representationIndices", [-1]);
    __publicField(this, "length", 0);
    __publicField(this, "representationStart", 0);
    __publicField(this, "representationEnd", -1);
    this.source = e4;
    {
      let n4 = -1, o5 = "";
      for (o5 of e4)
        n4 += o5.length, this.codePointSource.push(o5.codePointAt(0)), this.representationIndices.push(n4);
    }
    this.length = this.codePointSource.length;
  }
  advanceCodePoint(e4 = 1) {
    this.cursor = this.cursor + e4, this.representationEnd = this.representationIndices[this.cursor];
  }
  readCodePoint(e4 = 1) {
    const n4 = this.codePointSource[this.cursor];
    return void 0 !== n4 && (this.cursor = this.cursor + e4, this.representationEnd = this.representationIndices[this.cursor], n4);
  }
  unreadCodePoint(e4 = 1) {
    this.cursor = this.cursor - e4, this.representationEnd = this.representationIndices[this.cursor];
  }
  resetRepresentation() {
    this.representationStart = this.representationIndices[this.cursor] + 1, this.representationEnd = -1;
  }
};
var e3;
var n2;
var o3;
function mirrorVariantType(n4) {
  switch (n4) {
    case e3.OpenParen:
      return e3.CloseParen;
    case e3.CloseParen:
      return e3.OpenParen;
    case e3.OpenCurly:
      return e3.CloseCurly;
    case e3.CloseCurly:
      return e3.OpenCurly;
    case e3.OpenSquare:
      return e3.CloseSquare;
    case e3.CloseSquare:
      return e3.OpenSquare;
    default:
      return null;
  }
}
function mirrorVariant(n4) {
  switch (n4[0]) {
    case e3.OpenParen:
      return [e3.CloseParen, ")", -1, -1, void 0];
    case e3.CloseParen:
      return [e3.OpenParen, "(", -1, -1, void 0];
    case e3.OpenCurly:
      return [e3.CloseCurly, "}", -1, -1, void 0];
    case e3.CloseCurly:
      return [e3.OpenCurly, "{", -1, -1, void 0];
    case e3.OpenSquare:
      return [e3.CloseSquare, "]", -1, -1, void 0];
    case e3.CloseSquare:
      return [e3.OpenSquare, "[", -1, -1, void 0];
    default:
      return null;
  }
}
!function(e4) {
  e4.Comment = "comment", e4.AtKeyword = "at-keyword-token", e4.BadString = "bad-string-token", e4.BadURL = "bad-url-token", e4.CDC = "CDC-token", e4.CDO = "CDO-token", e4.Colon = "colon-token", e4.Comma = "comma-token", e4.Delim = "delim-token", e4.Dimension = "dimension-token", e4.EOF = "EOF-token", e4.Function = "function-token", e4.Hash = "hash-token", e4.Ident = "ident-token", e4.Number = "number-token", e4.Percentage = "percentage-token", e4.Semicolon = "semicolon-token", e4.String = "string-token", e4.URL = "url-token", e4.Whitespace = "whitespace-token", e4.OpenParen = "(-token", e4.CloseParen = ")-token", e4.OpenSquare = "[-token", e4.CloseSquare = "]-token", e4.OpenCurly = "{-token", e4.CloseCurly = "}-token", e4.UnicodeRange = "unicode-range-token";
}(e3 || (e3 = {})), function(e4) {
  e4.Integer = "integer", e4.Number = "number";
}(n2 || (n2 = {})), function(e4) {
  e4.Unrestricted = "unrestricted", e4.ID = "id";
}(o3 || (o3 = {}));
var r3 = Object.values(e3);
function isToken(e4) {
  return !!Array.isArray(e4) && (!(e4.length < 4) && (!!r3.includes(e4[0]) && ("string" == typeof e4[1] && ("number" == typeof e4[2] && "number" == typeof e4[3]))));
}
function stringify4(...e4) {
  let n4 = "";
  for (let o5 = 0; o5 < e4.length; o5++)
    n4 += e4[o5][1];
  return n4;
}
var t3 = 39;
var i3 = 42;
var c = 8;
var s = 13;
var a2 = 9;
var u = 58;
var d = 44;
var P = 64;
var p2 = 127;
var S = 33;
var C = 12;
var l = 46;
var f = 62;
var h = 45;
var E = 31;
var m = 69;
var v = 101;
var g = 123;
var k = 40;
var I = 91;
var T = 60;
var O = 10;
var U = 11;
var w = 95;
var D = 1114111;
var A = 0;
var R = 35;
var L = 37;
var x = 43;
var y = 34;
var q = 65533;
var W = 92;
var N = 125;
var b = 41;
var F = 93;
var H = 59;
var V = 14;
var B = 47;
var z = 32;
var K = 117;
var M = 85;
var $ = 114;
var J = 82;
var _ = 108;
var j = 76;
var Q = 63;
var G = 48;
var X = 70;
function checkIfFourCodePointsWouldStartCDO(e4) {
  return e4.codePointSource[e4.cursor] === T && e4.codePointSource[e4.cursor + 1] === S && e4.codePointSource[e4.cursor + 2] === h && e4.codePointSource[e4.cursor + 3] === h;
}
function isDigitCodePoint(e4) {
  return e4 >= 48 && e4 <= 57;
}
function isUppercaseLetterCodePoint(e4) {
  return e4 >= 65 && e4 <= 90;
}
function isLowercaseLetterCodePoint(e4) {
  return e4 >= 97 && e4 <= 122;
}
function isHexDigitCodePoint(e4) {
  return isDigitCodePoint(e4) || e4 >= 97 && e4 <= 102 || e4 >= 65 && e4 <= 70;
}
function isLetterCodePoint(e4) {
  return isLowercaseLetterCodePoint(e4) || isUppercaseLetterCodePoint(e4);
}
function isIdentStartCodePoint(e4) {
  return isLetterCodePoint(e4) || isNonASCII_IdentCodePoint(e4) || e4 === w;
}
function isIdentCodePoint(e4) {
  return isIdentStartCodePoint(e4) || isDigitCodePoint(e4) || e4 === h;
}
function isNonASCII_IdentCodePoint(e4) {
  return 183 === e4 || 8204 === e4 || 8205 === e4 || 8255 === e4 || 8256 === e4 || 8204 === e4 || (192 <= e4 && e4 <= 214 || 216 <= e4 && e4 <= 246 || 248 <= e4 && e4 <= 893 || 895 <= e4 && e4 <= 8191 || 8304 <= e4 && e4 <= 8591 || 11264 <= e4 && e4 <= 12271 || 12289 <= e4 && e4 <= 55295 || 63744 <= e4 && e4 <= 64975 || 65008 <= e4 && e4 <= 65533 || e4 >= 65536);
}
function isNewLine(e4) {
  return 10 === e4 || 13 === e4 || 12 === e4;
}
function isWhitespace(e4) {
  return 32 === e4 || 10 === e4 || 9 === e4 || 13 === e4 || 12 === e4;
}
function checkIfTwoCodePointsAreAValidEscape(e4) {
  return e4.codePointSource[e4.cursor] === W && !isNewLine(e4.codePointSource[e4.cursor + 1]);
}
function checkIfThreeCodePointsWouldStartAnIdentSequence(e4, n4) {
  return n4.codePointSource[n4.cursor] === h ? n4.codePointSource[n4.cursor + 1] === h || (!!isIdentStartCodePoint(n4.codePointSource[n4.cursor + 1]) || n4.codePointSource[n4.cursor + 1] === W && !isNewLine(n4.codePointSource[n4.cursor + 2])) : !!isIdentStartCodePoint(n4.codePointSource[n4.cursor]) || checkIfTwoCodePointsAreAValidEscape(n4);
}
function checkIfThreeCodePointsWouldStartANumber(e4) {
  return e4.codePointSource[e4.cursor] === x || e4.codePointSource[e4.cursor] === h ? !!isDigitCodePoint(e4.codePointSource[e4.cursor + 1]) || e4.codePointSource[e4.cursor + 1] === l && isDigitCodePoint(e4.codePointSource[e4.cursor + 2]) : e4.codePointSource[e4.cursor] === l ? isDigitCodePoint(e4.codePointSource[e4.cursor + 1]) : isDigitCodePoint(e4.codePointSource[e4.cursor]);
}
function checkIfTwoCodePointsStartAComment(e4) {
  return e4.codePointSource[e4.cursor] === B && e4.codePointSource[e4.cursor + 1] === i3;
}
function checkIfThreeCodePointsWouldStartCDC(e4) {
  return e4.codePointSource[e4.cursor] === h && e4.codePointSource[e4.cursor + 1] === h && e4.codePointSource[e4.cursor + 2] === f;
}
function consumeComment(n4, o5) {
  for (o5.advanceCodePoint(2); ; ) {
    const e4 = o5.readCodePoint();
    if (false === e4) {
      n4.onParseError(new ParseError("Unexpected EOF while consuming a comment.", o5.representationStart, o5.representationEnd, ["4.3.2. Consume comments", "Unexpected EOF"]));
      break;
    }
    if (e4 === i3 && (void 0 !== o5.codePointSource[o5.cursor] && o5.codePointSource[o5.cursor] === B)) {
      o5.advanceCodePoint();
      break;
    }
  }
  return [e3.Comment, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, void 0];
}
function consumeEscapedCodePoint(e4, n4) {
  const o5 = n4.readCodePoint();
  if (false === o5)
    return e4.onParseError(new ParseError("Unexpected EOF while consuming an escaped code point.", n4.representationStart, n4.representationEnd, ["4.3.7. Consume an escaped code point", "Unexpected EOF"])), q;
  if (isHexDigitCodePoint(o5)) {
    const e5 = [o5];
    for (; void 0 !== n4.codePointSource[n4.cursor] && isHexDigitCodePoint(n4.codePointSource[n4.cursor]) && e5.length < 6; )
      e5.push(n4.codePointSource[n4.cursor]), n4.advanceCodePoint();
    isWhitespace(n4.codePointSource[n4.cursor]) && n4.advanceCodePoint();
    const t5 = parseInt(String.fromCodePoint(...e5), 16);
    return 0 === t5 ? q : (r5 = t5) >= 55296 && r5 <= 57343 || t5 > D ? q : t5;
  }
  var r5;
  return o5;
}
function consumeIdentSequence(e4, n4) {
  const o5 = [];
  for (; ; )
    if (isIdentCodePoint(n4.codePointSource[n4.cursor]))
      o5.push(n4.codePointSource[n4.cursor]), n4.advanceCodePoint();
    else {
      if (!checkIfTwoCodePointsAreAValidEscape(n4))
        return o5;
      n4.advanceCodePoint(), o5.push(consumeEscapedCodePoint(e4, n4));
    }
}
function consumeHashToken(n4, r5) {
  if (r5.advanceCodePoint(), void 0 !== r5.codePointSource[r5.cursor] && (isIdentCodePoint(r5.codePointSource[r5.cursor]) || checkIfTwoCodePointsAreAValidEscape(r5))) {
    let t5 = o3.Unrestricted;
    checkIfThreeCodePointsWouldStartAnIdentSequence(0, r5) && (t5 = o3.ID);
    const i5 = consumeIdentSequence(n4, r5);
    return [e3.Hash, r5.source.slice(r5.representationStart, r5.representationEnd + 1), r5.representationStart, r5.representationEnd, { value: String.fromCodePoint(...i5), type: t5 }];
  }
  return [e3.Delim, "#", r5.representationStart, r5.representationEnd, { value: "#" }];
}
function consumeNumber(e4, o5) {
  let r5 = n2.Integer;
  for (o5.codePointSource[o5.cursor] !== x && o5.codePointSource[o5.cursor] !== h || o5.advanceCodePoint(); isDigitCodePoint(o5.codePointSource[o5.cursor]); )
    o5.advanceCodePoint();
  if (o5.codePointSource[o5.cursor] === l && isDigitCodePoint(o5.codePointSource[o5.cursor + 1]))
    for (o5.advanceCodePoint(2), r5 = n2.Number; isDigitCodePoint(o5.codePointSource[o5.cursor]); )
      o5.advanceCodePoint();
  if (o5.codePointSource[o5.cursor] === v || o5.codePointSource[o5.cursor] === m) {
    if (isDigitCodePoint(o5.codePointSource[o5.cursor + 1]))
      o5.advanceCodePoint(2);
    else {
      if (o5.codePointSource[o5.cursor + 1] !== h && o5.codePointSource[o5.cursor + 1] !== x || !isDigitCodePoint(o5.codePointSource[o5.cursor + 2]))
        return r5;
      o5.advanceCodePoint(3);
    }
    for (r5 = n2.Number; isDigitCodePoint(o5.codePointSource[o5.cursor]); )
      o5.advanceCodePoint();
  }
  return r5;
}
function consumeNumericToken(n4, o5) {
  let r5;
  {
    const e4 = o5.codePointSource[o5.cursor];
    e4 === h ? r5 = "-" : e4 === x && (r5 = "+");
  }
  const t5 = consumeNumber(0, o5), i5 = parseFloat(o5.source.slice(o5.representationStart, o5.representationEnd + 1)) || 0;
  if (checkIfThreeCodePointsWouldStartAnIdentSequence(0, o5)) {
    const c2 = consumeIdentSequence(n4, o5);
    return [e3.Dimension, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: i5, signCharacter: r5, type: t5, unit: String.fromCodePoint(...c2) }];
  }
  return o5.codePointSource[o5.cursor] === L ? (o5.advanceCodePoint(), [e3.Percentage, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: i5, signCharacter: r5 }]) : [e3.Number, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: i5, signCharacter: r5, type: t5 }];
}
function consumeWhiteSpace(n4) {
  for (; isWhitespace(n4.codePointSource[n4.cursor]); )
    n4.advanceCodePoint();
  return [e3.Whitespace, n4.source.slice(n4.representationStart, n4.representationEnd + 1), n4.representationStart, n4.representationEnd, void 0];
}
function consumeStringToken(n4, o5) {
  let r5 = "";
  const t5 = o5.readCodePoint();
  for (; ; ) {
    const i5 = o5.readCodePoint();
    if (false === i5)
      return n4.onParseError(new ParseError("Unexpected EOF while consuming a string token.", o5.representationStart, o5.representationEnd, ["4.3.5. Consume a string token", "Unexpected EOF"])), [e3.String, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }];
    if (isNewLine(i5))
      return n4.onParseError(new ParseError("Unexpected newline while consuming a string token.", o5.representationStart, o5.representationEnd, ["4.3.5. Consume a string token", "Unexpected newline"])), o5.unreadCodePoint(), [e3.BadString, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, void 0];
    if (i5 === t5)
      return [e3.String, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }];
    if (i5 !== W)
      r5 += String.fromCodePoint(i5);
    else {
      if (void 0 === o5.codePointSource[o5.cursor])
        continue;
      if (isNewLine(o5.codePointSource[o5.cursor])) {
        o5.advanceCodePoint();
        continue;
      }
      r5 += String.fromCodePoint(consumeEscapedCodePoint(n4, o5));
    }
  }
}
function checkIfCodePointsMatchURLIdent(e4) {
  return !(3 !== e4.length || e4[0] !== K && e4[0] !== M || e4[1] !== $ && e4[1] !== J || e4[2] !== _ && e4[2] !== j);
}
function consumeBadURL(e4, n4) {
  for (; ; ) {
    if (void 0 === n4.codePointSource[n4.cursor])
      return;
    if (n4.codePointSource[n4.cursor] === b)
      return void n4.advanceCodePoint();
    checkIfTwoCodePointsAreAValidEscape(n4) ? (n4.advanceCodePoint(), consumeEscapedCodePoint(e4, n4)) : n4.advanceCodePoint();
  }
}
function consumeUrlToken(n4, o5) {
  for (; isWhitespace(o5.codePointSource[o5.cursor]); )
    o5.advanceCodePoint();
  let r5 = "";
  for (; ; ) {
    if (void 0 === o5.codePointSource[o5.cursor])
      return n4.onParseError(new ParseError("Unexpected EOF while consuming a url token.", o5.representationStart, o5.representationEnd, ["4.3.6. Consume a url token", "Unexpected EOF"])), [e3.URL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }];
    if (o5.codePointSource[o5.cursor] === b)
      return o5.advanceCodePoint(), [e3.URL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }];
    if (isWhitespace(o5.codePointSource[o5.cursor])) {
      for (o5.advanceCodePoint(); isWhitespace(o5.codePointSource[o5.cursor]); )
        o5.advanceCodePoint();
      return void 0 === o5.codePointSource[o5.cursor] ? (n4.onParseError(new ParseError("Unexpected EOF while consuming a url token.", o5.representationStart, o5.representationEnd, ["4.3.6. Consume a url token", "Consume as much whitespace as possible", "Unexpected EOF"])), [e3.URL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }]) : o5.codePointSource[o5.cursor] === b ? (o5.advanceCodePoint(), [e3.URL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: r5 }]) : (consumeBadURL(n4, o5), [e3.BadURL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, void 0]);
    }
    if (o5.codePointSource[o5.cursor] === y || o5.codePointSource[o5.cursor] === t3 || o5.codePointSource[o5.cursor] === k || ((i5 = o5.codePointSource[o5.cursor]) === U || i5 === p2 || A <= i5 && i5 <= c || V <= i5 && i5 <= E))
      return consumeBadURL(n4, o5), n4.onParseError(new ParseError("Unexpected character while consuming a url token.", o5.representationStart, o5.representationEnd, ["4.3.6. Consume a url token", `Unexpected U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('), U+0028 LEFT PARENTHESIS (() or non-printable code point`])), [e3.BadURL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, void 0];
    if (o5.codePointSource[o5.cursor] === W) {
      if (checkIfTwoCodePointsAreAValidEscape(o5)) {
        o5.advanceCodePoint(), r5 += String.fromCodePoint(consumeEscapedCodePoint(n4, o5));
        continue;
      }
      return consumeBadURL(n4, o5), n4.onParseError(new ParseError("Invalid escape sequence while consuming a url token.", o5.representationStart, o5.representationEnd, ["4.3.6. Consume a url token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"])), [e3.BadURL, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, void 0];
    }
    r5 += String.fromCodePoint(o5.codePointSource[o5.cursor]), o5.advanceCodePoint();
  }
  var i5;
}
function consumeIdentLikeToken(n4, o5) {
  const r5 = consumeIdentSequence(n4, o5);
  if (o5.codePointSource[o5.cursor] !== k)
    return [e3.Ident, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: String.fromCodePoint(...r5) }];
  if (checkIfCodePointsMatchURLIdent(r5)) {
    o5.advanceCodePoint();
    let i5 = 0;
    for (; ; ) {
      const n5 = isWhitespace(o5.codePointSource[o5.cursor]), c2 = isWhitespace(o5.codePointSource[o5.cursor + 1]);
      if (n5 && c2) {
        i5 += 1, o5.advanceCodePoint(1);
        continue;
      }
      const s2 = n5 ? o5.codePointSource[o5.cursor + 1] : o5.codePointSource[o5.cursor];
      if (s2 === y || s2 === t3)
        return i5 > 0 && o5.unreadCodePoint(i5), [e3.Function, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: String.fromCodePoint(...r5) }];
      break;
    }
    return consumeUrlToken(n4, o5);
  }
  return o5.advanceCodePoint(), [e3.Function, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { value: String.fromCodePoint(...r5) }];
}
function checkIfThreeCodePointsWouldStartAUnicodeRange(e4) {
  return !(e4.codePointSource[e4.cursor] !== K && e4.codePointSource[e4.cursor] !== M || e4.codePointSource[e4.cursor + 1] !== x || e4.codePointSource[e4.cursor + 2] !== Q && !isHexDigitCodePoint(e4.codePointSource[e4.cursor + 2]));
}
function consumeUnicodeRangeToken(n4, o5) {
  o5.advanceCodePoint(2);
  const r5 = [], t5 = [];
  for (; void 0 !== o5.codePointSource[o5.cursor] && r5.length < 6 && isHexDigitCodePoint(o5.codePointSource[o5.cursor]); )
    r5.push(o5.codePointSource[o5.cursor]), o5.advanceCodePoint();
  for (; void 0 !== o5.codePointSource[o5.cursor] && r5.length < 6 && o5.codePointSource[o5.cursor] === Q; )
    0 === t5.length && t5.push(...r5), r5.push(G), t5.push(X), o5.advanceCodePoint();
  if (!t5.length && o5.codePointSource[o5.cursor] === h && isHexDigitCodePoint(o5.codePointSource[o5.cursor + 1]))
    for (o5.advanceCodePoint(); void 0 !== o5.codePointSource[o5.cursor] && t5.length < 6 && isHexDigitCodePoint(o5.codePointSource[o5.cursor]); )
      t5.push(o5.codePointSource[o5.cursor]), o5.advanceCodePoint();
  if (!t5.length) {
    const n5 = parseInt(String.fromCodePoint(...r5), 16);
    return [e3.UnicodeRange, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { startOfRange: n5, endOfRange: n5 }];
  }
  const i5 = parseInt(String.fromCodePoint(...r5), 16), c2 = parseInt(String.fromCodePoint(...t5), 16);
  return [e3.UnicodeRange, o5.source.slice(o5.representationStart, o5.representationEnd + 1), o5.representationStart, o5.representationEnd, { startOfRange: i5, endOfRange: c2 }];
}
function tokenize(e4, n4) {
  const o5 = tokenizer(e4, n4), r5 = [];
  {
    for (; !o5.endOfFile(); ) {
      const e6 = o5.nextToken();
      e6 && r5.push(e6);
    }
    const e5 = o5.nextToken();
    e5 && r5.push(e5);
  }
  return r5;
}
function tokenizer(n4, o5) {
  const r5 = n4.css.valueOf(), i5 = n4.unicodeRangesAllowed ?? false, c2 = new Reader(r5), p3 = { onParseError: o5?.onParseError ?? noop };
  return { nextToken: function nextToken() {
    c2.resetRepresentation();
    const n5 = c2.codePointSource[c2.cursor];
    if (void 0 === n5)
      return [e3.EOF, "", -1, -1, void 0];
    if (n5 === B && checkIfTwoCodePointsStartAComment(c2))
      return consumeComment(p3, c2);
    if (i5 && (n5 === K || n5 === M) && checkIfThreeCodePointsWouldStartAUnicodeRange(c2))
      return consumeUnicodeRangeToken(0, c2);
    if (isIdentStartCodePoint(n5))
      return consumeIdentLikeToken(p3, c2);
    if (isDigitCodePoint(n5))
      return consumeNumericToken(p3, c2);
    switch (n5) {
      case d:
        return c2.advanceCodePoint(), [e3.Comma, ",", c2.representationStart, c2.representationEnd, void 0];
      case u:
        return c2.advanceCodePoint(), [e3.Colon, ":", c2.representationStart, c2.representationEnd, void 0];
      case H:
        return c2.advanceCodePoint(), [e3.Semicolon, ";", c2.representationStart, c2.representationEnd, void 0];
      case k:
        return c2.advanceCodePoint(), [e3.OpenParen, "(", c2.representationStart, c2.representationEnd, void 0];
      case b:
        return c2.advanceCodePoint(), [e3.CloseParen, ")", c2.representationStart, c2.representationEnd, void 0];
      case I:
        return c2.advanceCodePoint(), [e3.OpenSquare, "[", c2.representationStart, c2.representationEnd, void 0];
      case F:
        return c2.advanceCodePoint(), [e3.CloseSquare, "]", c2.representationStart, c2.representationEnd, void 0];
      case g:
        return c2.advanceCodePoint(), [e3.OpenCurly, "{", c2.representationStart, c2.representationEnd, void 0];
      case N:
        return c2.advanceCodePoint(), [e3.CloseCurly, "}", c2.representationStart, c2.representationEnd, void 0];
      case t3:
      case y:
        return consumeStringToken(p3, c2);
      case R:
        return consumeHashToken(p3, c2);
      case x:
      case l:
        return checkIfThreeCodePointsWouldStartANumber(c2) ? consumeNumericToken(p3, c2) : (c2.advanceCodePoint(), [e3.Delim, c2.source[c2.representationStart], c2.representationStart, c2.representationEnd, { value: c2.source[c2.representationStart] }]);
      case O:
      case s:
      case C:
      case a2:
      case z:
        return consumeWhiteSpace(c2);
      case h:
        return checkIfThreeCodePointsWouldStartANumber(c2) ? consumeNumericToken(p3, c2) : checkIfThreeCodePointsWouldStartCDC(c2) ? (c2.advanceCodePoint(3), [e3.CDC, "-->", c2.representationStart, c2.representationEnd, void 0]) : checkIfThreeCodePointsWouldStartAnIdentSequence(0, c2) ? consumeIdentLikeToken(p3, c2) : (c2.advanceCodePoint(), [e3.Delim, "-", c2.representationStart, c2.representationEnd, { value: "-" }]);
      case T:
        return checkIfFourCodePointsWouldStartCDO(c2) ? (c2.advanceCodePoint(4), [e3.CDO, "<!--", c2.representationStart, c2.representationEnd, void 0]) : (c2.advanceCodePoint(), [e3.Delim, "<", c2.representationStart, c2.representationEnd, { value: "<" }]);
      case P:
        if (c2.advanceCodePoint(), checkIfThreeCodePointsWouldStartAnIdentSequence(0, c2)) {
          const n6 = consumeIdentSequence(p3, c2);
          return [e3.AtKeyword, c2.source.slice(c2.representationStart, c2.representationEnd + 1), c2.representationStart, c2.representationEnd, { value: String.fromCodePoint(...n6) }];
        }
        return [e3.Delim, "@", c2.representationStart, c2.representationEnd, { value: "@" }];
      case W:
        return checkIfTwoCodePointsAreAValidEscape(c2) ? consumeIdentLikeToken(p3, c2) : (c2.advanceCodePoint(), p3.onParseError(new ParseError('Invalid escape sequence after "\\"', c2.representationStart, c2.representationEnd, ["4.3.1. Consume a token", "U+005C REVERSE SOLIDUS (\\)", "The input stream does not start with a valid escape sequence"])), [e3.Delim, "\\", c2.representationStart, c2.representationEnd, { value: "\\" }]);
    }
    return c2.advanceCodePoint(), [e3.Delim, c2.source[c2.representationStart], c2.representationStart, c2.representationEnd, { value: c2.source[c2.representationStart] }];
  }, endOfFile: function endOfFile() {
    return void 0 === c2.codePointSource[c2.cursor];
  } };
}
function noop() {
}

// node_modules/@csstools/css-color-parser/dist/index.mjs
init_shim();

// node_modules/@csstools/color-helpers/dist/index.mjs
init_shim();
function multiplyMatrices(t5, _3) {
  const n4 = t5.length;
  let o5, e4;
  o5 = Array.isArray(t5[0]) ? t5 : [t5], e4 = Array.isArray(_3[0]) ? _3 : _3.map((t6) => [t6]);
  const r5 = e4[0].length, a3 = e4[0].map((t6, _4) => e4.map((t7) => t7[_4]));
  let i5 = o5.map((t6) => a3.map((_4) => Array.isArray(t6) ? t6.reduce((t7, n5, o6) => t7 + n5 * (_4[o6] || 0), 0) : _4.reduce((_5, n5) => _5 + n5 * t6, 0)));
  return 1 === n4 && (i5 = i5[0]), 1 === r5 ? i5.map((t6) => t6[0]) : i5;
}
function D65_to_D50(t5) {
  return multiplyMatrices([[1.0479297925449969, 0.022946870601609652, -0.05019226628920524], [0.02962780877005599, 0.9904344267538799, -0.017073799063418826], [-0.009243040646204504, 0.015055191490298152, 0.7518742814281371]], t5);
}
function HSL_to_sRGB(t5) {
  let _3 = t5[0], n4 = t5[1], o5 = t5[2];
  function f2(t6) {
    const e4 = (t6 + _3 / 30) % 12, r5 = n4 * Math.min(o5, 1 - o5);
    return o5 - r5 * Math.max(-1, Math.min(e4 - 3, 9 - e4, 1));
  }
  return _3 %= 360, _3 < 0 && (_3 += 360), n4 /= 100, o5 /= 100, [f2(0), f2(8), f2(4)];
}
function HWB_to_sRGB(t5) {
  const _3 = t5[0];
  let n4 = t5[1], o5 = t5[2];
  if (n4 /= 100, o5 /= 100, n4 + o5 >= 1) {
    const t6 = n4 / (n4 + o5);
    return [t6, t6, t6];
  }
  const e4 = HSL_to_sRGB([_3, 100, 50]);
  for (let t6 = 0; t6 < 3; t6++)
    e4[t6] *= 1 - n4 - o5, e4[t6] += n4;
  return e4;
}
var t4 = [0.3457 / 0.3585, 1, 0.2958 / 0.3585];
function Lab_to_XYZ(_3) {
  const n4 = 24389 / 27, o5 = 216 / 24389, e4 = [];
  e4[1] = (_3[0] + 16) / 116, e4[0] = _3[1] / 500 + e4[1], e4[2] = e4[1] - _3[2] / 200;
  return [Math.pow(e4[0], 3) > o5 ? Math.pow(e4[0], 3) : (116 * e4[0] - 16) / n4, _3[0] > 8 ? Math.pow((_3[0] + 16) / 116, 3) : _3[0] / n4, Math.pow(e4[2], 3) > o5 ? Math.pow(e4[2], 3) : (116 * e4[2] - 16) / n4].map((_4, n5) => _4 * t4[n5]);
}
function OKLCH_to_OKLab(t5) {
  return [t5[0], t5[1] * Math.cos(t5[2] * Math.PI / 180), t5[1] * Math.sin(t5[2] * Math.PI / 180)];
}
function OKLab_to_XYZ(t5) {
  const _3 = multiplyMatrices([[1, 0.3963377773761749, 0.2158037573099136], [1, -0.1055613458156586, -0.0638541728258133], [1, -0.0894841775298119, -1.2914855480194092]], t5);
  return multiplyMatrices([[1.2268798758459243, -0.5578149944602171, 0.2813910456659647], [-0.0405757452148008, 1.112286803280317, -0.0717110580655164], [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]], _3.map((t6) => t6 ** 3));
}
function lin_2020(t5) {
  const _3 = 1.09929682680944;
  return t5.map(function(t6) {
    const n4 = t6 < 0 ? -1 : 1, o5 = Math.abs(t6);
    return o5 < 0.08124285829863151 ? t6 / 4.5 : n4 * Math.pow((o5 + _3 - 1) / _3, 1 / 0.45);
  });
}
function lin_sRGB(t5) {
  return t5.map(function(t6) {
    const _3 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return n4 <= 0.04045 ? t6 / 12.92 : _3 * Math.pow((n4 + 0.055) / 1.055, 2.4);
  });
}
function lin_P3(t5) {
  return lin_sRGB(t5);
}
function lin_P3_to_XYZ(t5) {
  return multiplyMatrices([[608311 / 1250200, 189793 / 714400, 198249 / 1000160], [35783 / 156275, 247089 / 357200, 198249 / 2500400], [0, 32229 / 714400, 5220557 / 5000800]], t5);
}
function lin_sRGB_to_XYZ(t5) {
  return multiplyMatrices([[506752 / 1228815, 87881 / 245763, 12673 / 70218], [87098 / 409605, 175762 / 245763, 12673 / 175545], [7918 / 409605, 87881 / 737289, 1001167 / 1053270]], t5);
}
function D50_to_D65(t5) {
  return multiplyMatrices([[0.955473421488075, -0.02309845494876471, 0.06325924320057072], [-0.0283697093338637, 1.0099953980813041, 0.021041441191917323], [0.012314014864481998, -0.020507649298898964, 1.330365926242124]], t5);
}
function XYZ_to_lin_sRGB(t5) {
  return multiplyMatrices([[12831 / 3959, -329 / 214, -1974 / 3959], [-851781 / 878810, 1648619 / 878810, 36519 / 878810], [705 / 12673, -2585 / 12673, 705 / 667]], t5);
}
function gam_sRGB(t5) {
  return t5.map(function(t6) {
    const _3 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return n4 > 31308e-7 ? _3 * (1.055 * Math.pow(n4, 1 / 2.4) - 0.055) : 12.92 * t6;
  });
}
function sRGB_to_HSL(t5) {
  const _3 = t5[0], n4 = t5[1], o5 = t5[2], e4 = Math.max(_3, n4, o5), r5 = Math.min(_3, n4, o5), a3 = (r5 + e4) / 2, i5 = e4 - r5;
  let l2 = NaN, u3 = 0;
  if (0 !== Math.round(1e5 * i5)) {
    switch (u3 = 0 === Math.round(1e5 * a3) || 1e5 === Math.round(1e5 * a3) ? 0 : (e4 - a3) / Math.min(a3, 1 - a3), e4) {
      case _3:
        l2 = (n4 - o5) / i5 + (n4 < o5 ? 6 : 0);
        break;
      case n4:
        l2 = (o5 - _3) / i5 + 2;
        break;
      case o5:
        l2 = (_3 - n4) / i5 + 4;
    }
    l2 *= 60;
  }
  return [l2, 100 * u3, 100 * a3];
}
function XYZ_to_lin_P3(t5) {
  return multiplyMatrices([[446124 / 178915, -333277 / 357830, -72051 / 178915], [-14852 / 17905, 63121 / 35810, 423 / 17905], [11844 / 330415, -50337 / 660830, 316169 / 330415]], t5);
}
function gam_P3(t5) {
  return gam_sRGB(t5);
}
function XYZ_to_Lab(_3) {
  const n4 = _3.map((_4, n5) => _4 / t4[n5]).map((t5) => t5 > 0.008856451679035631 ? Math.cbrt(t5) : (903.2962962962963 * t5 + 16) / 116);
  return [116 * n4[1] - 16, 500 * (n4[0] - n4[1]), 200 * (n4[1] - n4[2])];
}
function XYZ_to_OKLab(t5) {
  const _3 = multiplyMatrices([[0.819022437996703, 0.3619062600528904, -0.1288737815209879], [0.0329836539323885, 0.9292868615863434, 0.0361446663506424], [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]], t5);
  return multiplyMatrices([[0.210454268309314, 0.7936177747023054, -0.0040720430116193], [1.9779985324311684, -2.42859224204858, 0.450593709617411], [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]], _3.map((t6) => Math.cbrt(t6)));
}
function Lab_to_LCH(t5) {
  const _3 = 180 * Math.atan2(t5[2], t5[1]) / Math.PI;
  return [t5[0], Math.sqrt(Math.pow(t5[1], 2) + Math.pow(t5[2], 2)), _3 >= 0 ? _3 : _3 + 360];
}
function OKLab_to_OKLCH(t5) {
  const _3 = 180 * Math.atan2(t5[2], t5[1]) / Math.PI;
  return [t5[0], Math.sqrt(t5[1] ** 2 + t5[2] ** 2), _3 >= 0 ? _3 : _3 + 360];
}
function gam_2020(t5) {
  const _3 = 1.09929682680944;
  return t5.map(function(t6) {
    const n4 = t6 < 0 ? -1 : 1, o5 = Math.abs(t6);
    return o5 > 0.018053968510807 ? n4 * (_3 * Math.pow(o5, 0.45) - (_3 - 1)) : 4.5 * t6;
  });
}
function sRGB_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = lin_sRGB(_3), _3 = lin_sRGB_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_sRGB(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_lin_sRGB(_3), _3 = gam_sRGB(_3), _3;
}
function HSL_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = HSL_to_sRGB(_3), _3 = lin_sRGB(_3), _3 = lin_sRGB_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_HSL(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_lin_sRGB(_3), _3 = gam_sRGB(_3), _3 = sRGB_to_HSL(_3), _3;
}
function HWB_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = HWB_to_sRGB(_3), _3 = lin_sRGB(_3), _3 = lin_sRGB_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_HWB(t5) {
  let _3 = t5;
  _3 = D50_to_D65(_3), _3 = XYZ_to_lin_sRGB(_3);
  const n4 = gam_sRGB(_3);
  _3 = sRGB_to_HSL(n4);
  const o5 = Math.min(n4[0], n4[1], n4[2]), e4 = 1 - Math.max(n4[0], n4[1], n4[2]);
  return [_3[0], 100 * o5, 100 * e4];
}
function Lab_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = Lab_to_XYZ(_3), _3;
}
function XYZ_D50_to_Lab(t5) {
  let _3 = t5;
  return _3 = XYZ_to_Lab(_3), _3;
}
function LCH_to_XYZ_D50(t5) {
  let _3 = t5;
  var n4;
  return _3 = [(n4 = _3)[0], n4[1] * Math.cos(n4[2] * Math.PI / 180), n4[1] * Math.sin(n4[2] * Math.PI / 180)], _3 = Lab_to_XYZ(_3), _3;
}
function XYZ_D50_to_LCH(t5) {
  let _3 = t5;
  return _3 = XYZ_to_Lab(_3), _3 = Lab_to_LCH(_3), _3;
}
function OKLab_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = OKLab_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_OKLab(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_OKLab(_3), _3;
}
function OKLCH_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = OKLCH_to_OKLab(_3), _3 = OKLab_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_OKLCH(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_OKLab(_3), _3 = OKLab_to_OKLCH(_3), _3;
}
function lin_sRGB_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = lin_sRGB_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_lin_sRGB(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_lin_sRGB(_3), _3;
}
function a98_RGB_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = _3.map(function(t6) {
    const _4 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return _4 * Math.pow(n4, 563 / 256);
  }), _3 = multiplyMatrices([[573536 / 994567, 263643 / 1420810, 187206 / 994567], [591459 / 1989134, 6239551 / 9945670, 374412 / 4972835], [53769 / 1989134, 351524 / 4972835, 4929758 / 4972835]], _3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_a98_RGB(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = multiplyMatrices([[1829569 / 896150, -506331 / 896150, -308931 / 896150], [-851781 / 878810, 1648619 / 878810, 36519 / 878810], [16779 / 1248040, -147721 / 1248040, 1266979 / 1248040]], _3), _3 = _3.map(function(t6) {
    const _4 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return _4 * Math.pow(n4, 256 / 563);
  }), _3;
}
function P3_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = lin_P3(_3), _3 = lin_P3_to_XYZ(_3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_P3(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = XYZ_to_lin_P3(_3), _3 = gam_P3(_3), _3;
}
function rec_2020_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = lin_2020(_3), _3 = multiplyMatrices([[63426534 / 99577255, 20160776 / 139408157, 47086771 / 278816314], [26158966 / 99577255, 0.677998071518871, 8267143 / 139408157], [0, 19567812 / 697040785, 1.0609850577107909]], _3), _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_rec_2020(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3 = multiplyMatrices([[30757411 / 17917100, -6372589 / 17917100, -4539589 / 17917100], [-0.666684351832489, 1.616481236634939, 467509 / 29648200], [792561 / 44930125, -1921689 / 44930125, 0.942103121235474]], _3), _3 = gam_2020(_3), _3;
}
function ProPhoto_RGB_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = _3.map(function(t6) {
    const _4 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return n4 <= 0.03125 ? t6 / 16 : _4 * Math.pow(n4, 1.8);
  }), _3 = multiplyMatrices([[0.7977604896723027, 0.13518583717574031, 0.0313493495815248], [0.2880711282292934, 0.7118432178101014, 8565396060525902e-20], [0, 0, 0.8251046025104601]], _3), _3;
}
function XYZ_D50_to_ProPhoto(t5) {
  let _3 = t5;
  return _3 = multiplyMatrices([[1.3457989731028281, -0.25558010007997534, -0.05110628506753401], [-0.5446224939028347, 1.5082327413132781, 0.02053603239147973], [0, 0, 1.2119675456389454]], _3), _3 = _3.map(function(t6) {
    const _4 = t6 < 0 ? -1 : 1, n4 = Math.abs(t6);
    return n4 >= 1953125e-9 ? _4 * Math.pow(n4, 1 / 1.8) : 16 * t6;
  }), _3;
}
function XYZ_D65_to_XYZ_D50(t5) {
  let _3 = t5;
  return _3 = D65_to_D50(_3), _3;
}
function XYZ_D50_to_XYZ_D65(t5) {
  let _3 = t5;
  return _3 = D50_to_D65(_3), _3;
}
function XYZ_D50_to_XYZ_D50(t5) {
  return t5;
}
function inGamut(t5) {
  const [_3, n4, o5] = t5;
  return _3 >= -1e-4 && _3 <= 1.0001 && n4 >= -1e-4 && n4 <= 1.0001 && o5 >= -1e-4 && o5 <= 1.0001;
}
function clip(t5) {
  return t5.map((t6) => t6 < 0 ? 0 : t6 > 1 ? 1 : t6);
}
function deltaEOK(t5, _3) {
  const [n4, o5, e4] = t5, [r5, a3, i5] = _3, l2 = n4 - r5, u3 = o5 - a3, c2 = e4 - i5;
  return Math.sqrt(l2 ** 2 + u3 ** 2 + c2 ** 2);
}
var _2 = 0.02;
var n3 = 1e-5;
function binarySearchGamut(t5, o5, e4) {
  const r5 = t5;
  let a3 = 0, i5 = r5[1];
  for (; i5 - a3 > n3; ) {
    const t6 = (a3 + i5) / 2;
    r5[1] = t6;
    const n4 = o5(r5);
    if (inGamut(n4)) {
      a3 = t6;
      continue;
    }
    const l2 = clip(n4);
    if (deltaEOK(OKLCH_to_OKLab(e4(l2)), OKLCH_to_OKLab(r5)) < _2)
      return l2;
    i5 = t6;
  }
  return clip(o5([...r5]));
}
function mapGamut(t5, _3, n4) {
  return binarySearchGamut(t5, _3, n4);
}
var o4 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };

// node_modules/@csstools/css-parser-algorithms/dist/index.mjs
init_shim();
var r4;
function walkerIndexGenerator(e4) {
  let n4 = e4.slice();
  return (e5, t5, o5) => {
    let s2 = -1;
    for (let i5 = n4.indexOf(t5); i5 < n4.length && (s2 = e5.indexOf(n4[i5]), -1 === s2 || s2 < o5); i5++)
      ;
    return -1 === s2 || s2 === o5 && t5 === e5[o5] && (s2++, s2 >= e5.length) ? -1 : (n4 = e5.slice(), s2);
  };
}
function consumeComponentValue(n4, t5) {
  const o5 = t5[0];
  if (o5[0] === e3.OpenParen || o5[0] === e3.OpenCurly || o5[0] === e3.OpenSquare) {
    const e4 = consumeSimpleBlock(n4, t5);
    return { advance: e4.advance, node: e4.node };
  }
  if (o5[0] === e3.Function) {
    const e4 = consumeFunction(n4, t5);
    return { advance: e4.advance, node: e4.node };
  }
  if (o5[0] === e3.Whitespace) {
    const e4 = consumeWhitespace(n4, t5);
    return { advance: e4.advance, node: e4.node };
  }
  if (o5[0] === e3.Comment) {
    const e4 = consumeComment2(n4, t5);
    return { advance: e4.advance, node: e4.node };
  }
  return { advance: 1, node: new TokenNode(o5) };
}
!function(e4) {
  e4.Function = "function", e4.SimpleBlock = "simple-block", e4.Whitespace = "whitespace", e4.Comment = "comment", e4.Token = "token";
}(r4 || (r4 = {}));
var ContainerNodeBaseClass = class {
  constructor() {
    __publicField(this, "value", []);
  }
  indexOf(e4) {
    return this.value.indexOf(e4);
  }
  at(e4) {
    if ("number" == typeof e4)
      return e4 < 0 && (e4 = this.value.length + e4), this.value[e4];
  }
  forEach(e4, n4) {
    if (0 === this.value.length)
      return;
    const t5 = walkerIndexGenerator(this.value);
    let o5 = 0;
    for (; o5 < this.value.length; ) {
      const s2 = this.value[o5];
      let i5;
      if (n4 && (i5 = { ...n4 }), false === e4({ node: s2, parent: this, state: i5 }, o5))
        return false;
      if (o5 = t5(this.value, s2, o5), -1 === o5)
        break;
    }
  }
  walk(e4, n4) {
    0 !== this.value.length && this.forEach((n5, t5) => false !== e4(n5, t5) && ((!("walk" in n5.node) || !this.value.includes(n5.node) || false !== n5.node.walk(e4, n5.state)) && void 0), n4);
  }
};
var FunctionNode = class _FunctionNode extends ContainerNodeBaseClass {
  constructor(e4, n4, t5) {
    super();
    __publicField(this, "type", r4.Function);
    __publicField(this, "name");
    __publicField(this, "endToken");
    this.name = e4, this.endToken = n4, this.value = t5;
  }
  getName() {
    return this.name[4].value;
  }
  normalize() {
    this.endToken[0] === e3.EOF && (this.endToken = [e3.CloseParen, ")", -1, -1, void 0]);
  }
  tokens() {
    return this.endToken[0] === e3.EOF ? [this.name, ...this.value.flatMap((e4) => e4.tokens())] : [this.name, ...this.value.flatMap((e4) => e4.tokens()), this.endToken];
  }
  toString() {
    const e4 = this.value.map((e5) => isToken(e5) ? stringify4(e5) : e5.toString()).join("");
    return stringify4(this.name) + e4 + stringify4(this.endToken);
  }
  toJSON() {
    return { type: this.type, name: this.getName(), tokens: this.tokens(), value: this.value.map((e4) => e4.toJSON()) };
  }
  isFunctionNode() {
    return _FunctionNode.isFunctionNode(this);
  }
  static isFunctionNode(e4) {
    return !!e4 && (e4 instanceof _FunctionNode && e4.type === r4.Function);
  }
};
function consumeFunction(n4, t5) {
  const o5 = [];
  let i5 = 1;
  for (; ; ) {
    const r5 = t5[i5];
    if (!r5 || r5[0] === e3.EOF)
      return n4.onParseError(new ParseError("Unexpected EOF while consuming a function.", t5[0][2], t5[t5.length - 1][3], ["5.4.9. Consume a function", "Unexpected EOF"])), { advance: t5.length, node: new FunctionNode(t5[0], r5, o5) };
    if (r5[0] === e3.CloseParen)
      return { advance: i5 + 1, node: new FunctionNode(t5[0], r5, o5) };
    if (r5[0] === e3.Comment || r5[0] === e3.Whitespace) {
      const e4 = consumeAllCommentsAndWhitespace(n4, t5.slice(i5));
      i5 += e4.advance, o5.push(...e4.nodes);
      continue;
    }
    const a3 = consumeComponentValue(n4, t5.slice(i5));
    i5 += a3.advance, o5.push(a3.node);
  }
}
var SimpleBlockNode = class _SimpleBlockNode extends ContainerNodeBaseClass {
  constructor(e4, n4, t5) {
    super();
    __publicField(this, "type", r4.SimpleBlock);
    __publicField(this, "startToken");
    __publicField(this, "endToken");
    this.startToken = e4, this.endToken = n4, this.value = t5;
  }
  normalize() {
    if (this.endToken[0] === e3.EOF) {
      const e4 = mirrorVariant(this.startToken);
      e4 && (this.endToken = e4);
    }
  }
  tokens() {
    return this.endToken[0] === e3.EOF ? [this.startToken, ...this.value.flatMap((e4) => e4.tokens())] : [this.startToken, ...this.value.flatMap((e4) => e4.tokens()), this.endToken];
  }
  toString() {
    const e4 = this.value.map((e5) => isToken(e5) ? stringify4(e5) : e5.toString()).join("");
    return stringify4(this.startToken) + e4 + stringify4(this.endToken);
  }
  toJSON() {
    return { type: this.type, startToken: this.startToken, tokens: this.tokens(), value: this.value.map((e4) => e4.toJSON()) };
  }
  isSimpleBlockNode() {
    return _SimpleBlockNode.isSimpleBlockNode(this);
  }
  static isSimpleBlockNode(e4) {
    return !!e4 && (e4 instanceof _SimpleBlockNode && e4.type === r4.SimpleBlock);
  }
};
function consumeSimpleBlock(n4, t5) {
  const o5 = mirrorVariantType(t5[0][0]);
  if (!o5)
    throw new Error("Failed to parse, a mirror variant must exist for all block open tokens.");
  const r5 = [];
  let a3 = 1;
  for (; ; ) {
    const i5 = t5[a3];
    if (!i5 || i5[0] === e3.EOF)
      return n4.onParseError(new ParseError("Unexpected EOF while consuming a simple block.", t5[0][2], t5[t5.length - 1][3], ["5.4.8. Consume a simple block", "Unexpected EOF"])), { advance: t5.length, node: new SimpleBlockNode(t5[0], i5, r5) };
    if (i5[0] === o5)
      return { advance: a3 + 1, node: new SimpleBlockNode(t5[0], i5, r5) };
    if (i5[0] === e3.Comment || i5[0] === e3.Whitespace) {
      const e4 = consumeAllCommentsAndWhitespace(n4, t5.slice(a3));
      a3 += e4.advance, r5.push(...e4.nodes);
      continue;
    }
    const c2 = consumeComponentValue(n4, t5.slice(a3));
    a3 += c2.advance, r5.push(c2.node);
  }
}
var WhitespaceNode = class _WhitespaceNode {
  constructor(e4) {
    __publicField(this, "type", r4.Whitespace);
    __publicField(this, "value");
    this.value = e4;
  }
  tokens() {
    return this.value;
  }
  toString() {
    return stringify4(...this.value);
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isWhitespaceNode() {
    return _WhitespaceNode.isWhitespaceNode(this);
  }
  static isWhitespaceNode(e4) {
    return !!e4 && (e4 instanceof _WhitespaceNode && e4.type === r4.Whitespace);
  }
};
function consumeWhitespace(n4, t5) {
  let o5 = 0;
  for (; ; ) {
    if (t5[o5][0] !== e3.Whitespace)
      return { advance: o5, node: new WhitespaceNode(t5.slice(0, o5)) };
    o5++;
  }
}
var CommentNode = class _CommentNode {
  constructor(e4) {
    __publicField(this, "type", r4.Comment);
    __publicField(this, "value");
    this.value = e4;
  }
  tokens() {
    return [this.value];
  }
  toString() {
    return stringify4(this.value);
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isCommentNode() {
    return _CommentNode.isCommentNode(this);
  }
  static isCommentNode(e4) {
    return !!e4 && (e4 instanceof _CommentNode && e4.type === r4.Comment);
  }
};
function consumeComment2(e4, n4) {
  return { advance: 1, node: new CommentNode(n4[0]) };
}
function consumeAllCommentsAndWhitespace(n4, t5) {
  const o5 = [];
  let s2 = 0;
  for (; ; )
    if (t5[s2][0] !== e3.Whitespace) {
      if (t5[s2][0] !== e3.Comment)
        return { advance: s2, nodes: o5 };
      o5.push(new CommentNode(t5[s2])), s2++;
    } else {
      const e4 = consumeWhitespace(0, t5.slice(s2));
      s2 += e4.advance, o5.push(e4.node);
    }
}
var TokenNode = class _TokenNode {
  constructor(e4) {
    __publicField(this, "type", r4.Token);
    __publicField(this, "value");
    this.value = e4;
  }
  tokens() {
    return [this.value];
  }
  toString() {
    return this.value[1];
  }
  toJSON() {
    return { type: this.type, tokens: this.tokens() };
  }
  isTokenNode() {
    return _TokenNode.isTokenNode(this);
  }
  static isTokenNode(e4) {
    return !!e4 && (e4 instanceof _TokenNode && e4.type === r4.Token);
  }
};
function parseCommaSeparatedListOfComponentValues(n4, t5) {
  const o5 = { onParseError: t5?.onParseError ?? (() => {
  }) }, s2 = [...n4];
  if (0 === n4.length)
    return [];
  s2[s2.length - 1][0] !== e3.EOF && s2.push([e3.EOF, "", s2[s2.length - 1][2], s2[s2.length - 1][3], void 0]);
  const i5 = [];
  let r5 = [], a3 = 0;
  for (; ; ) {
    if (!s2[a3] || s2[a3][0] === e3.EOF)
      return r5.length && i5.push(r5), i5;
    if (s2[a3][0] === e3.Comma) {
      i5.push(r5), r5 = [], a3++;
      continue;
    }
    const t6 = consumeComponentValue(o5, n4.slice(a3));
    r5.push(t6.node), a3 += t6.advance;
  }
}
function forEach(e4, n4, t5) {
  if (0 === e4.length)
    return;
  const o5 = walkerIndexGenerator(e4);
  let s2 = 0;
  for (; s2 < e4.length; ) {
    const i5 = e4[s2];
    let r5;
    if (t5 && (r5 = { ...t5 }), false === n4({ node: i5, parent: { value: e4 }, state: r5 }, s2))
      return false;
    if (s2 = o5(e4, i5, s2), -1 === s2)
      break;
  }
}
function walk(e4, n4, t5) {
  0 !== e4.length && forEach(e4, (t6, o5) => false !== n4(t6, o5) && ((!("walk" in t6.node) || !e4.includes(t6.node) || false !== t6.node.walk(n4, t6.state)) && void 0), t5);
}
function replaceComponentValues(e4, n4) {
  for (let t5 = 0; t5 < e4.length; t5++) {
    walk(e4[t5], (e5, t6) => {
      if ("number" != typeof t6)
        return;
      const o5 = n4(e5.node);
      o5 && e5.parent.value.splice(t6, 1, o5);
    });
  }
  return e4;
}
function stringify5(e4) {
  return e4.map((e5) => e5.map((e6) => stringify4(...e6.tokens())).join("")).join(",");
}
function isSimpleBlockNode(e4) {
  return SimpleBlockNode.isSimpleBlockNode(e4);
}
function isFunctionNode(e4) {
  return FunctionNode.isFunctionNode(e4);
}
function isWhitespaceNode(e4) {
  return WhitespaceNode.isWhitespaceNode(e4);
}
function isCommentNode(e4) {
  return CommentNode.isCommentNode(e4);
}
function isTokenNode(e4) {
  return TokenNode.isTokenNode(e4);
}

// node_modules/@csstools/css-calc/dist/index.mjs
init_shim();
var g2 = /[A-Z]/g;
function toLowerCaseAZ(e4) {
  return e4.replace(g2, (e5) => String.fromCharCode(e5.charCodeAt(0) + 32));
}
var b2 = { cm: "px", in: "px", mm: "px", pc: "px", pt: "px", px: "px", q: "px", deg: "deg", grad: "deg", rad: "deg", turn: "deg", ms: "s", s: "s", hz: "hz", khz: "hz" };
var d2 = /* @__PURE__ */ new Map([["cm", (e4) => e4], ["mm", (e4) => 10 * e4], ["q", (e4) => 40 * e4], ["in", (e4) => e4 / 2.54], ["pc", (e4) => e4 / 2.54 * 6], ["pt", (e4) => e4 / 2.54 * 72], ["px", (e4) => e4 / 2.54 * 96]]);
var w2 = /* @__PURE__ */ new Map([["deg", (e4) => e4], ["grad", (e4) => e4 / 0.9], ["rad", (e4) => e4 / 180 * Math.PI], ["turn", (e4) => e4 / 360]]);
var h2 = /* @__PURE__ */ new Map([["deg", (e4) => 0.9 * e4], ["grad", (e4) => e4], ["rad", (e4) => 0.9 * e4 / 180 * Math.PI], ["turn", (e4) => 0.9 * e4 / 360]]);
var C2 = /* @__PURE__ */ new Map([["hz", (e4) => e4], ["khz", (e4) => e4 / 1e3]]);
var I2 = /* @__PURE__ */ new Map([["cm", (e4) => 2.54 * e4], ["mm", (e4) => 25.4 * e4], ["q", (e4) => 25.4 * e4 * 4], ["in", (e4) => e4], ["pc", (e4) => 6 * e4], ["pt", (e4) => 72 * e4], ["px", (e4) => 96 * e4]]);
var S2 = /* @__PURE__ */ new Map([["hz", (e4) => 1e3 * e4], ["khz", (e4) => e4]]);
var y2 = /* @__PURE__ */ new Map([["cm", (e4) => e4 / 10], ["mm", (e4) => e4], ["q", (e4) => 4 * e4], ["in", (e4) => e4 / 25.4], ["pc", (e4) => e4 / 25.4 * 6], ["pt", (e4) => e4 / 25.4 * 72], ["px", (e4) => e4 / 25.4 * 96]]);
var M2 = /* @__PURE__ */ new Map([["ms", (e4) => e4], ["s", (e4) => e4 / 1e3]]);
var P2 = /* @__PURE__ */ new Map([["cm", (e4) => e4 / 6 * 2.54], ["mm", (e4) => e4 / 6 * 25.4], ["q", (e4) => e4 / 6 * 25.4 * 4], ["in", (e4) => e4 / 6], ["pc", (e4) => e4], ["pt", (e4) => e4 / 6 * 72], ["px", (e4) => e4 / 6 * 96]]);
var D2 = /* @__PURE__ */ new Map([["cm", (e4) => e4 / 72 * 2.54], ["mm", (e4) => e4 / 72 * 25.4], ["q", (e4) => e4 / 72 * 25.4 * 4], ["in", (e4) => e4 / 72], ["pc", (e4) => e4 / 72 * 6], ["pt", (e4) => e4], ["px", (e4) => e4 / 72 * 96]]);
var T2 = /* @__PURE__ */ new Map([["cm", (e4) => e4 / 96 * 2.54], ["mm", (e4) => e4 / 96 * 25.4], ["q", (e4) => e4 / 96 * 25.4 * 4], ["in", (e4) => e4 / 96], ["pc", (e4) => e4 / 96 * 6], ["pt", (e4) => e4 / 96 * 72], ["px", (e4) => e4]]);
var A2 = /* @__PURE__ */ new Map([["cm", (e4) => e4 / 4 / 10], ["mm", (e4) => e4 / 4], ["q", (e4) => e4], ["in", (e4) => e4 / 4 / 25.4], ["pc", (e4) => e4 / 4 / 25.4 * 6], ["pt", (e4) => e4 / 4 / 25.4 * 72], ["px", (e4) => e4 / 4 / 25.4 * 96]]);
var k2 = /* @__PURE__ */ new Map([["deg", (e4) => 180 * e4 / Math.PI], ["grad", (e4) => 180 * e4 / Math.PI / 0.9], ["rad", (e4) => e4], ["turn", (e4) => 180 * e4 / Math.PI / 360]]);
var F2 = /* @__PURE__ */ new Map([["ms", (e4) => 1e3 * e4], ["s", (e4) => e4]]);
var x2 = /* @__PURE__ */ new Map([["deg", (e4) => 360 * e4], ["grad", (e4) => 360 * e4 / 0.9], ["rad", (e4) => 360 * e4 / 180 * Math.PI], ["turn", (e4) => e4]]);
var O2 = /* @__PURE__ */ new Map([["cm", d2], ["mm", y2], ["q", A2], ["in", I2], ["pc", P2], ["pt", D2], ["px", T2], ["ms", M2], ["s", F2], ["deg", w2], ["grad", h2], ["rad", k2], ["turn", x2], ["hz", C2], ["khz", S2]]);
function convertUnit(e4, n4) {
  if (e4[0] !== e3.Dimension)
    return n4;
  if (n4[0] !== e3.Dimension)
    return n4;
  const t5 = toLowerCaseAZ(e4[4].unit), r5 = toLowerCaseAZ(n4[4].unit);
  if (t5 === r5)
    return n4;
  const u3 = O2.get(r5);
  if (!u3)
    return n4;
  const i5 = u3.get(t5);
  if (!i5)
    return n4;
  const a3 = i5(n4[4].value);
  return [e3.Dimension, a3.toString() + e4[4].unit, n4[2], n4[3], { value: a3, unit: e4[4].unit, type: Number.isInteger(a3) ? n2.Integer : n2.Number }];
}
function toCanonicalUnit(e4) {
  if (e4[0] !== e3.Dimension)
    return e4;
  const n4 = toLowerCaseAZ(e4[4].unit), t5 = b2[n4];
  if (n4 === t5)
    return e4;
  const r5 = O2.get(n4);
  if (!r5)
    return e4;
  const u3 = r5.get(t5);
  if (!u3)
    return e4;
  const i5 = u3(e4[4].value);
  return [e3.Dimension, i5.toString() + t5, e4[2], e4[3], { value: i5, unit: t5, type: Number.isInteger(i5) ? n2.Integer : n2.Number }];
}
function addition(n4) {
  if (2 !== n4.length)
    return -1;
  const t5 = n4[0].value;
  let r5 = n4[1].value;
  if (t5[0] === e3.Number && r5[0] === e3.Number) {
    const n5 = t5[4].value + r5[4].value;
    return new TokenNode([e3.Number, n5.toString(), t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number }]);
  }
  if (t5[0] === e3.Percentage && r5[0] === e3.Percentage) {
    const n5 = t5[4].value + r5[4].value;
    return new TokenNode([e3.Percentage, n5.toString() + "%", t5[2], r5[3], { value: n5 }]);
  }
  if (t5[0] === e3.Dimension && r5[0] === e3.Dimension && (r5 = convertUnit(t5, r5), toLowerCaseAZ(t5[4].unit) === toLowerCaseAZ(r5[4].unit))) {
    const n5 = t5[4].value + r5[4].value;
    return new TokenNode([e3.Dimension, n5.toString() + t5[4].unit, t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number, unit: t5[4].unit }]);
  }
  return -1;
}
function division(n4) {
  if (2 !== n4.length)
    return -1;
  const t5 = n4[0].value, r5 = n4[1].value;
  if (t5[0] === e3.Number && r5[0] === e3.Number) {
    const n5 = t5[4].value / r5[4].value;
    return new TokenNode([e3.Number, n5.toString(), t5[2], r5[3], { value: n5, type: Number.isInteger(n5) ? n2.Integer : n2.Number }]);
  }
  if (t5[0] === e3.Percentage && r5[0] === e3.Number) {
    const n5 = t5[4].value / r5[4].value;
    return new TokenNode([e3.Percentage, n5.toString() + "%", t5[2], r5[3], { value: n5 }]);
  }
  if (t5[0] === e3.Dimension && r5[0] === e3.Number) {
    const n5 = t5[4].value / r5[4].value;
    return new TokenNode([e3.Dimension, n5.toString() + t5[4].unit, t5[2], r5[3], { value: n5, type: Number.isInteger(n5) ? n2.Integer : n2.Number, unit: t5[4].unit }]);
  }
  return -1;
}
function isCalculation(e4) {
  return !!e4 && "object" == typeof e4 && "inputs" in e4 && Array.isArray(e4.inputs) && "operation" in e4;
}
function solve(e4) {
  if (-1 === e4)
    return -1;
  const t5 = [];
  for (let r5 = 0; r5 < e4.inputs.length; r5++) {
    const u3 = e4.inputs[r5];
    if (isTokenNode(u3)) {
      t5.push(u3);
      continue;
    }
    const i5 = solve(u3);
    if (-1 === i5)
      return -1;
    t5.push(i5);
  }
  return e4.operation(t5);
}
function multiplication(n4) {
  if (2 !== n4.length)
    return -1;
  const t5 = n4[0].value, r5 = n4[1].value;
  if (t5[0] === e3.Number && r5[0] === e3.Number) {
    const n5 = t5[4].value * r5[4].value;
    return new TokenNode([e3.Number, n5.toString(), t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number }]);
  }
  if (t5[0] === e3.Percentage && r5[0] === e3.Number) {
    const n5 = t5[4].value * r5[4].value;
    return new TokenNode([e3.Percentage, n5.toString() + "%", t5[2], r5[3], { value: n5 }]);
  }
  if (t5[0] === e3.Number && r5[0] === e3.Percentage) {
    const n5 = t5[4].value * r5[4].value;
    return new TokenNode([e3.Percentage, n5.toString() + "%", t5[2], r5[3], { value: n5 }]);
  }
  if (t5[0] === e3.Dimension && r5[0] === e3.Number) {
    const n5 = t5[4].value * r5[4].value;
    return new TokenNode([e3.Dimension, n5.toString() + t5[4].unit, t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number, unit: t5[4].unit }]);
  }
  if (t5[0] === e3.Number && r5[0] === e3.Dimension) {
    const n5 = t5[4].value * r5[4].value;
    return new TokenNode([e3.Dimension, n5.toString() + r5[4].unit, t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number, unit: r5[4].unit }]);
  }
  return -1;
}
function resolveGlobalsAndConstants(t5, r5) {
  for (let u3 = 0; u3 < t5.length; u3++) {
    const i5 = t5[u3];
    if (!isTokenNode(i5))
      continue;
    const a3 = i5.value;
    if (a3[0] !== e3.Ident)
      continue;
    const o5 = toLowerCaseAZ(a3[4].value);
    switch (o5) {
      case "e":
        t5.splice(u3, 1, new TokenNode([e3.Number, Math.E.toString(), a3[2], a3[3], { value: Math.E, type: n2.Number }]));
        break;
      case "pi":
        t5.splice(u3, 1, new TokenNode([e3.Number, Math.PI.toString(), a3[2], a3[3], { value: Math.PI, type: n2.Number }]));
        break;
      case "infinity":
        t5.splice(u3, 1, new TokenNode([e3.Number, "infinity", a3[2], a3[3], { value: 1 / 0, type: n2.Number }]));
        break;
      case "-infinity":
        t5.splice(u3, 1, new TokenNode([e3.Number, "-infinity", a3[2], a3[3], { value: -1 / 0, type: n2.Number }]));
        break;
      case "nan":
        t5.splice(u3, 1, new TokenNode([e3.Number, "NaN", a3[2], a3[3], { value: Number.NaN, type: n2.Number }]));
        break;
      default:
        if (r5.has(o5)) {
          const n4 = r5.get(o5);
          t5.splice(u3, 1, new TokenNode(n4));
        }
    }
  }
  return t5;
}
function isNumeric(e4) {
  return e4[0] === e3.Dimension || (e4[0] === e3.Percentage || e4[0] === e3.Number);
}
function isDimensionOrNumber(e4) {
  return e4[0] === e3.Dimension || e4[0] === e3.Number;
}
function arrayOfSameNumeric(e4) {
  if (0 === e4.length)
    return true;
  const n4 = e4[0];
  if (!isNumeric(n4))
    return false;
  if (1 === e4.length)
    return true;
  if (n4[0] === e3.Dimension) {
    const t5 = toLowerCaseAZ(n4[4].unit);
    for (let r5 = 1; r5 < e4.length; r5++) {
      const u3 = e4[r5];
      if (n4[0] !== u3[0])
        return false;
      if (t5 !== toLowerCaseAZ(u3[4].unit))
        return false;
    }
    return true;
  }
  for (let t5 = 1; t5 < e4.length; t5++) {
    const r5 = e4[t5];
    if (n4[0] !== r5[0])
      return false;
  }
  return true;
}
function twoOfSameNumeric(e4, n4) {
  return !!isNumeric(e4) && (e4[0] === e3.Dimension ? e4[0] === n4[0] && toLowerCaseAZ(e4[4].unit) === toLowerCaseAZ(n4[4].unit) : e4[0] === n4[0]);
}
function unary(e4) {
  if (1 !== e4.length)
    return -1;
  return isNumeric(e4[0].value) ? e4[0] : -1;
}
function resultToCalculation(e4, n4, t5) {
  return n4[0] === e3.Dimension ? dimensionToCalculation(e4, n4[4].unit, t5) : n4[0] === e3.Percentage ? percentageToCalculation(e4, t5) : n4[0] === e3.Number ? numberToCalculation(e4, t5) : -1;
}
function dimensionToCalculation(n4, t5, r5) {
  const u3 = n4.tokens();
  return { inputs: [new TokenNode([e3.Dimension, r5.toString() + t5, u3[0][2], u3[u3.length - 1][3], { value: r5, type: Number.isInteger(r5) ? n2.Integer : n2.Number, unit: t5 }])], operation: unary };
}
function percentageToCalculation(n4, t5) {
  const r5 = n4.tokens();
  return { inputs: [new TokenNode([e3.Percentage, t5.toString() + "%", r5[0][2], r5[r5.length - 1][3], { value: t5 }])], operation: unary };
}
function numberToCalculation(n4, t5) {
  const r5 = n4.tokens();
  return { inputs: [new TokenNode([e3.Number, t5.toString(), r5[0][2], r5[r5.length - 1][3], { value: t5, type: Number.isInteger(t5) ? n2.Integer : n2.Number }])], operation: unary };
}
function solveACos(e4, n4) {
  const t5 = n4.value;
  if (t5[0] !== e3.Number)
    return -1;
  return dimensionToCalculation(e4, "rad", Math.acos(t5[4].value));
}
function solveASin(e4, n4) {
  const t5 = n4.value;
  if (t5[0] !== e3.Number)
    return -1;
  return dimensionToCalculation(e4, "rad", Math.asin(t5[4].value));
}
function solveATan(e4, n4) {
  const t5 = n4.value;
  if (t5[0] !== e3.Number)
    return -1;
  return dimensionToCalculation(e4, "rad", Math.atan(t5[4].value));
}
function solveATan2(e4, n4, t5) {
  const r5 = n4.value;
  if (!isDimensionOrNumber(r5))
    return -1;
  const u3 = convertUnit(r5, t5.value);
  if (!twoOfSameNumeric(r5, u3))
    return -1;
  return dimensionToCalculation(e4, "rad", Math.atan2(r5[4].value, u3[4].value));
}
function solveAbs(e4, n4) {
  const t5 = n4.value;
  if (!isDimensionOrNumber(t5))
    return -1;
  return resultToCalculation(e4, t5, Math.abs(t5[4].value));
}
function solveClamp(e4, t5, r5, u3) {
  if (!isTokenNode(t5) || !isTokenNode(r5) || !isTokenNode(u3))
    return -1;
  const i5 = t5.value;
  if (!isNumeric(i5))
    return -1;
  const a3 = convertUnit(i5, r5.value);
  if (!twoOfSameNumeric(i5, a3))
    return -1;
  const o5 = convertUnit(i5, u3.value);
  if (!twoOfSameNumeric(i5, o5))
    return -1;
  return resultToCalculation(e4, i5, Math.max(i5[4].value, Math.min(a3[4].value, o5[4].value)));
}
function solveCos(e4, n4) {
  const t5 = n4.value;
  if (!isDimensionOrNumber(t5))
    return -1;
  let r5 = t5[4].value;
  if (t5[0] === e3.Dimension)
    switch (toLowerCaseAZ(t5[4].unit)) {
      case "rad":
        break;
      case "deg":
        r5 = w2.get("rad")(t5[4].value);
        break;
      case "grad":
        r5 = h2.get("rad")(t5[4].value);
        break;
      case "turn":
        r5 = x2.get("rad")(t5[4].value);
        break;
      default:
        return -1;
    }
  return r5 = Math.cos(r5), numberToCalculation(e4, r5);
}
function solveExp(e4, n4) {
  const t5 = n4.value;
  if (t5[0] !== e3.Number)
    return -1;
  return numberToCalculation(e4, Math.exp(t5[4].value));
}
function solveHypot(e4, t5) {
  const r5 = t5[0];
  if (!r5 || !isTokenNode(r5))
    return -1;
  if (1 !== new Set(t5.map((e5) => e5.type)).size)
    return -1;
  const u3 = r5.value;
  if (!isNumeric(u3))
    return -1;
  const i5 = t5.map((e5) => convertUnit(u3, e5.value));
  if (!arrayOfSameNumeric(i5))
    return -1;
  const a3 = i5.map((e5) => e5[4].value), o5 = Math.hypot(...a3);
  return resultToCalculation(e4, u3, o5);
}
function solveMax(e4, t5) {
  const r5 = t5[0];
  if (!r5 || !isTokenNode(r5))
    return -1;
  if (1 !== new Set(t5.map((e5) => e5.type)).size)
    return -1;
  const u3 = r5.value;
  if (!isNumeric(u3))
    return -1;
  const i5 = t5.map((e5) => convertUnit(u3, e5.value));
  if (!arrayOfSameNumeric(i5))
    return -1;
  const a3 = i5.map((e5) => e5[4].value), o5 = Math.max(...a3);
  return resultToCalculation(e4, u3, o5);
}
function solveMin(e4, t5) {
  const r5 = t5[0];
  if (!r5 || !isTokenNode(r5))
    return -1;
  if (1 !== new Set(t5.map((e5) => e5.type)).size)
    return -1;
  const u3 = r5.value;
  if (!isNumeric(u3))
    return -1;
  const i5 = t5.map((e5) => convertUnit(u3, e5.value));
  if (!arrayOfSameNumeric(i5))
    return -1;
  const a3 = i5.map((e5) => e5[4].value), o5 = Math.min(...a3);
  return resultToCalculation(e4, u3, o5);
}
function solveMod(e4, n4, t5) {
  const r5 = n4.value;
  if (!isNumeric(r5))
    return -1;
  const u3 = convertUnit(r5, t5.value);
  if (!twoOfSameNumeric(r5, u3))
    return -1;
  let i5;
  return i5 = 0 === u3[4].value ? Number.NaN : Number.isFinite(r5[4].value) && (Number.isFinite(u3[4].value) || (u3[4].value !== Number.POSITIVE_INFINITY || r5[4].value !== Number.NEGATIVE_INFINITY && !Object.is(0 * r5[4].value, -0)) && (u3[4].value !== Number.NEGATIVE_INFINITY || r5[4].value !== Number.POSITIVE_INFINITY && !Object.is(0 * r5[4].value, 0))) ? Number.isFinite(u3[4].value) ? (r5[4].value % u3[4].value + u3[4].value) % u3[4].value : r5[4].value : Number.NaN, resultToCalculation(e4, r5, i5);
}
function solvePow(e4, n4, t5) {
  const r5 = n4.value, u3 = t5.value;
  if (r5[0] !== e3.Number)
    return -1;
  if (!twoOfSameNumeric(r5, u3))
    return -1;
  return numberToCalculation(e4, Math.pow(r5[4].value, u3[4].value));
}
function solveRem(e4, n4, t5) {
  const r5 = n4.value;
  if (!isNumeric(r5))
    return -1;
  const u3 = convertUnit(r5, t5.value);
  if (!twoOfSameNumeric(r5, u3))
    return -1;
  let i5;
  return i5 = 0 === u3[4].value ? Number.NaN : Number.isFinite(r5[4].value) ? Number.isFinite(u3[4].value) ? r5[4].value % u3[4].value : r5[4].value : Number.NaN, resultToCalculation(e4, r5, i5);
}
function solveRound(e4, n4, t5, r5) {
  const u3 = t5.value;
  if (!isNumeric(u3))
    return -1;
  const i5 = convertUnit(u3, r5.value);
  if (!twoOfSameNumeric(u3, i5))
    return -1;
  let a3;
  if (0 === i5[4].value)
    a3 = Number.NaN;
  else if (Number.isFinite(u3[4].value) || Number.isFinite(i5[4].value))
    if (!Number.isFinite(u3[4].value) && Number.isFinite(i5[4].value))
      a3 = u3[4].value;
    else if (Number.isFinite(u3[4].value) && !Number.isFinite(i5[4].value))
      switch (n4) {
        case "down":
          a3 = u3[4].value < 0 ? -1 / 0 : Object.is(-0, 0 * u3[4].value) ? -0 : 0;
          break;
        case "up":
          a3 = u3[4].value > 0 ? 1 / 0 : Object.is(0, 0 * u3[4].value) ? 0 : -0;
          break;
        default:
          a3 = Object.is(0, 0 * u3[4].value) ? 0 : -0;
      }
    else if (Number.isFinite(i5[4].value))
      switch (n4) {
        case "down":
          a3 = Math.floor(u3[4].value / i5[4].value) * i5[4].value;
          break;
        case "up":
          a3 = Math.ceil(u3[4].value / i5[4].value) * i5[4].value;
          break;
        case "to-zero":
          a3 = Math.trunc(u3[4].value / i5[4].value) * i5[4].value;
          break;
        default: {
          let e5 = Math.floor(u3[4].value / i5[4].value) * i5[4].value, n5 = Math.ceil(u3[4].value / i5[4].value) * i5[4].value;
          if (e5 > n5) {
            const t7 = e5;
            e5 = n5, n5 = t7;
          }
          const t6 = Math.abs(u3[4].value - e5), r6 = Math.abs(u3[4].value - n5);
          a3 = t6 === r6 ? n5 : t6 < r6 ? e5 : n5;
          break;
        }
      }
    else
      a3 = u3[4].value;
  else
    a3 = Number.NaN;
  return resultToCalculation(e4, u3, a3);
}
function solveSign(e4, n4) {
  const t5 = n4.value;
  if (!isDimensionOrNumber(t5))
    return -1;
  return numberToCalculation(e4, Math.sign(t5[4].value));
}
function solveSin(e4, n4) {
  const t5 = n4.value;
  if (!isDimensionOrNumber(t5))
    return -1;
  let r5 = t5[4].value;
  if (t5[0] === e3.Dimension)
    switch (toLowerCaseAZ(t5[4].unit)) {
      case "rad":
        break;
      case "deg":
        r5 = w2.get("rad")(t5[4].value);
        break;
      case "grad":
        r5 = h2.get("rad")(t5[4].value);
        break;
      case "turn":
        r5 = x2.get("rad")(t5[4].value);
        break;
      default:
        return -1;
    }
  return r5 = Math.sin(r5), numberToCalculation(e4, r5);
}
function solveSqrt(e4, n4) {
  const t5 = n4.value;
  if (t5[0] !== e3.Number)
    return -1;
  return numberToCalculation(e4, Math.sqrt(t5[4].value));
}
function solveTan(e4, n4) {
  const t5 = n4.value;
  if (!isDimensionOrNumber(t5))
    return -1;
  const r5 = t5[4].value;
  let u3 = 0, i5 = t5[4].value;
  if (t5[0] === e3.Dimension)
    switch (toLowerCaseAZ(t5[4].unit)) {
      case "rad":
        u3 = k2.get("deg")(r5);
        break;
      case "deg":
        u3 = r5, i5 = w2.get("rad")(r5);
        break;
      case "grad":
        u3 = h2.get("deg")(r5), i5 = h2.get("rad")(r5);
        break;
      case "turn":
        u3 = x2.get("deg")(r5), i5 = x2.get("rad")(r5);
        break;
      default:
        return -1;
    }
  const a3 = u3 / 90;
  return i5 = u3 % 90 == 0 && a3 % 2 != 0 ? a3 > 0 ? 1 / 0 : -1 / 0 : Math.tan(i5), numberToCalculation(e4, i5);
}
function subtraction(n4) {
  if (2 !== n4.length)
    return -1;
  const t5 = n4[0].value;
  let r5 = n4[1].value;
  if (t5[0] === e3.Number && r5[0] === e3.Number) {
    const n5 = t5[4].value - r5[4].value;
    return new TokenNode([e3.Number, n5.toString(), t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number }]);
  }
  if (t5[0] === e3.Percentage && r5[0] === e3.Percentage) {
    const n5 = t5[4].value - r5[4].value;
    return new TokenNode([e3.Percentage, n5.toString() + "%", t5[2], r5[3], { value: n5 }]);
  }
  if (t5[0] === e3.Dimension && r5[0] === e3.Dimension && (r5 = convertUnit(t5, r5), toLowerCaseAZ(t5[4].unit) === toLowerCaseAZ(r5[4].unit))) {
    const n5 = t5[4].value - r5[4].value;
    return new TokenNode([e3.Dimension, n5.toString() + t5[4].unit, t5[2], r5[3], { value: n5, type: t5[4].type === n2.Integer && r5[4].type === n2.Integer ? n2.Integer : n2.Number, unit: t5[4].unit }]);
  }
  return -1;
}
function solveLog(e4, t5) {
  if (1 === t5.length) {
    const r5 = t5[0];
    if (!r5 || !isTokenNode(r5))
      return -1;
    const u3 = r5.value;
    if (u3[0] !== e3.Number)
      return -1;
    return numberToCalculation(e4, Math.log(u3[4].value));
  }
  if (2 === t5.length) {
    const r5 = t5[0];
    if (!r5 || !isTokenNode(r5))
      return -1;
    const u3 = r5.value;
    if (u3[0] !== e3.Number)
      return -1;
    const i5 = t5[1];
    if (!i5 || !isTokenNode(i5))
      return -1;
    const a3 = i5.value;
    if (a3[0] !== e3.Number)
      return -1;
    return numberToCalculation(e4, Math.log(u3[4].value) / Math.log(a3[4].value));
  }
  return -1;
}
var Z = /* @__PURE__ */ new Map([["abs", function abs(e4, n4) {
  return singleNodeSolver(e4, n4, solveAbs);
}], ["acos", function acos(e4, n4) {
  return singleNodeSolver(e4, n4, solveACos);
}], ["asin", function asin(e4, n4) {
  return singleNodeSolver(e4, n4, solveASin);
}], ["atan", function atan(e4, n4) {
  return singleNodeSolver(e4, n4, solveATan);
}], ["atan2", function atan2(e4, n4) {
  return twoCommaSeparatedNodesSolver(e4, n4, solveATan2);
}], ["calc", calc$1], ["clamp", function clamp(e4, u3) {
  const i5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], u3), o5 = [], l2 = [], c2 = [];
  {
    let e5 = o5;
    for (let t5 = 0; t5 < i5.length; t5++) {
      const r5 = i5[t5];
      if (isTokenNode(r5) && r5.value[0] === e3.Comma) {
        if (e5 === c2)
          return -1;
        if (e5 === l2) {
          e5 = c2;
          continue;
        }
        if (e5 === o5) {
          e5 = l2;
          continue;
        }
        return -1;
      }
      e5.push(r5);
    }
  }
  const v2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], o5), u3));
  if (-1 === v2)
    return -1;
  const m2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], l2), u3));
  if (-1 === m2)
    return -1;
  const f2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], c2), u3));
  if (-1 === f2)
    return -1;
  return solveClamp(e4, v2, m2, f2);
}], ["cos", function cos(e4, n4) {
  return singleNodeSolver(e4, n4, solveCos);
}], ["exp", function exp(e4, n4) {
  return singleNodeSolver(e4, n4, solveExp);
}], ["hypot", function hypot(e4, n4) {
  return variadicNodesSolver(e4, n4, solveHypot);
}], ["log", function log(e4, n4) {
  return variadicNodesSolver(e4, n4, solveLog);
}], ["max", function max(e4, n4) {
  return variadicNodesSolver(e4, n4, solveMax);
}], ["min", function min(e4, n4) {
  return variadicNodesSolver(e4, n4, solveMin);
}], ["mod", function mod(e4, n4) {
  return twoCommaSeparatedNodesSolver(e4, n4, solveMod);
}], ["pow", function pow(e4, n4) {
  return twoCommaSeparatedNodesSolver(e4, n4, solvePow);
}], ["rem", function rem(e4, n4) {
  return twoCommaSeparatedNodesSolver(e4, n4, solveRem);
}], ["round", function round(e4, u3) {
  const i5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], u3);
  let o5 = "";
  const l2 = [], c2 = [];
  {
    let e5 = l2;
    for (let t5 = 0; t5 < i5.length; t5++) {
      const r5 = i5[t5];
      if (!o5 && 0 === l2.length && 0 === c2.length && isTokenNode(r5) && r5.value[0] === e3.Ident) {
        const e6 = toLowerCaseAZ(r5.value[4].value);
        if (L2.has(e6)) {
          o5 = e6;
          continue;
        }
      }
      if (isTokenNode(r5) && r5.value[0] === e3.Comma) {
        if (e5 === c2)
          return -1;
        if (e5 === l2 && o5 && 0 === l2.length)
          continue;
        if (e5 === l2) {
          e5 = c2;
          continue;
        }
        return -1;
      }
      e5.push(r5);
    }
  }
  const v2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], l2), u3));
  if (-1 === v2)
    return -1;
  const m2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], c2), u3));
  if (-1 === m2)
    return -1;
  o5 || (o5 = "nearest");
  return solveRound(e4, o5, v2, m2);
}], ["sign", function sign(e4, n4) {
  return singleNodeSolver(e4, n4, solveSign);
}], ["sin", function sin(e4, n4) {
  return singleNodeSolver(e4, n4, solveSin);
}], ["sqrt", function sqrt(e4, n4) {
  return singleNodeSolver(e4, n4, solveSqrt);
}], ["tan", function tan(e4, n4) {
  return singleNodeSolver(e4, n4, solveTan);
}]]);
function calc$1(e4, a3) {
  const o5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], a3);
  if (1 === o5.length && isTokenNode(o5[0]))
    return { inputs: [o5[0]], operation: unary };
  let l2 = 0;
  for (; l2 < o5.length; ) {
    const e5 = o5[l2];
    if (isSimpleBlockNode(e5) && e5.startToken[0] === e3.OpenParen) {
      const n4 = calc$1(e5, a3);
      if (-1 === n4)
        return -1;
      o5.splice(l2, 1, n4);
    } else if (isFunctionNode(e5)) {
      const n4 = Z.get(toLowerCaseAZ(e5.getName()));
      if (!n4)
        return -1;
      const t5 = n4(e5, a3);
      if (-1 === t5)
        return -1;
      o5.splice(l2, 1, t5);
    } else
      l2++;
  }
  if (l2 = 0, 1 === o5.length && isCalculation(o5[0]))
    return o5[0];
  for (; l2 < o5.length; ) {
    const e5 = o5[l2];
    if (!e5 || !isTokenNode(e5) && !isCalculation(e5)) {
      l2++;
      continue;
    }
    const t5 = o5[l2 + 1];
    if (!t5 || !isTokenNode(t5)) {
      l2++;
      continue;
    }
    const r5 = t5.value;
    if (r5[0] !== e3.Delim || "*" !== r5[4].value && "/" !== r5[4].value) {
      l2++;
      continue;
    }
    const u3 = o5[l2 + 2];
    if (!u3 || !isTokenNode(u3) && !isCalculation(u3))
      return -1;
    "*" !== r5[4].value ? "/" !== r5[4].value ? l2++ : o5.splice(l2, 3, { inputs: [e5, u3], operation: division }) : o5.splice(l2, 3, { inputs: [e5, u3], operation: multiplication });
  }
  if (l2 = 0, 1 === o5.length && isCalculation(o5[0]))
    return o5[0];
  for (; l2 < o5.length; ) {
    const e5 = o5[l2];
    if (!e5 || !isTokenNode(e5) && !isCalculation(e5)) {
      l2++;
      continue;
    }
    const t5 = o5[l2 + 1];
    if (!t5 || !isTokenNode(t5)) {
      l2++;
      continue;
    }
    const r5 = t5.value;
    if (r5[0] !== e3.Delim || "+" !== r5[4].value && "-" !== r5[4].value) {
      l2++;
      continue;
    }
    const u3 = o5[l2 + 2];
    if (!u3 || !isTokenNode(u3) && !isCalculation(u3))
      return -1;
    "+" !== r5[4].value ? "-" !== r5[4].value ? l2++ : o5.splice(l2, 3, { inputs: [e5, u3], operation: subtraction }) : o5.splice(l2, 3, { inputs: [e5, u3], operation: addition });
  }
  return 1 === o5.length && isCalculation(o5[0]) ? o5[0] : -1;
}
function singleNodeSolver(e4, n4, u3) {
  const i5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], n4), o5 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], i5), n4));
  return -1 === o5 ? -1 : u3(e4, o5);
}
function twoCommaSeparatedNodesSolver(e4, u3, i5) {
  const o5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], u3), l2 = [], c2 = [];
  {
    let e5 = l2;
    for (let t5 = 0; t5 < o5.length; t5++) {
      const r5 = o5[t5];
      if (isTokenNode(r5) && r5.value[0] === e3.Comma) {
        if (e5 === c2)
          return -1;
        if (e5 === l2) {
          e5 = c2;
          continue;
        }
        return -1;
      }
      e5.push(r5);
    }
  }
  const v2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], l2), u3));
  if (-1 === v2)
    return -1;
  const m2 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], c2), u3));
  return -1 === m2 ? -1 : i5(e4, v2, m2);
}
function variadicNodesSolver(e4, u3, i5) {
  const o5 = resolveGlobalsAndConstants([...e4.value.filter((e5) => !isCommentNode(e5) && !isWhitespaceNode(e5))], u3), l2 = [];
  {
    const e5 = [];
    let t5 = [];
    for (let r5 = 0; r5 < o5.length; r5++) {
      const u4 = o5[r5];
      isTokenNode(u4) && u4.value[0] === e3.Comma ? (e5.push(t5), t5 = []) : t5.push(u4);
    }
    e5.push(t5);
    for (let n4 = 0; n4 < e5.length; n4++) {
      if (0 === e5[n4].length)
        return -1;
      const t6 = solve(calc$1(new FunctionNode([e3.Function, "calc(", -1, -1, { value: "calc" }], [e3.CloseParen, ")", -1, -1, void 0], e5[n4]), u3));
      if (-1 === t6)
        return -1;
      l2.push(t6);
    }
  }
  return i5(e4, l2);
}
var L2 = /* @__PURE__ */ new Set(["nearest", "up", "down", "to-zero"]);
function patchNaN(n4) {
  if (-1 === n4)
    return -1;
  if (isFunctionNode(n4))
    return n4;
  const t5 = n4.value;
  return t5[0] !== e3.Number && t5[0] !== e3.Percentage && t5[0] !== e3.Dimension ? n4 : Number.isNaN(t5[4].value) ? t5[0] === e3.Number ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, "NaN", t5[2], t5[3], { value: "NaN" }])]) : t5[0] === e3.Dimension ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, "NaN", t5[2], t5[3], { value: "NaN" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Delim, "*", t5[2], t5[3], { value: "*" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Dimension, "1" + t5[4].unit, t5[2], t5[3], { value: 1, type: n2.Integer, unit: t5[4].unit }])]) : t5[0] === e3.Percentage ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, "NaN", t5[2], t5[3], { value: "NaN" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Delim, "*", t5[2], t5[3], { value: "*" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Percentage, "1%", t5[2], t5[3], { value: 1 }])]) : -1 : n4;
}
function patchInfinity(n4) {
  if (-1 === n4)
    return -1;
  if (isFunctionNode(n4))
    return n4;
  const t5 = n4.value;
  if (t5[0] !== e3.Number && t5[0] !== e3.Percentage && t5[0] !== e3.Dimension)
    return n4;
  if (Number.isFinite(t5[4].value))
    return n4;
  let r5 = "";
  return Number.NEGATIVE_INFINITY === t5[4].value && (r5 = "-"), t5[0] === e3.Number ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, r5 + "infinity", t5[2], t5[3], { value: r5 + "infinity" }])]) : t5[0] === e3.Dimension ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, r5 + "infinity", t5[2], t5[3], { value: r5 + "infinity" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Delim, "*", t5[2], t5[3], { value: "*" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Dimension, "1" + t5[4].unit, t5[2], t5[3], { value: 1, type: n2.Integer, unit: t5[4].unit }])]) : t5[0] === e3.Percentage ? new FunctionNode([e3.Function, "calc(", t5[2], t5[3], { value: "calc" }], [e3.CloseParen, ")", t5[2], t5[3], void 0], [new TokenNode([e3.Ident, r5 + "infinity", t5[2], t5[3], { value: r5 + "infinity" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Delim, "*", t5[2], t5[3], { value: "*" }]), new WhitespaceNode([[e3.Whitespace, " ", t5[2], t5[3], void 0]]), new TokenNode([e3.Percentage, "1%", t5[2], t5[3], { value: 1 }])]) : -1;
}
function patchMinusZero(e4) {
  if (-1 === e4)
    return -1;
  if (isFunctionNode(e4))
    return e4;
  const n4 = e4.value;
  return n4[0] !== e3.Number && n4[0] !== e3.Percentage && n4[0] !== e3.Dimension ? e4 : Object.is(-0, n4[4].value) ? ("-0" === n4[1] || (n4[1] = `calc(-1 * ${n4[1]})`), e4) : e4;
}
function patchPrecision(e4, n4 = 13) {
  if (-1 === e4)
    return -1;
  if (isFunctionNode(e4))
    return e4;
  const t5 = e4.value;
  if (t5[0] !== e3.Number && t5[0] !== e3.Percentage && t5[0] !== e3.Dimension)
    return e4;
  if (Number.isInteger(t5[4].value))
    return e4;
  const r5 = Number(t5[4].value.toFixed(n4)).toString();
  return t5[0] === e3.Number ? t5[1] = r5 : t5[0] === e3.Percentage ? t5[1] = r5 + "%" : t5[0] === e3.Dimension && (t5[1] = r5 + t5[4].unit), e4;
}
function patchCanonicalUnit(e4) {
  return -1 === e4 ? -1 : (isFunctionNode(e4) || e4.value[0] !== e3.Dimension || (e4.value = toCanonicalUnit(e4.value)), e4);
}
function patchCalcResult(e4, n4) {
  let t5;
  return t5 = patchNaN(e4), t5 = patchInfinity(t5), n4?.toCanonicalUnits && (t5 = patchCanonicalUnit(t5)), t5 = patchPrecision(t5, n4?.precision), t5 = patchMinusZero(t5), t5;
}
function tokenizeGlobals(e4) {
  const n4 = /* @__PURE__ */ new Map();
  if (!e4)
    return n4;
  for (const [t5, r5] of e4)
    if (isToken(r5))
      n4.set(t5, r5);
    else if ("string" != typeof r5)
      ;
    else {
      const e5 = tokenizer({ css: r5 }), u3 = e5.nextToken();
      if (e5.nextToken(), !e5.endOfFile())
        continue;
      if (!u3)
        continue;
      if (u3[0] !== e3.Number && u3[0] !== e3.Dimension && u3[0] !== e3.Percentage)
        continue;
      n4.set(t5, u3);
    }
  return n4;
}
function calcFromComponentValues(e4, n4) {
  const t5 = tokenizeGlobals(n4?.globals);
  return replaceComponentValues(e4, (e5) => {
    if (!isFunctionNode(e5))
      return;
    const r5 = Z.get(toLowerCaseAZ(e5.getName()));
    if (!r5)
      return;
    const u3 = patchCalcResult(solve(r5(e5, t5)), n4);
    return -1 !== u3 ? u3 : void 0;
  });
}
var z2 = new Set(Z.keys());

// node_modules/@csstools/css-color-parser/dist/index.mjs
var ee;
var ae;
function colorData_to_XYZ_D50(e4) {
  switch (e4.colorNotation) {
    case ee.HEX:
    case ee.RGB:
    case ee.sRGB:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: sRGB_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.Linear_sRGB:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: lin_sRGB_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.Display_P3:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: P3_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.Rec2020:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: rec_2020_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.A98_RGB:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: a98_RGB_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.ProPhoto_RGB:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: ProPhoto_RGB_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.HSL:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: HSL_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.HWB:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: HWB_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.Lab:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: Lab_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.OKLab:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: OKLab_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.LCH:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: LCH_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.OKLCH:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: OKLCH_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.XYZ_D50:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: XYZ_D50_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    case ee.XYZ_D65:
      return { ...e4, colorNotation: ee.XYZ_D50, channels: XYZ_D65_to_XYZ_D50(e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5)) };
    default:
      throw new Error("Unsupported color notation");
  }
}
!function(e4) {
  e4.A98_RGB = "a98-rgb", e4.Display_P3 = "display-p3", e4.HEX = "hex", e4.HSL = "hsl", e4.HWB = "hwb", e4.LCH = "lch", e4.Lab = "lab", e4.Linear_sRGB = "srgb-linear", e4.OKLCH = "oklch", e4.OKLab = "oklab", e4.ProPhoto_RGB = "prophoto-rgb", e4.RGB = "rgb", e4.sRGB = "srgb", e4.Rec2020 = "rec2020", e4.XYZ_D50 = "xyz-d50", e4.XYZ_D65 = "xyz-d65";
}(ee || (ee = {})), function(e4) {
  e4.ColorKeyword = "color-keyword", e4.HasAlpha = "has-alpha", e4.HasDimensionValues = "has-dimension-values", e4.HasNoneKeywords = "has-none-keywords", e4.HasNumberValues = "has-number-values", e4.HasPercentageAlpha = "has-percentage-alpha", e4.HasPercentageValues = "has-percentage-values", e4.HasVariableAlpha = "has-variable-alpha", e4.Hex = "hex", e4.LegacyHSL = "legacy-hsl", e4.LegacyRGB = "legacy-rgb", e4.NamedColor = "named-color", e4.RelativeColorSyntax = "relative-color-syntax", e4.ColorMix = "color-mix", e4.Experimental = "experimental";
}(ae || (ae = {}));
var ne = /* @__PURE__ */ new Set([ee.A98_RGB, ee.Display_P3, ee.HEX, ee.Linear_sRGB, ee.ProPhoto_RGB, ee.RGB, ee.sRGB, ee.Rec2020, ee.XYZ_D50, ee.XYZ_D65]);
function colorDataTo(e4, a3) {
  const g3 = { ...e4 };
  if (e4.colorNotation !== a3) {
    const e5 = colorData_to_XYZ_D50(g3);
    switch (a3) {
      case ee.HEX:
      case ee.RGB:
        g3.colorNotation = ee.RGB, g3.channels = XYZ_D50_to_sRGB(e5.channels);
        break;
      case ee.sRGB:
        g3.colorNotation = ee.sRGB, g3.channels = XYZ_D50_to_sRGB(e5.channels);
        break;
      case ee.Linear_sRGB:
        g3.colorNotation = ee.Linear_sRGB, g3.channels = XYZ_D50_to_lin_sRGB(e5.channels);
        break;
      case ee.Display_P3:
        g3.colorNotation = ee.Display_P3, g3.channels = XYZ_D50_to_P3(e5.channels);
        break;
      case ee.Rec2020:
        g3.colorNotation = ee.Rec2020, g3.channels = XYZ_D50_to_rec_2020(e5.channels);
        break;
      case ee.ProPhoto_RGB:
        g3.colorNotation = ee.ProPhoto_RGB, g3.channels = XYZ_D50_to_ProPhoto(e5.channels);
        break;
      case ee.A98_RGB:
        g3.colorNotation = ee.A98_RGB, g3.channels = XYZ_D50_to_a98_RGB(e5.channels);
        break;
      case ee.HSL:
        g3.colorNotation = ee.HSL, g3.channels = XYZ_D50_to_HSL(e5.channels);
        break;
      case ee.HWB:
        g3.colorNotation = ee.HWB, g3.channels = XYZ_D50_to_HWB(e5.channels);
        break;
      case ee.Lab:
        g3.colorNotation = ee.Lab, g3.channels = XYZ_D50_to_Lab(e5.channels);
        break;
      case ee.LCH:
        g3.colorNotation = ee.LCH, g3.channels = XYZ_D50_to_LCH(e5.channels);
        break;
      case ee.OKLCH:
        g3.colorNotation = ee.OKLCH, g3.channels = XYZ_D50_to_OKLCH(e5.channels);
        break;
      case ee.OKLab:
        g3.colorNotation = ee.OKLab, g3.channels = XYZ_D50_to_OKLab(e5.channels);
        break;
      case ee.XYZ_D50:
        g3.colorNotation = ee.XYZ_D50, g3.channels = XYZ_D50_to_XYZ_D50(e5.channels);
        break;
      case ee.XYZ_D65:
        g3.colorNotation = ee.XYZ_D65, g3.channels = XYZ_D50_to_XYZ_D65(e5.channels);
        break;
      default:
        throw new Error("Unsupported color notation");
    }
  } else
    g3.channels = e4.channels.map((e5) => Number.isNaN(e5) ? 0 : e5);
  if (a3 === e4.colorNotation)
    g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [0, 1, 2]);
  else if (ne.has(a3) && ne.has(e4.colorNotation))
    g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [0, 1, 2]);
  else
    switch (a3) {
      case ee.HSL:
        switch (e4.colorNotation) {
          case ee.HWB:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [0]);
            break;
          case ee.Lab:
          case ee.OKLab:
            g3.channels = carryForwardMissingComponents(e4.channels, [2], g3.channels, [0]);
            break;
          case ee.LCH:
          case ee.OKLCH:
            g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [2, 1, 0]);
        }
        break;
      case ee.HWB:
        switch (e4.colorNotation) {
          case ee.HSL:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [0]);
            break;
          case ee.LCH:
          case ee.OKLCH:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [2]);
        }
        break;
      case ee.Lab:
      case ee.OKLab:
        switch (e4.colorNotation) {
          case ee.HSL:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [2]);
            break;
          case ee.Lab:
          case ee.OKLab:
            g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [0, 1, 2]);
            break;
          case ee.LCH:
          case ee.OKLCH:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [0]);
        }
        break;
      case ee.LCH:
      case ee.OKLCH:
        switch (e4.colorNotation) {
          case ee.HSL:
            g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [2, 1, 0]);
            break;
          case ee.HWB:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [2]);
            break;
          case ee.Lab:
          case ee.OKLab:
            g3.channels = carryForwardMissingComponents(e4.channels, [0], g3.channels, [0]);
            break;
          case ee.LCH:
          case ee.OKLCH:
            g3.channels = carryForwardMissingComponents(e4.channels, [0, 1, 2], g3.channels, [0, 1, 2]);
        }
    }
  return g3.channels = convertPowerlessComponentsToMissingComponents(g3.channels, a3), g3;
}
function convertPowerlessComponentsToMissingComponents(e4, a3) {
  const n4 = [...e4];
  switch (a3) {
    case ee.HSL:
      reducePrecision(n4[1], 4) <= 0 && (n4[0] = NaN);
      break;
    case ee.HWB:
      Math.max(0, reducePrecision(n4[1], 4)) + Math.max(0, reducePrecision(n4[2], 4)) >= 100 && (n4[0] = NaN);
      break;
    case ee.LCH:
      reducePrecision(n4[1], 4) <= 0 && (n4[2] = NaN);
      break;
    case ee.OKLCH:
      reducePrecision(n4[1], 6) <= 0 && (n4[2] = NaN);
  }
  return n4;
}
function convertPowerlessComponentsToZeroValuesForDisplay(e4, a3) {
  const n4 = [...e4];
  switch (a3) {
    case ee.HSL:
      (reducePrecision(n4[2]) <= 0 || reducePrecision(n4[2]) >= 100) && (n4[0] = NaN, n4[1] = NaN), reducePrecision(n4[1]) <= 0 && (n4[0] = NaN);
      break;
    case ee.HWB:
      Math.max(0, reducePrecision(n4[1])) + Math.max(0, reducePrecision(n4[2])) >= 100 && (n4[0] = NaN);
      break;
    case ee.Lab:
      (reducePrecision(n4[0]) <= 0 || reducePrecision(n4[0]) >= 100) && (n4[1] = NaN, n4[2] = NaN);
      break;
    case ee.LCH:
      reducePrecision(n4[1]) <= 0 && (n4[2] = NaN), (reducePrecision(n4[0]) <= 0 || reducePrecision(n4[0]) >= 100) && (n4[1] = NaN, n4[2] = NaN);
      break;
    case ee.OKLab:
      (reducePrecision(n4[0]) <= 0 || reducePrecision(n4[0]) >= 1) && (n4[1] = NaN, n4[2] = NaN);
      break;
    case ee.OKLCH:
      reducePrecision(n4[1]) <= 0 && (n4[2] = NaN), (reducePrecision(n4[0]) <= 0 || reducePrecision(n4[0]) >= 1) && (n4[1] = NaN, n4[2] = NaN);
  }
  return n4;
}
function carryForwardMissingComponents(e4, a3, n4, r5) {
  const o5 = [...n4];
  for (const n5 of a3)
    Number.isNaN(e4[a3[n5]]) && (o5[r5[n5]] = NaN);
  return o5;
}
function normalizeRelativeColorDataChannels(e4) {
  const a3 = /* @__PURE__ */ new Map();
  switch (e4.colorNotation) {
    case ee.RGB:
    case ee.HEX:
      a3.set("r", dummyNumberToken(255 * e4.channels[0])), a3.set("g", dummyNumberToken(255 * e4.channels[1])), a3.set("b", dummyNumberToken(255 * e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.HSL:
      a3.set("h", dummyNumberToken(e4.channels[0])), a3.set("s", dummyNumberToken(e4.channels[1])), a3.set("l", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.HWB:
      a3.set("h", dummyNumberToken(e4.channels[0])), a3.set("w", dummyNumberToken(e4.channels[1])), a3.set("b", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.Lab:
    case ee.OKLab:
      a3.set("l", dummyNumberToken(e4.channels[0])), a3.set("a", dummyNumberToken(e4.channels[1])), a3.set("b", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.LCH:
    case ee.OKLCH:
      a3.set("l", dummyNumberToken(e4.channels[0])), a3.set("c", dummyNumberToken(e4.channels[1])), a3.set("h", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.sRGB:
    case ee.A98_RGB:
    case ee.Display_P3:
    case ee.Rec2020:
    case ee.Linear_sRGB:
    case ee.ProPhoto_RGB:
      a3.set("r", dummyNumberToken(e4.channels[0])), a3.set("g", dummyNumberToken(e4.channels[1])), a3.set("b", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
      break;
    case ee.XYZ_D50:
    case ee.XYZ_D65:
      a3.set("x", dummyNumberToken(e4.channels[0])), a3.set("y", dummyNumberToken(e4.channels[1])), a3.set("z", dummyNumberToken(e4.channels[2])), "number" == typeof e4.alpha && a3.set("alpha", dummyNumberToken(e4.alpha));
  }
  return a3;
}
function noneToZeroInRelativeColorDataChannels(e4) {
  const a3 = new Map(e4);
  for (const [n4, r5] of e4)
    Number.isNaN(r5[4].value) && a3.set(n4, dummyNumberToken(0));
  return a3;
}
function dummyNumberToken(n4) {
  return [e3.Number, n4.toString(), -1, -1, { value: n4, type: n2.Number }];
}
function reducePrecision(e4, a3 = 7) {
  if (Number.isNaN(e4))
    return 0;
  const n4 = Math.pow(10, a3);
  return Math.round(e4 * n4) / n4;
}
function normalize(e4, a3, n4, r5) {
  return Math.min(Math.max(e4 / a3, n4), r5);
}
var re = /[A-Z]/g;
function toLowerCaseAZ2(e4) {
  return e4.replace(re, (e5) => String.fromCharCode(e5.charCodeAt(0) + 32));
}
function normalize_Color_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 100, -1 / 0, 1 / 0);
    return 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 1, -1 / 0, 1 / 0);
    return 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
var oe = /* @__PURE__ */ new Set(["srgb", "srgb-linear", "display-p3", "a98-rgb", "prophoto-rgb", "rec2020", "xyz", "xyz-d50", "xyz-d65"]);
function color$1(a3, n4) {
  const r5 = [], o5 = [], t5 = [], l2 = [];
  let s2, u3, i5 = false, c2 = false;
  const m2 = { colorNotation: ee.sRGB, channels: [0, 0, 0], alpha: 1, syntaxFlags: /* @__PURE__ */ new Set([]) };
  let h3 = r5;
  for (let N3 = 0; N3 < a3.value.length; N3++) {
    let p4 = a3.value[N3];
    if (isWhitespaceNode(p4) || isCommentNode(p4))
      for (; isWhitespaceNode(a3.value[N3 + 1]) || isCommentNode(a3.value[N3 + 1]); )
        N3++;
    else if (h3 === r5 && r5.length && (h3 = o5), h3 === o5 && o5.length && (h3 = t5), isTokenNode(p4) && p4.value[0] === e3.Delim && "/" === p4.value[4].value) {
      if (h3 === l2)
        return false;
      h3 = l2;
    } else {
      if (isFunctionNode(p4)) {
        if (h3 === l2 && "var" === toLowerCaseAZ2(p4.getName())) {
          m2.syntaxFlags.add(ae.HasVariableAlpha), h3.push(p4);
          continue;
        }
        if (!z2.has(toLowerCaseAZ2(p4.getName())))
          return false;
        const [[a4]] = calcFromComponentValues([[p4]], { toCanonicalUnits: true, precision: 100, globals: u3 });
        if (!a4 || !isTokenNode(a4) || (a4.value[0] === e3.Percentage || a4.value[0] === e3.Number || a4.value[0] === e3.Dimension) && Number.isNaN(a4.value[4].value))
          return false;
        p4 = a4;
      }
      if (h3 === r5 && 0 === r5.length && isTokenNode(p4) && p4.value[0] === e3.Ident && oe.has(toLowerCaseAZ2(p4.value[4].value))) {
        if (i5)
          return false;
        i5 = toLowerCaseAZ2(p4.value[4].value), m2.colorNotation = colorSpaceNameToColorNotation(i5), c2 && (c2.colorNotation !== m2.colorNotation && (c2 = colorDataTo(c2, m2.colorNotation)), s2 = normalizeRelativeColorDataChannels(c2), u3 = noneToZeroInRelativeColorDataChannels(s2));
      } else if (h3 === r5 && 0 === r5.length && isTokenNode(p4) && p4.value[0] === e3.Ident && "from" === toLowerCaseAZ2(p4.value[4].value)) {
        if (c2)
          return false;
        if (i5)
          return false;
        for (; isWhitespaceNode(a3.value[N3 + 1]) || isCommentNode(a3.value[N3 + 1]); )
          N3++;
        if (N3++, p4 = a3.value[N3], c2 = n4(p4), false === c2)
          return false;
        c2.syntaxFlags.has(ae.Experimental) && m2.syntaxFlags.add(ae.Experimental), m2.syntaxFlags.add(ae.RelativeColorSyntax);
      } else {
        if (!isTokenNode(p4))
          return false;
        if (p4.value[0] === e3.Ident && s2 && s2.has(toLowerCaseAZ2(p4.value[4].value))) {
          h3.push(new TokenNode(s2.get(toLowerCaseAZ2(p4.value[4].value))));
          continue;
        }
        h3.push(p4);
      }
    }
  }
  if (!i5)
    return false;
  if (1 !== h3.length)
    return false;
  if (1 !== r5.length || 1 !== o5.length || 1 !== t5.length)
    return false;
  if (!isTokenNode(r5[0]) || !isTokenNode(o5[0]) || !isTokenNode(t5[0]))
    return false;
  if (s2 && !s2.has("alpha"))
    return false;
  const N2 = normalize_Color_ChannelValues(r5[0].value, 0, m2);
  if (!N2 || N2[0] !== e3.Number)
    return false;
  const p3 = normalize_Color_ChannelValues(o5[0].value, 1, m2);
  if (!p3 || p3[0] !== e3.Number)
    return false;
  const b3 = normalize_Color_ChannelValues(t5[0].value, 2, m2);
  if (!b3 || b3[0] !== e3.Number)
    return false;
  const g3 = [N2, p3, b3];
  if (1 === l2.length)
    if (m2.syntaxFlags.add(ae.HasAlpha), isTokenNode(l2[0])) {
      const a4 = normalize_Color_ChannelValues(l2[0].value, 3, m2);
      if (!a4 || a4[0] !== e3.Number)
        return false;
      g3.push(a4);
    } else
      m2.alpha = l2[0];
  else if (s2 && s2.has("alpha")) {
    const a4 = normalize_Color_ChannelValues(s2.get("alpha"), 3, m2);
    if (!a4 || a4[0] !== e3.Number)
      return false;
    g3.push(a4);
  }
  return m2.channels = [g3[0][4].value, g3[1][4].value, g3[2][4].value], 4 === g3.length && (m2.alpha = g3[3][4].value), m2;
}
function colorSpaceNameToColorNotation(e4) {
  switch (e4) {
    case "srgb":
      return ee.sRGB;
    case "srgb-linear":
      return ee.Linear_sRGB;
    case "display-p3":
      return ee.Display_P3;
    case "a98-rgb":
      return ee.A98_RGB;
    case "prophoto-rgb":
      return ee.ProPhoto_RGB;
    case "rec2020":
      return ee.Rec2020;
    case "xyz":
    case "xyz-d65":
      return ee.XYZ_D65;
    case "xyz-d50":
      return ee.XYZ_D50;
    default:
      throw new Error("Unknown color space name: " + e4);
  }
}
var te = /* @__PURE__ */ new Set(["srgb", "srgb-linear", "lab", "oklab", "xyz", "xyz-d50", "xyz-d65"]);
var le = /* @__PURE__ */ new Set(["hsl", "hwb", "lch", "oklch"]);
var se = /* @__PURE__ */ new Set(["shorter", "longer", "increasing", "decreasing"]);
function colorMix(a3, n4) {
  let r5 = null, o5 = null, t5 = null, l2 = false;
  for (let s2 = 0; s2 < a3.value.length; s2++) {
    const u3 = a3.value[s2];
    if (!isWhitespaceNode(u3) && !isCommentNode(u3)) {
      if (isTokenNode(u3) && u3.value[0] === e3.Ident) {
        if (!r5 && "in" === toLowerCaseAZ2(u3.value[4].value)) {
          r5 = u3;
          continue;
        }
        if (r5 && !o5) {
          o5 = toLowerCaseAZ2(u3.value[4].value);
          continue;
        }
        if (r5 && o5 && !t5 && le.has(o5)) {
          t5 = toLowerCaseAZ2(u3.value[4].value);
          continue;
        }
        if (r5 && o5 && t5 && !l2 && "hue" === toLowerCaseAZ2(u3.value[4].value)) {
          l2 = true;
          continue;
        }
        return false;
      }
      return !(!isTokenNode(u3) || u3.value[0] !== e3.Comma) && (!!o5 && (t5 || l2 ? !!(o5 && t5 && l2 && le.has(o5) && se.has(t5)) && colorMixPolar(o5, t5, colorMixComponents(a3.value.slice(s2 + 1), n4)) : te.has(o5) ? colorMixRectangular(o5, colorMixComponents(a3.value.slice(s2 + 1), n4)) : !!le.has(o5) && colorMixPolar(o5, "shorter", colorMixComponents(a3.value.slice(s2 + 1), n4))));
    }
  }
  return false;
}
function colorMixComponents(a3, n4) {
  const r5 = [];
  let o5 = 1, t5 = false, l2 = false;
  for (let o6 = 0; o6 < a3.length; o6++) {
    let s3 = a3[o6];
    if (!isWhitespaceNode(s3) && !isCommentNode(s3)) {
      if (!isTokenNode(s3) || s3.value[0] !== e3.Comma) {
        if (!t5) {
          const e4 = n4(s3);
          if (e4) {
            t5 = e4;
            continue;
          }
        }
        if (!l2) {
          if (isFunctionNode(s3) && z2.has(toLowerCaseAZ2(s3.getName())) && ([[s3]] = calcFromComponentValues([[s3]], { toCanonicalUnits: true, precision: 100 }), !s3 || !isTokenNode(s3) || (s3.value[0] === e3.Percentage || s3.value[0] === e3.Number || s3.value[0] === e3.Dimension) && Number.isNaN(s3.value[4].value)))
            return false;
          if (isTokenNode(s3) && s3.value[0] === e3.Percentage && s3.value[4].value >= 0) {
            l2 = s3.value[4].value;
            continue;
          }
        }
        return false;
      }
      if (!t5)
        return false;
      r5.push({ color: t5, percentage: l2 }), t5 = false, l2 = false;
    }
  }
  if (t5 && r5.push({ color: t5, percentage: l2 }), 2 !== r5.length)
    return false;
  let s2 = r5[0].percentage, u3 = r5[1].percentage;
  return (false === s2 || !(s2 < 0 || s2 > 100)) && ((false === u3 || !(u3 < 0 || u3 > 100)) && (false === s2 && false === u3 ? (s2 = 50, u3 = 50) : false !== s2 && false === u3 ? u3 = 100 - s2 : false === s2 && false !== u3 && (s2 = 100 - u3), (0 !== s2 || 0 !== u3) && (false !== s2 && false !== u3 && (s2 + u3 > 100 && (s2 = s2 / (s2 + u3) * 100, u3 = u3 / (s2 + u3) * 100), s2 + u3 < 100 && (o5 = (s2 + u3) / 100, s2 = s2 / (s2 + u3) * 100, u3 = u3 / (s2 + u3) * 100), { a: { color: r5[0].color, percentage: s2 }, b: { color: r5[1].color, percentage: u3 }, alphaMultiplier: o5 }))));
}
function colorMixRectangular(e4, a3) {
  if (!a3)
    return false;
  const n4 = a3.a.color, r5 = a3.b.color, o5 = a3.a.percentage / 100;
  let t5 = n4.channels, l2 = r5.channels, s2 = ee.RGB, u3 = n4.alpha;
  if ("number" != typeof u3)
    return false;
  let i5 = r5.alpha;
  if ("number" != typeof i5)
    return false;
  switch (u3 = Number.isNaN(u3) ? i5 : u3, i5 = Number.isNaN(i5) ? u3 : i5, e4) {
    case "srgb":
      s2 = ee.RGB;
      break;
    case "srgb-linear":
      s2 = ee.Linear_sRGB;
      break;
    case "lab":
      s2 = ee.Lab;
      break;
    case "oklab":
      s2 = ee.OKLab;
      break;
    case "xyz-d50":
      s2 = ee.XYZ_D50;
      break;
    case "xyz":
    case "xyz-d65":
      s2 = ee.XYZ_D65;
  }
  t5 = colorDataTo(n4, s2).channels, l2 = colorDataTo(r5, s2).channels, t5[0] = fillInMissingComponent(t5[0], l2[0]), l2[0] = fillInMissingComponent(l2[0], t5[0]), t5[1] = fillInMissingComponent(t5[1], l2[1]), l2[1] = fillInMissingComponent(l2[1], t5[1]), t5[2] = fillInMissingComponent(t5[2], l2[2]), l2[2] = fillInMissingComponent(l2[2], t5[2]), t5[0] = premultiply(t5[0], u3), t5[1] = premultiply(t5[1], u3), t5[2] = premultiply(t5[2], u3), l2[0] = premultiply(l2[0], i5), l2[1] = premultiply(l2[1], i5), l2[2] = premultiply(l2[2], i5);
  const c2 = interpolate(u3, i5, o5), m2 = { colorNotation: s2, channels: [un_premultiply(interpolate(t5[0], l2[0], o5), c2), un_premultiply(interpolate(t5[1], l2[1], o5), c2), un_premultiply(interpolate(t5[2], l2[2], o5), c2)], alpha: c2 * a3.alphaMultiplier, syntaxFlags: /* @__PURE__ */ new Set([ae.ColorMix]) };
  return (a3.a.color.syntaxFlags.has(ae.Experimental) || a3.b.color.syntaxFlags.has(ae.Experimental)) && m2.syntaxFlags.add(ae.Experimental), m2;
}
function colorMixPolar(e4, a3, n4) {
  if (!n4)
    return false;
  const r5 = n4.a.color, o5 = n4.b.color, t5 = n4.a.percentage / 100;
  let l2 = r5.channels, s2 = o5.channels, u3 = 0, i5 = 0, c2 = 0, m2 = 0, h3 = 0, N2 = 0, p3 = ee.RGB, b3 = r5.alpha;
  if ("number" != typeof b3)
    return false;
  let g3 = o5.alpha;
  if ("number" != typeof g3)
    return false;
  switch (b3 = Number.isNaN(b3) ? g3 : b3, g3 = Number.isNaN(g3) ? b3 : g3, e4) {
    case "hsl":
      p3 = ee.HSL;
      break;
    case "hwb":
      p3 = ee.HWB;
      break;
    case "lch":
      p3 = ee.LCH;
      break;
    case "oklch":
      p3 = ee.OKLCH;
  }
  switch (l2 = colorDataTo(r5, p3).channels, s2 = colorDataTo(o5, p3).channels, e4) {
    case "hsl":
    case "hwb":
      u3 = l2[0], i5 = s2[0], c2 = l2[1], m2 = s2[1], h3 = l2[2], N2 = s2[2];
      break;
    case "lch":
    case "oklch":
      c2 = l2[0], m2 = s2[0], h3 = l2[1], N2 = s2[1], u3 = l2[2], i5 = s2[2];
  }
  u3 = fillInMissingComponent(u3, i5), Number.isNaN(u3) && (u3 = 0), i5 = fillInMissingComponent(i5, u3), Number.isNaN(i5) && (i5 = 0), c2 = fillInMissingComponent(c2, m2), m2 = fillInMissingComponent(m2, c2), h3 = fillInMissingComponent(h3, N2), N2 = fillInMissingComponent(N2, h3);
  const v2 = i5 - u3;
  switch (a3) {
    case "shorter":
      v2 > 180 ? u3 += 360 : v2 < -180 && (i5 += 360);
      break;
    case "longer":
      -180 < v2 && v2 < 180 && (v2 > 0 ? u3 += 360 : i5 += 360);
      break;
    case "increasing":
      v2 < 0 && (i5 += 360);
      break;
    case "decreasing":
      v2 > 0 && (u3 += 360);
      break;
    default:
      throw new Error("Unknown hue interpolation method");
  }
  c2 = premultiply(c2, b3), h3 = premultiply(h3, b3), m2 = premultiply(m2, g3), N2 = premultiply(N2, g3);
  let d3 = [0, 0, 0];
  const f2 = interpolate(b3, g3, t5);
  switch (e4) {
    case "hsl":
    case "hwb":
      d3 = [interpolate(u3, i5, t5), un_premultiply(interpolate(c2, m2, t5), f2), un_premultiply(interpolate(h3, N2, t5), f2)];
      break;
    case "lch":
    case "oklch":
      d3 = [un_premultiply(interpolate(c2, m2, t5), f2), un_premultiply(interpolate(h3, N2, t5), f2), interpolate(u3, i5, t5)];
  }
  const y3 = { colorNotation: p3, channels: d3, alpha: f2 * n4.alphaMultiplier, syntaxFlags: /* @__PURE__ */ new Set([ae.ColorMix]) };
  return (n4.a.color.syntaxFlags.has(ae.Experimental) || n4.b.color.syntaxFlags.has(ae.Experimental)) && y3.syntaxFlags.add(ae.Experimental), y3;
}
function fillInMissingComponent(e4, a3) {
  return Number.isNaN(e4) ? a3 : e4;
}
function interpolate(e4, a3, n4) {
  return e4 * n4 + a3 * (1 - n4);
}
function premultiply(e4, a3) {
  return Number.isNaN(a3) ? e4 : Number.isNaN(e4) ? NaN : e4 * a3;
}
function un_premultiply(e4, a3) {
  return 0 === a3 || Number.isNaN(a3) ? e4 : Number.isNaN(e4) ? NaN : e4 / a3;
}
function hex(e4) {
  const a3 = toLowerCaseAZ2(e4[4].value);
  if (a3.match(/[^a-f0-9]/))
    return false;
  const n4 = { colorNotation: ee.HEX, channels: [0, 0, 0], alpha: 1, syntaxFlags: /* @__PURE__ */ new Set([ae.Hex]) }, r5 = a3.length;
  if (3 === r5) {
    const e5 = a3[0], r6 = a3[1], o5 = a3[2];
    return n4.channels = [parseInt(e5 + e5, 16) / 255, parseInt(r6 + r6, 16) / 255, parseInt(o5 + o5, 16) / 255], n4;
  }
  if (6 === r5) {
    const e5 = a3[0] + a3[1], r6 = a3[2] + a3[3], o5 = a3[4] + a3[5];
    return n4.channels = [parseInt(e5, 16) / 255, parseInt(r6, 16) / 255, parseInt(o5, 16) / 255], n4;
  }
  if (4 === r5) {
    const e5 = a3[0], r6 = a3[1], o5 = a3[2], t5 = a3[3];
    return n4.channels = [parseInt(e5 + e5, 16) / 255, parseInt(r6 + r6, 16) / 255, parseInt(o5 + o5, 16) / 255], n4.alpha = parseInt(t5 + t5, 16) / 255, n4.syntaxFlags.add(ae.HasAlpha), n4;
  }
  if (8 === r5) {
    const e5 = a3[0] + a3[1], r6 = a3[2] + a3[3], o5 = a3[4] + a3[5], t5 = a3[6] + a3[7];
    return n4.channels = [parseInt(e5, 16) / 255, parseInt(r6, 16) / 255, parseInt(o5, 16) / 255], n4.alpha = parseInt(t5, 16) / 255, n4.syntaxFlags.add(ae.HasAlpha), n4;
  }
  return false;
}
function normalizeHue(n4) {
  if (n4[0] === e3.Number)
    return n4[4].value = n4[4].value % 360, n4[1] = n4[4].value.toString(), n4;
  if (n4[0] === e3.Dimension) {
    let r5 = n4[4].value;
    switch (toLowerCaseAZ2(n4[4].unit)) {
      case "deg":
        break;
      case "rad":
        r5 = 180 * n4[4].value / Math.PI;
        break;
      case "grad":
        r5 = 0.9 * n4[4].value;
        break;
      case "turn":
        r5 = 360 * n4[4].value;
        break;
      default:
        return false;
    }
    return r5 %= 360, [e3.Number, r5.toString(), n4[2], n4[3], { value: r5, type: n2.Number }];
  }
  return false;
}
function normalize_legacy_HSL_ChannelValues(n4, r5, o5) {
  if (0 === r5) {
    const a3 = normalizeHue(n4);
    return false !== a3 && (n4[0] === e3.Dimension && o5.syntaxFlags.add(ae.HasDimensionValues), a3);
  }
  if (n4[0] === e3.Percentage) {
    3 === r5 ? o5.syntaxFlags.add(ae.HasPercentageAlpha) : o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 1, 0, 100);
    return 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    if (3 !== r5)
      return false;
    let o6 = normalize(n4[4].value, 1, 0, 100);
    return 3 === r5 && (o6 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, o6.toString(), n4[2], n4[3], { value: o6, type: n2.Number }];
  }
  return false;
}
function normalize_modern_HSL_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (0 === r5) {
    const a3 = normalizeHue(n4);
    return false !== a3 && (n4[0] === e3.Dimension && o5.syntaxFlags.add(ae.HasDimensionValues), a3);
  }
  if (n4[0] === e3.Percentage) {
    3 === r5 ? o5.syntaxFlags.add(ae.HasPercentageAlpha) : o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = n4[4].value;
    return 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = n4[4].value;
    return 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function threeChannelLegacySyntax(a3, n4, r5, o5) {
  const t5 = [], l2 = [], s2 = [], u3 = [], i5 = { colorNotation: r5, channels: [0, 0, 0], alpha: 1, syntaxFlags: new Set(o5) };
  let c2 = t5;
  for (let n5 = 0; n5 < a3.value.length; n5++) {
    let r6 = a3.value[n5];
    if (!isWhitespaceNode(r6) && !isCommentNode(r6)) {
      if (isTokenNode(r6) && r6.value[0] === e3.Comma) {
        if (c2 === t5) {
          c2 = l2;
          continue;
        }
        if (c2 === l2) {
          c2 = s2;
          continue;
        }
        if (c2 === s2) {
          c2 = u3;
          continue;
        }
        if (c2 === u3)
          return false;
      }
      if (isFunctionNode(r6)) {
        if (c2 === u3 && "var" === toLowerCaseAZ2(r6.getName())) {
          i5.syntaxFlags.add(ae.HasVariableAlpha), c2.push(r6);
          continue;
        }
        if (!z2.has(toLowerCaseAZ2(r6.getName())))
          return false;
        const [[a4]] = calcFromComponentValues([[r6]], { toCanonicalUnits: true, precision: 100 });
        if (!a4 || !isTokenNode(a4) || (a4.value[0] === e3.Percentage || a4.value[0] === e3.Number || a4.value[0] === e3.Dimension) && Number.isNaN(a4.value[4].value))
          return false;
        r6 = a4;
      }
      if (!isTokenNode(r6))
        return false;
      c2.push(r6);
    }
  }
  if (1 !== c2.length)
    return false;
  if (1 !== t5.length || 1 !== l2.length || 1 !== s2.length)
    return false;
  if (!isTokenNode(t5[0]) || !isTokenNode(l2[0]) || !isTokenNode(s2[0]))
    return false;
  const m2 = n4(t5[0].value, 0, i5);
  if (!m2 || m2[0] !== e3.Number)
    return false;
  const h3 = n4(l2[0].value, 1, i5);
  if (!h3 || h3[0] !== e3.Number)
    return false;
  const N2 = n4(s2[0].value, 2, i5);
  if (!N2 || N2[0] !== e3.Number)
    return false;
  const p3 = [m2, h3, N2];
  if (1 === u3.length)
    if (i5.syntaxFlags.add(ae.HasAlpha), isTokenNode(u3[0])) {
      const a4 = n4(u3[0].value, 3, i5);
      if (!a4 || a4[0] !== e3.Number)
        return false;
      p3.push(a4);
    } else
      i5.alpha = u3[0];
  return i5.channels = [p3[0][4].value, p3[1][4].value, p3[2][4].value], 4 === p3.length && (i5.alpha = p3[3][4].value), i5;
}
function threeChannelSpaceSeparated(a3, n4, r5, o5, t5) {
  const l2 = toLowerCaseAZ2(a3.getName()), s2 = [], u3 = [], i5 = [], c2 = [];
  let m2, h3, N2 = false;
  const p3 = { colorNotation: r5, channels: [0, 0, 0], alpha: 1, syntaxFlags: new Set(o5) };
  let b3 = s2;
  for (let n5 = 0; n5 < a3.value.length; n5++) {
    let o6 = a3.value[n5];
    if (isWhitespaceNode(o6) || isCommentNode(o6))
      for (; isWhitespaceNode(a3.value[n5 + 1]) || isCommentNode(a3.value[n5 + 1]); )
        n5++;
    else if (b3 === s2 && s2.length && (b3 = u3), b3 === u3 && u3.length && (b3 = i5), isTokenNode(o6) && o6.value[0] === e3.Delim && "/" === o6.value[4].value) {
      if (b3 === c2)
        return false;
      b3 = c2;
    } else {
      if (isFunctionNode(o6)) {
        if (b3 === c2 && "var" === toLowerCaseAZ2(o6.getName())) {
          p3.syntaxFlags.add(ae.HasVariableAlpha), b3.push(o6);
          continue;
        }
        if (!z2.has(toLowerCaseAZ2(o6.getName())))
          return false;
        const [[a4]] = calcFromComponentValues([[o6]], { toCanonicalUnits: true, precision: 100, globals: h3 });
        if (!a4 || !isTokenNode(a4) || (a4.value[0] === e3.Percentage || a4.value[0] === e3.Number || a4.value[0] === e3.Dimension) && Number.isNaN(a4.value[4].value))
          return false;
        o6 = a4;
      }
      if (b3 === s2 && 0 === s2.length && isTokenNode(o6) && o6.value[0] === e3.Ident && "from" === toLowerCaseAZ2(o6.value[4].value) && "hsla" !== l2 && "rgba" !== l2) {
        if (N2)
          return false;
        for (; isWhitespaceNode(a3.value[n5 + 1]) || isCommentNode(a3.value[n5 + 1]); )
          n5++;
        if (n5++, o6 = a3.value[n5], N2 = t5(o6), false === N2)
          return false;
        N2.syntaxFlags.has(ae.Experimental) && p3.syntaxFlags.add(ae.Experimental), p3.syntaxFlags.add(ae.RelativeColorSyntax), N2.colorNotation !== r5 && (N2 = colorDataTo(N2, r5)), m2 = normalizeRelativeColorDataChannels(N2), h3 = noneToZeroInRelativeColorDataChannels(m2);
      } else {
        if (!isTokenNode(o6))
          return false;
        if (o6.value[0] === e3.Ident && m2 && m2.has(toLowerCaseAZ2(o6.value[4].value))) {
          b3.push(new TokenNode(m2.get(toLowerCaseAZ2(o6.value[4].value))));
          continue;
        }
        b3.push(o6);
      }
    }
  }
  if (1 !== b3.length)
    return false;
  if (1 !== s2.length || 1 !== u3.length || 1 !== i5.length)
    return false;
  if (!isTokenNode(s2[0]) || !isTokenNode(u3[0]) || !isTokenNode(i5[0]))
    return false;
  if (m2 && !m2.has("alpha"))
    return false;
  const g3 = n4(s2[0].value, 0, p3);
  if (!g3 || g3[0] !== e3.Number)
    return false;
  const v2 = n4(u3[0].value, 1, p3);
  if (!v2 || v2[0] !== e3.Number)
    return false;
  const d3 = n4(i5[0].value, 2, p3);
  if (!d3 || d3[0] !== e3.Number)
    return false;
  const f2 = [g3, v2, d3];
  if (1 === c2.length)
    if (p3.syntaxFlags.add(ae.HasAlpha), isTokenNode(c2[0])) {
      const a4 = n4(c2[0].value, 3, p3);
      if (!a4 || a4[0] !== e3.Number)
        return false;
      f2.push(a4);
    } else
      p3.alpha = c2[0];
  else if (m2 && m2.has("alpha")) {
    const a4 = n4(m2.get("alpha"), 3, p3);
    if (!a4 || a4[0] !== e3.Number)
      return false;
    f2.push(a4);
  }
  return p3.channels = [f2[0][4].value, f2[1][4].value, f2[2][4].value], 4 === f2.length && (p3.alpha = f2[3][4].value), p3;
}
function hsl(a3, n4) {
  if (a3.value.some((a4) => isTokenNode(a4) && a4.value[0] === e3.Comma)) {
    const e4 = hslCommaSeparated(a3);
    if (false !== e4)
      return e4;
  }
  {
    const e4 = hslSpaceSeparated(a3, n4);
    if (false !== e4)
      return e4;
  }
  return false;
}
function hslCommaSeparated(e4) {
  return threeChannelLegacySyntax(e4, normalize_legacy_HSL_ChannelValues, ee.HSL, [ae.LegacyHSL]);
}
function hslSpaceSeparated(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_modern_HSL_ChannelValues, ee.HSL, [], a3);
}
function normalize_HWB_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (0 === r5) {
    const a3 = normalizeHue(n4);
    return false !== a3 && (n4[0] === e3.Dimension && o5.syntaxFlags.add(ae.HasDimensionValues), a3);
  }
  if (n4[0] === e3.Percentage) {
    3 === r5 ? o5.syntaxFlags.add(ae.HasPercentageAlpha) : o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = n4[4].value;
    return 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = n4[4].value;
    return 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function normalize_Lab_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 1, 0, 100);
    return 1 === r5 || 2 === r5 ? t5 = normalize(n4[4].value, 0.8, -1 / 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 1, 0, 100);
    return 1 === r5 || 2 === r5 ? t5 = normalize(n4[4].value, 1, -1 / 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function lab(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_Lab_ChannelValues, ee.Lab, [], a3);
}
function normalize_LCH_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (2 === r5) {
    const a3 = normalizeHue(n4);
    return false !== a3 && (n4[0] === e3.Dimension && o5.syntaxFlags.add(ae.HasDimensionValues), a3);
  }
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 1, 0, 100);
    return 1 === r5 ? t5 = normalize(n4[4].value, 100 / 150, 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 1, 0, 100);
    return 1 === r5 ? t5 = normalize(n4[4].value, 1, 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function lch(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_LCH_ChannelValues, ee.LCH, [], a3);
}
var ue = /* @__PURE__ */ new Map();
for (const [e4, a3] of Object.entries(o4))
  ue.set(e4, a3);
function namedColor(e4) {
  const a3 = ue.get(toLowerCaseAZ2(e4));
  return !!a3 && { colorNotation: ee.RGB, channels: [a3[0] / 255, a3[1] / 255, a3[2] / 255], alpha: 1, syntaxFlags: /* @__PURE__ */ new Set([ae.ColorKeyword, ae.NamedColor]) };
}
function normalize_OKLab_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 100, 0, 1);
    return 1 === r5 || 2 === r5 ? t5 = normalize(n4[4].value, 250, -1 / 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 1, 0, 1);
    return 1 === r5 || 2 === r5 ? t5 = normalize(n4[4].value, 1, -1 / 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function oklab(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_OKLab_ChannelValues, ee.OKLab, [], a3);
}
function normalize_OKLCH_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (2 === r5) {
    const a3 = normalizeHue(n4);
    return false !== a3 && (n4[0] === e3.Dimension && o5.syntaxFlags.add(ae.HasDimensionValues), a3);
  }
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 100, 0, 1);
    return 1 === r5 ? t5 = normalize(n4[4].value, 250, 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 1, 0, 1);
    return 1 === r5 ? t5 = normalize(n4[4].value, 1, 0, 1 / 0) : 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function oklch(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_OKLCH_ChannelValues, ee.OKLCH, [], a3);
}
function normalize_legacy_sRGB_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Percentage) {
    3 === r5 ? o5.syntaxFlags.add(ae.HasPercentageAlpha) : o5.syntaxFlags.add(ae.HasPercentageValues);
    const t5 = normalize(n4[4].value, 100, 0, 1);
    return [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 255, 0, 1);
    return 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function normalize_modern_sRGB_ChannelValues(n4, r5, o5) {
  if (n4[0] === e3.Ident && "none" === toLowerCaseAZ2(n4[4].value))
    return o5.syntaxFlags.add(ae.HasNoneKeywords), [e3.Number, "none", n4[2], n4[3], { value: NaN, type: n2.Number }];
  if (n4[0] === e3.Percentage) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasPercentageValues);
    let t5 = normalize(n4[4].value, 100, -1 / 0, 1 / 0);
    return 3 === r5 && (t5 = normalize(n4[4].value, 100, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  if (n4[0] === e3.Number) {
    3 !== r5 && o5.syntaxFlags.add(ae.HasNumberValues);
    let t5 = normalize(n4[4].value, 255, -1 / 0, 1 / 0);
    return 3 === r5 && (t5 = normalize(n4[4].value, 1, 0, 1)), [e3.Number, t5.toString(), n4[2], n4[3], { value: t5, type: n2.Number }];
  }
  return false;
}
function rgb(a3, n4) {
  if (a3.value.some((a4) => isTokenNode(a4) && a4.value[0] === e3.Comma)) {
    const e4 = rgbCommaSeparated(a3);
    if (false !== e4)
      return (!e4.syntaxFlags.has(ae.HasNumberValues) || !e4.syntaxFlags.has(ae.HasPercentageValues)) && e4;
  } else {
    const e4 = rgbSpaceSeparated(a3, n4);
    if (false !== e4)
      return e4;
  }
  return false;
}
function rgbCommaSeparated(e4) {
  return threeChannelLegacySyntax(e4, normalize_legacy_sRGB_ChannelValues, ee.RGB, [ae.LegacyRGB]);
}
function rgbSpaceSeparated(e4, a3) {
  return threeChannelSpaceSeparated(e4, normalize_modern_sRGB_ChannelValues, ee.RGB, [], a3);
}
function toPrecision(e4, a3 = 7) {
  e4 = +e4, a3 = +a3;
  const n4 = (Math.floor(e4) + "").length;
  if (a3 > n4)
    return +e4.toFixed(a3 - n4);
  {
    const r5 = 10 ** (n4 - a3);
    return Math.round(e4 / r5) * r5;
  }
}
function XYZ_D50_to_sRGB_Gamut(e4) {
  const a3 = XYZ_D50_to_sRGB(e4);
  if (inGamut(a3))
    return clip(a3);
  let n4 = e4.slice();
  return n4 = XYZ_D50_to_OKLCH(n4), n4[0] < 1e-6 && (n4 = [0, 0, 0]), n4[0] > 0.999999 && (n4 = [1, 0, 0]), mapGamut(n4, (e5) => (e5 = OKLCH_to_OKLab(e5), e5 = OKLab_to_XYZ(e5), e5 = XYZ_to_lin_sRGB(e5), gam_sRGB(e5)), (e5) => (e5 = lin_sRGB(e5), e5 = lin_sRGB_to_XYZ(e5), e5 = XYZ_to_OKLab(e5), OKLab_to_OKLCH(e5)));
}
function serializeRGB(n4, r5 = true) {
  n4.channels = convertPowerlessComponentsToZeroValuesForDisplay(n4.channels, n4.colorNotation);
  let o5 = n4.channels.map((e4) => Number.isNaN(e4) ? 0 : e4);
  o5 = r5 ? XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(n4).channels) : XYZ_D50_to_sRGB(colorData_to_XYZ_D50(n4).channels);
  const t5 = Math.min(255, Math.max(0, Math.round(255 * toPrecision(o5[0])))), l2 = Math.min(255, Math.max(0, Math.round(255 * toPrecision(o5[1])))), s2 = Math.min(255, Math.max(0, Math.round(255 * toPrecision(o5[2])))), u3 = [e3.CloseParen, ")", -1, -1, void 0], i5 = [e3.Whitespace, " ", -1, -1, void 0], c2 = [e3.Comma, ",", -1, -1, void 0], m2 = [new TokenNode([e3.Number, t5.toString(), -1, -1, { value: o5[0], type: n2.Integer }]), new TokenNode(c2), new WhitespaceNode([i5]), new TokenNode([e3.Number, l2.toString(), -1, -1, { value: o5[1], type: n2.Integer }]), new TokenNode(c2), new WhitespaceNode([i5]), new TokenNode([e3.Number, s2.toString(), -1, -1, { value: o5[2], type: n2.Integer }])];
  if ("number" == typeof n4.alpha) {
    const r6 = Math.min(1, Math.max(0, toPrecision(Number.isNaN(n4.alpha) ? 0 : n4.alpha)));
    return 1 === toPrecision(r6, 4) ? new FunctionNode([e3.Function, "rgb(", -1, -1, { value: "rgb" }], u3, m2) : new FunctionNode([e3.Function, "rgba(", -1, -1, { value: "rgba" }], u3, [...m2, new TokenNode(c2), new WhitespaceNode([i5]), new TokenNode([e3.Number, toPrecision(r6, 4).toString(), -1, -1, { value: n4.alpha, type: n2.Number }])]);
  }
  return new FunctionNode([e3.Function, "rgba(", -1, -1, { value: "rgba" }], u3, [...m2, new TokenNode(c2), new WhitespaceNode([i5]), n4.alpha]);
}
function serializeHSL(n4, r5 = true) {
  n4.channels = convertPowerlessComponentsToZeroValuesForDisplay(n4.channels, n4.colorNotation);
  let o5 = n4.channels.map((e4) => Number.isNaN(e4) ? 0 : e4);
  o5 = XYZ_D50_to_HSL(r5 ? sRGB_to_XYZ_D50(XYZ_D50_to_sRGB_Gamut(colorData_to_XYZ_D50(n4).channels)) : colorData_to_XYZ_D50(n4).channels), o5 = o5.map((e4) => Number.isNaN(e4) ? 0 : e4);
  const t5 = Math.min(360, Math.max(0, Math.round(toPrecision(o5[0])))), l2 = Math.min(100, Math.max(0, Math.round(toPrecision(o5[1])))), s2 = Math.min(100, Math.max(0, Math.round(toPrecision(o5[2])))), u3 = [e3.CloseParen, ")", -1, -1, void 0], c2 = [e3.Whitespace, " ", -1, -1, void 0], m2 = [e3.Comma, ",", -1, -1, void 0], h3 = [new TokenNode([e3.Number, t5.toString(), -1, -1, { value: o5[0], type: n2.Integer }]), new TokenNode(m2), new WhitespaceNode([c2]), new TokenNode([e3.Percentage, l2.toString() + "%", -1, -1, { value: o5[1] }]), new TokenNode(m2), new WhitespaceNode([c2]), new TokenNode([e3.Percentage, s2.toString() + "%", -1, -1, { value: o5[2] }])];
  if ("number" == typeof n4.alpha) {
    const r6 = Math.min(1, Math.max(0, toPrecision(Number.isNaN(n4.alpha) ? 0 : n4.alpha)));
    return 1 === toPrecision(r6, 4) ? new FunctionNode([e3.Function, "hsl(", -1, -1, { value: "hsl" }], u3, h3) : new FunctionNode([e3.Function, "hsla(", -1, -1, { value: "hsla" }], u3, [...h3, new TokenNode(m2), new WhitespaceNode([c2]), new TokenNode([e3.Number, toPrecision(r6, 4).toString(), -1, -1, { value: n4.alpha, type: n2.Number }])]);
  }
  return new FunctionNode([e3.Function, "hsla(", -1, -1, { value: "hsla" }], u3, [...h3, new TokenNode(m2), new WhitespaceNode([c2]), n4.alpha]);
}
function color(a3) {
  if (isFunctionNode(a3)) {
    switch (toLowerCaseAZ2(a3.getName())) {
      case "rgb":
      case "rgba":
        return rgb(a3, color);
      case "hsl":
      case "hsla":
        return hsl(a3, color);
      case "hwb":
        return n4 = color, threeChannelSpaceSeparated(a3, normalize_HWB_ChannelValues, ee.HWB, [], n4);
      case "lab":
        return lab(a3, color);
      case "lch":
        return lch(a3, color);
      case "oklab":
        return oklab(a3, color);
      case "oklch":
        return oklch(a3, color);
      case "color":
        return color$1(a3, color);
      case "color-mix":
        return colorMix(a3, color);
    }
  }
  var n4;
  if (isTokenNode(a3)) {
    if (a3.value[0] === e3.Hash)
      return hex(a3.value);
    if (a3.value[0] === e3.Ident) {
      const e4 = namedColor(a3.value[4].value);
      return false !== e4 ? e4 : "transparent" === toLowerCaseAZ2(a3.value[4].value) && { colorNotation: ee.RGB, channels: [0, 0, 0], alpha: 0, syntaxFlags: /* @__PURE__ */ new Set([ae.ColorKeyword]) };
    }
  }
  return false;
}

// node_modules/postcss-color-functional-notation/dist/index.mjs
function hasFallback(s2) {
  const t5 = s2.parent;
  if (!t5)
    return false;
  const e4 = s2.prop.toLowerCase(), o5 = t5.index(s2);
  for (let s3 = 0; s3 < o5; s3++) {
    const o6 = t5.nodes[s3];
    if ("decl" === o6.type && o6.prop.toLowerCase() === e4)
      return true;
  }
  return false;
}
var i4 = /(?:rgb|hsl)a?\(/i;
function hasSupportsAtRuleAncestor(s2) {
  let t5 = s2.parent;
  for (; t5; )
    if ("atrule" === t5.type) {
      if ("supports" === t5.name.toLowerCase() && i4.test(t5.params))
        return true;
      t5 = t5.parent;
    } else
      t5 = t5.parent;
  return false;
}
var u2 = /^(?:rgb|hsl)a?$/i;
var basePlugin = (s2) => ({ postcssPlugin: "postcss-color-functional-notation", Declaration: (f2) => {
  const g3 = f2.value;
  if (!i4.test(g3))
    return;
  if (hasFallback(f2))
    return;
  if (hasSupportsAtRuleAncestor(f2))
    return;
  const m2 = replaceComponentValues(parseCommaSeparatedListOfComponentValues(tokenize({ css: g3 })), (s3) => {
    if (!isFunctionNode(s3) || !u2.test(s3.getName()))
      return;
    const t5 = color(s3);
    return !t5 || t5.syntaxFlags.has(ae.Experimental) || t5.syntaxFlags.has(ae.HasNoneKeywords) || t5.syntaxFlags.has(ae.RelativeColorSyntax) || (t5.syntaxFlags.has(ae.LegacyRGB) || t5.syntaxFlags.has(ae.LegacyHSL)) && !t5.syntaxFlags.has(ae.HasPercentageAlpha) ? void 0 : "hsl" === t5.colorNotation ? serializeHSL(t5) : serializeRGB(t5);
  }), h3 = stringify5(m2);
  h3 !== g3 && (f2.cloneBefore({ value: h3 }), s2?.preserve || f2.remove());
} });
basePlugin.postcss = true;
var postcssPlugin = (t5) => {
  const e4 = Object.assign({ preserve: false, enableProgressiveCustomProperties: true }, t5);
  return e4.enableProgressiveCustomProperties && e4.preserve ? { postcssPlugin: "postcss-color-functional-notation", plugins: [creator2(), basePlugin(e4)] } : basePlugin(e4);
};
postcssPlugin.postcss = true;

// src/tailwind/utils.resend.ts
init_shim();
import * as React8 from "react";
import { renderToString } from "react-dom/server";
var propToAttributeString = (propValue) => {
  if (typeof propValue === "string")
    return propValue;
  else if (typeof propValue === "object")
    return JSON.stringify(propValue);
};
var quickSafeRenderToString = (element) => {
  if (typeof element === "string" || typeof element === "number") {
    return String(element);
  }
  if (Array.isArray(element)) {
    return element.map(quickSafeRenderToString).join("");
  }
  if (React8.isValidElement(element)) {
    const { type, props } = element;
    if (typeof type === "function") {
      const isClass = type.prototype && type.prototype.isReactComponent;
      if (isClass) {
        const classComponent = type;
        const componentInstance = renderToString(
          React8.createElement(classComponent, props)
        );
        return componentInstance;
      }
      const functionComponent = type;
      const componentRenderingResults = functionComponent(props);
      return quickSafeRenderToString(componentRenderingResults);
    }
    let elementAttributes = Object.keys(props || {}).filter((propName) => propName !== "children").map((prop) => `${prop}="${propToAttributeString(props[prop])}"`).join(" ");
    elementAttributes = elementAttributes.trim().length > 0 ? ` ${elementAttributes}` : "";
    const children = props && "children" in props ? props.children : "";
    const renderedChildren = children ? quickSafeRenderToString(children) : "";
    return typeof element.type === "symbol" ? renderedChildren : `<${element.type.toString()}${elementAttributes}>${renderedChildren}</${element.type.toString()}>`;
  }
  return "";
};

// raw-loader:../../node_modules/tailwindcss/lib/css/preflight.css?raw
var preflight_default = "/*\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\n*/\n\n*,\n::before,\n::after {\n  box-sizing: border-box; /* 1 */\n  border-width: 0; /* 2 */\n  border-style: solid; /* 2 */\n  border-color: theme('borderColor.DEFAULT', currentColor); /* 2 */\n}\n\n::before,\n::after {\n  --tw-content: '';\n}\n\n/*\n1. Use a consistent sensible line-height in all browsers.\n2. Prevent adjustments of font size after orientation changes in iOS.\n3. Use a more readable tab size.\n4. Use the user's configured `sans` font-family by default.\n5. Use the user's configured `sans` font-feature-settings by default.\n6. Use the user's configured `sans` font-variation-settings by default.\n*/\n\nhtml {\n  line-height: 1.5; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n  -moz-tab-size: 4; /* 3 */\n  tab-size: 4; /* 3 */\n  font-family: theme('fontFamily.sans', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"); /* 4 */\n  font-feature-settings: theme('fontFamily.sans[1].fontFeatureSettings', normal); /* 5 */\n  font-variation-settings: theme('fontFamily.sans[1].fontVariationSettings', normal); /* 6 */\n}\n\n/*\n1. Remove the margin in all browsers.\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\n*/\n\nbody {\n  margin: 0; /* 1 */\n  line-height: inherit; /* 2 */\n}\n\n/*\n1. Add the correct height in Firefox.\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n3. Ensure horizontal rules are visible by default.\n*/\n\nhr {\n  height: 0; /* 1 */\n  color: inherit; /* 2 */\n  border-top-width: 1px; /* 3 */\n}\n\n/*\nAdd the correct text decoration in Chrome, Edge, and Safari.\n*/\n\nabbr:where([title]) {\n  text-decoration: underline dotted;\n}\n\n/*\nRemove the default font size and weight for headings.\n*/\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-size: inherit;\n  font-weight: inherit;\n}\n\n/*\nReset links to optimize for opt-in styling instead of opt-out.\n*/\n\na {\n  color: inherit;\n  text-decoration: inherit;\n}\n\n/*\nAdd the correct font weight in Edge and Safari.\n*/\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/*\n1. Use the user's configured `mono` font family by default.\n2. Correct the odd `em` font sizing in all browsers.\n*/\n\ncode,\nkbd,\nsamp,\npre {\n  font-family: theme('fontFamily.mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace); /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/*\nAdd the correct font size in all browsers.\n*/\n\nsmall {\n  font-size: 80%;\n}\n\n/*\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\n*/\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/*\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n3. Remove gaps between table borders by default.\n*/\n\ntable {\n  text-indent: 0; /* 1 */\n  border-color: inherit; /* 2 */\n  border-collapse: collapse; /* 3 */\n}\n\n/*\n1. Change the font styles in all browsers.\n2. Remove the margin in Firefox and Safari.\n3. Remove default padding in all browsers.\n*/\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  font-weight: inherit; /* 1 */\n  line-height: inherit; /* 1 */\n  color: inherit; /* 1 */\n  margin: 0; /* 2 */\n  padding: 0; /* 3 */\n}\n\n/*\nRemove the inheritance of text transform in Edge and Firefox.\n*/\n\nbutton,\nselect {\n  text-transform: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Remove default button styles.\n*/\n\nbutton,\n[type='button'],\n[type='reset'],\n[type='submit'] {\n  -webkit-appearance: button; /* 1 */\n  background-color: transparent; /* 2 */\n  background-image: none; /* 2 */\n}\n\n/*\nUse the modern Firefox focus style for all focusable elements.\n*/\n\n:-moz-focusring {\n  outline: auto;\n}\n\n/*\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n:-moz-ui-invalid {\n  box-shadow: none;\n}\n\n/*\nAdd the correct vertical alignment in Chrome and Firefox.\n*/\n\nprogress {\n  vertical-align: baseline;\n}\n\n/*\nCorrect the cursor style of increment and decrement buttons in Safari.\n*/\n\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/*\n1. Correct the odd appearance in Chrome and Safari.\n2. Correct the outline style in Safari.\n*/\n\n[type='search'] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/*\nRemove the inner padding in Chrome and Safari on macOS.\n*/\n\n::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Change font properties to `inherit` in Safari.\n*/\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/*\nAdd the correct display in Chrome and Safari.\n*/\n\nsummary {\n  display: list-item;\n}\n\n/*\nRemoves the default spacing and border for appropriate elements.\n*/\n\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nhr,\nfigure,\np,\npre {\n  margin: 0;\n}\n\nfieldset {\n  margin: 0;\n  padding: 0;\n}\n\nlegend {\n  padding: 0;\n}\n\nol,\nul,\nmenu {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n/*\nPrevent resizing textareas horizontally by default.\n*/\n\ntextarea {\n  resize: vertical;\n}\n\n/*\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n2. Set the default placeholder color to the user's configured gray 400 color.\n*/\n\ninput::placeholder,\ntextarea::placeholder {\n  opacity: 1; /* 1 */\n  color: theme('colors.gray.400', #9ca3af); /* 2 */\n}\n\n/*\nSet the default cursor for buttons.\n*/\n\nbutton,\n[role=\"button\"] {\n  cursor: pointer;\n}\n\n/*\nMake sure disabled buttons don't get the pointer cursor.\n*/\n:disabled {\n  cursor: default;\n}\n\n/*\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n   This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\nimg,\nsvg,\nvideo,\ncanvas,\naudio,\niframe,\nembed,\nobject {\n  display: block; /* 1 */\n  vertical-align: middle; /* 2 */\n}\n\n/*\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\nimg,\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n\n/* Make elements with the HTML hidden attribute stay hidden by default */\n[hidden] {\n  display: none;\n}\n";

// node_modules/@mhsdesign/jit-browser-tailwindcss/dist/module.esm.js
init_shim();
init_postcss();
var import_quick_lru = __toESM(require_quick_lru(), 1);
init_postcss();
var import_postcss_selector_parser = __toESM(require_dist(), 1);
init_postcss();
var import_postcss_nested = __toESM(require_postcss_nested(), 1);

// node_modules/postcss-js/index.mjs
init_shim();
var import_index = __toESM(require_postcss_js(), 1);
var postcss_js_default = import_index.default;
var objectify = import_index.default.objectify;
var parse5 = import_index.default.parse;
var async = import_index.default.async;
var sync = import_index.default.sync;

// node_modules/@mhsdesign/jit-browser-tailwindcss/dist/module.esm.js
var import_postcss_selector_parser2 = __toESM(require_dist(), 1);
var import_color_name = __toESM(require_color_name(), 1);
var import_postcss_selector_parser3 = __toESM(require_dist(), 1);
var import_unesc = __toESM(require_unesc(), 1);
var import_postcss_selector_parser4 = __toESM(require_dist(), 1);
init_postcss();
var import_dlv = __toESM(require_dlv_umd(), 1);
var import_postcss_selector_parser5 = __toESM(require_dist(), 1);
init_postcss();
init_postcss();
init_postcss();
var import_postcss_selector_parser6 = __toESM(require_dist(), 1);
var import_dlv2 = __toESM(require_dlv_umd(), 1);
var import_didyoumean = __toESM(require_didYouMean_1_2_1(), 1);
var import_postcss_value_parser3 = __toESM(require_lib(), 1);
init_postcss();
var import_postcss_selector_parser7 = __toESM(require_dist(), 1);
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __require2 = /* @__PURE__ */ ((x3) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x3, {
  get: (a3, b3) => (typeof __require !== "undefined" ? __require : a3)[b3]
}) : x3)(function(x3) {
  if (typeof __require !== "undefined")
    return __require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x3 + '" is not supported');
});
var __commonJS2 = (cb, mod2) => function __require22() {
  return mod2 || (0, cb[__getOwnPropNames2(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var require_config_full = __commonJS2({
  "node_modules/tailwindcss/stubs/config.full.js"(exports, module) {
    module.exports = {
      content: [],
      presets: [],
      darkMode: "media",
      theme: {
        accentColor: ({ theme }) => ({
          ...theme("colors"),
          auto: "auto"
        }),
        animation: {
          none: "none",
          spin: "spin 1s linear infinite",
          ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
          pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
          bounce: "bounce 1s infinite"
        },
        aria: {
          checked: 'checked="true"',
          disabled: 'disabled="true"',
          expanded: 'expanded="true"',
          hidden: 'hidden="true"',
          pressed: 'pressed="true"',
          readonly: 'readonly="true"',
          required: 'required="true"',
          selected: 'selected="true"'
        },
        aspectRatio: {
          auto: "auto",
          square: "1 / 1",
          video: "16 / 9"
        },
        backdropBlur: ({ theme }) => theme("blur"),
        backdropBrightness: ({ theme }) => theme("brightness"),
        backdropContrast: ({ theme }) => theme("contrast"),
        backdropGrayscale: ({ theme }) => theme("grayscale"),
        backdropHueRotate: ({ theme }) => theme("hueRotate"),
        backdropInvert: ({ theme }) => theme("invert"),
        backdropOpacity: ({ theme }) => theme("opacity"),
        backdropSaturate: ({ theme }) => theme("saturate"),
        backdropSepia: ({ theme }) => theme("sepia"),
        backgroundColor: ({ theme }) => theme("colors"),
        backgroundImage: {
          none: "none",
          "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
          "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
          "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
          "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
          "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
          "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
          "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
          "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
        },
        backgroundOpacity: ({ theme }) => theme("opacity"),
        backgroundPosition: {
          bottom: "bottom",
          center: "center",
          left: "left",
          "left-bottom": "left bottom",
          "left-top": "left top",
          right: "right",
          "right-bottom": "right bottom",
          "right-top": "right top",
          top: "top"
        },
        backgroundSize: {
          auto: "auto",
          cover: "cover",
          contain: "contain"
        },
        blur: {
          0: "0",
          none: "0",
          sm: "4px",
          DEFAULT: "8px",
          md: "12px",
          lg: "16px",
          xl: "24px",
          "2xl": "40px",
          "3xl": "64px"
        },
        borderColor: ({ theme }) => ({
          ...theme("colors"),
          DEFAULT: theme("colors.gray.200", "currentColor")
        }),
        borderOpacity: ({ theme }) => theme("opacity"),
        borderRadius: {
          none: "0px",
          sm: "0.125rem",
          DEFAULT: "0.25rem",
          md: "0.375rem",
          lg: "0.5rem",
          xl: "0.75rem",
          "2xl": "1rem",
          "3xl": "1.5rem",
          full: "9999px"
        },
        borderSpacing: ({ theme }) => ({
          ...theme("spacing")
        }),
        borderWidth: {
          DEFAULT: "1px",
          0: "0px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        boxShadow: {
          sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
          DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
          md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
          lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
          xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
          "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
          inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
          none: "none"
        },
        boxShadowColor: ({ theme }) => theme("colors"),
        brightness: {
          0: "0",
          50: ".5",
          75: ".75",
          90: ".9",
          95: ".95",
          100: "1",
          105: "1.05",
          110: "1.1",
          125: "1.25",
          150: "1.5",
          200: "2"
        },
        caretColor: ({ theme }) => theme("colors"),
        colors: ({ colors }) => ({
          inherit: colors.inherit,
          current: colors.current,
          transparent: colors.transparent,
          black: colors.black,
          white: colors.white,
          slate: colors.slate,
          gray: colors.gray,
          zinc: colors.zinc,
          neutral: colors.neutral,
          stone: colors.stone,
          red: colors.red,
          orange: colors.orange,
          amber: colors.amber,
          yellow: colors.yellow,
          lime: colors.lime,
          green: colors.green,
          emerald: colors.emerald,
          teal: colors.teal,
          cyan: colors.cyan,
          sky: colors.sky,
          blue: colors.blue,
          indigo: colors.indigo,
          violet: colors.violet,
          purple: colors.purple,
          fuchsia: colors.fuchsia,
          pink: colors.pink,
          rose: colors.rose
        }),
        columns: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          "3xs": "16rem",
          "2xs": "18rem",
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem"
        },
        container: {},
        content: {
          none: "none"
        },
        contrast: {
          0: "0",
          50: ".5",
          75: ".75",
          100: "1",
          125: "1.25",
          150: "1.5",
          200: "2"
        },
        cursor: {
          auto: "auto",
          default: "default",
          pointer: "pointer",
          wait: "wait",
          text: "text",
          move: "move",
          help: "help",
          "not-allowed": "not-allowed",
          none: "none",
          "context-menu": "context-menu",
          progress: "progress",
          cell: "cell",
          crosshair: "crosshair",
          "vertical-text": "vertical-text",
          alias: "alias",
          copy: "copy",
          "no-drop": "no-drop",
          grab: "grab",
          grabbing: "grabbing",
          "all-scroll": "all-scroll",
          "col-resize": "col-resize",
          "row-resize": "row-resize",
          "n-resize": "n-resize",
          "e-resize": "e-resize",
          "s-resize": "s-resize",
          "w-resize": "w-resize",
          "ne-resize": "ne-resize",
          "nw-resize": "nw-resize",
          "se-resize": "se-resize",
          "sw-resize": "sw-resize",
          "ew-resize": "ew-resize",
          "ns-resize": "ns-resize",
          "nesw-resize": "nesw-resize",
          "nwse-resize": "nwse-resize",
          "zoom-in": "zoom-in",
          "zoom-out": "zoom-out"
        },
        divideColor: ({ theme }) => theme("borderColor"),
        divideOpacity: ({ theme }) => theme("borderOpacity"),
        divideWidth: ({ theme }) => theme("borderWidth"),
        dropShadow: {
          sm: "0 1px 1px rgb(0 0 0 / 0.05)",
          DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
          md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
          lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
          xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
          "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
          none: "0 0 #0000"
        },
        fill: ({ theme }) => ({
          none: "none",
          ...theme("colors")
        }),
        flex: {
          1: "1 1 0%",
          auto: "1 1 auto",
          initial: "0 1 auto",
          none: "none"
        },
        flexBasis: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          "1/12": "8.333333%",
          "2/12": "16.666667%",
          "3/12": "25%",
          "4/12": "33.333333%",
          "5/12": "41.666667%",
          "6/12": "50%",
          "7/12": "58.333333%",
          "8/12": "66.666667%",
          "9/12": "75%",
          "10/12": "83.333333%",
          "11/12": "91.666667%",
          full: "100%"
        }),
        flexGrow: {
          0: "0",
          DEFAULT: "1"
        },
        flexShrink: {
          0: "0",
          DEFAULT: "1"
        },
        fontFamily: {
          sans: [
            "ui-sans-serif",
            "system-ui",
            "-apple-system",
            "BlinkMacSystemFont",
            '"Segoe UI"',
            "Roboto",
            '"Helvetica Neue"',
            "Arial",
            '"Noto Sans"',
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
          ],
          serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
          mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
          ]
        },
        fontSize: {
          xs: ["0.75rem", { lineHeight: "1rem" }],
          sm: ["0.875rem", { lineHeight: "1.25rem" }],
          base: ["1rem", { lineHeight: "1.5rem" }],
          lg: ["1.125rem", { lineHeight: "1.75rem" }],
          xl: ["1.25rem", { lineHeight: "1.75rem" }],
          "2xl": ["1.5rem", { lineHeight: "2rem" }],
          "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
          "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
          "5xl": ["3rem", { lineHeight: "1" }],
          "6xl": ["3.75rem", { lineHeight: "1" }],
          "7xl": ["4.5rem", { lineHeight: "1" }],
          "8xl": ["6rem", { lineHeight: "1" }],
          "9xl": ["8rem", { lineHeight: "1" }]
        },
        fontWeight: {
          thin: "100",
          extralight: "200",
          light: "300",
          normal: "400",
          medium: "500",
          semibold: "600",
          bold: "700",
          extrabold: "800",
          black: "900"
        },
        gap: ({ theme }) => theme("spacing"),
        gradientColorStops: ({ theme }) => theme("colors"),
        gradientColorStopPositions: {
          "0%": "0%",
          "5%": "5%",
          "10%": "10%",
          "15%": "15%",
          "20%": "20%",
          "25%": "25%",
          "30%": "30%",
          "35%": "35%",
          "40%": "40%",
          "45%": "45%",
          "50%": "50%",
          "55%": "55%",
          "60%": "60%",
          "65%": "65%",
          "70%": "70%",
          "75%": "75%",
          "80%": "80%",
          "85%": "85%",
          "90%": "90%",
          "95%": "95%",
          "100%": "100%"
        },
        grayscale: {
          0: "0",
          DEFAULT: "100%"
        },
        gridAutoColumns: {
          auto: "auto",
          min: "min-content",
          max: "max-content",
          fr: "minmax(0, 1fr)"
        },
        gridAutoRows: {
          auto: "auto",
          min: "min-content",
          max: "max-content",
          fr: "minmax(0, 1fr)"
        },
        gridColumn: {
          auto: "auto",
          "span-1": "span 1 / span 1",
          "span-2": "span 2 / span 2",
          "span-3": "span 3 / span 3",
          "span-4": "span 4 / span 4",
          "span-5": "span 5 / span 5",
          "span-6": "span 6 / span 6",
          "span-7": "span 7 / span 7",
          "span-8": "span 8 / span 8",
          "span-9": "span 9 / span 9",
          "span-10": "span 10 / span 10",
          "span-11": "span 11 / span 11",
          "span-12": "span 12 / span 12",
          "span-full": "1 / -1"
        },
        gridColumnEnd: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridColumnStart: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12",
          13: "13"
        },
        gridRow: {
          auto: "auto",
          "span-1": "span 1 / span 1",
          "span-2": "span 2 / span 2",
          "span-3": "span 3 / span 3",
          "span-4": "span 4 / span 4",
          "span-5": "span 5 / span 5",
          "span-6": "span 6 / span 6",
          "span-full": "1 / -1"
        },
        gridRowEnd: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7"
        },
        gridRowStart: {
          auto: "auto",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7"
        },
        gridTemplateColumns: {
          none: "none",
          1: "repeat(1, minmax(0, 1fr))",
          2: "repeat(2, minmax(0, 1fr))",
          3: "repeat(3, minmax(0, 1fr))",
          4: "repeat(4, minmax(0, 1fr))",
          5: "repeat(5, minmax(0, 1fr))",
          6: "repeat(6, minmax(0, 1fr))",
          7: "repeat(7, minmax(0, 1fr))",
          8: "repeat(8, minmax(0, 1fr))",
          9: "repeat(9, minmax(0, 1fr))",
          10: "repeat(10, minmax(0, 1fr))",
          11: "repeat(11, minmax(0, 1fr))",
          12: "repeat(12, minmax(0, 1fr))"
        },
        gridTemplateRows: {
          none: "none",
          1: "repeat(1, minmax(0, 1fr))",
          2: "repeat(2, minmax(0, 1fr))",
          3: "repeat(3, minmax(0, 1fr))",
          4: "repeat(4, minmax(0, 1fr))",
          5: "repeat(5, minmax(0, 1fr))",
          6: "repeat(6, minmax(0, 1fr))"
        },
        height: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        hueRotate: {
          0: "0deg",
          15: "15deg",
          30: "30deg",
          60: "60deg",
          90: "90deg",
          180: "180deg"
        },
        inset: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          full: "100%"
        }),
        invert: {
          0: "0",
          DEFAULT: "100%"
        },
        keyframes: {
          spin: {
            to: {
              transform: "rotate(360deg)"
            }
          },
          ping: {
            "75%, 100%": {
              transform: "scale(2)",
              opacity: "0"
            }
          },
          pulse: {
            "50%": {
              opacity: ".5"
            }
          },
          bounce: {
            "0%, 100%": {
              transform: "translateY(-25%)",
              animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
            },
            "50%": {
              transform: "none",
              animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
            }
          }
        },
        letterSpacing: {
          tighter: "-0.05em",
          tight: "-0.025em",
          normal: "0em",
          wide: "0.025em",
          wider: "0.05em",
          widest: "0.1em"
        },
        lineHeight: {
          none: "1",
          tight: "1.25",
          snug: "1.375",
          normal: "1.5",
          relaxed: "1.625",
          loose: "2",
          3: ".75rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem"
        },
        listStyleType: {
          none: "none",
          disc: "disc",
          decimal: "decimal"
        },
        listStyleImage: {
          none: "none"
        },
        margin: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing")
        }),
        lineClamp: {
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6"
        },
        maxHeight: ({ theme }) => ({
          ...theme("spacing"),
          none: "none",
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        maxWidth: ({ theme, breakpoints }) => ({
          none: "none",
          0: "0rem",
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem",
          full: "100%",
          min: "min-content",
          max: "max-content",
          fit: "fit-content",
          prose: "65ch",
          ...breakpoints(theme("screens"))
        }),
        minHeight: {
          0: "0px",
          full: "100%",
          screen: "100vh",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        },
        minWidth: {
          0: "0px",
          full: "100%",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        },
        objectPosition: {
          bottom: "bottom",
          center: "center",
          left: "left",
          "left-bottom": "left bottom",
          "left-top": "left top",
          right: "right",
          "right-bottom": "right bottom",
          "right-top": "right top",
          top: "top"
        },
        opacity: {
          0: "0",
          5: "0.05",
          10: "0.1",
          20: "0.2",
          25: "0.25",
          30: "0.3",
          40: "0.4",
          50: "0.5",
          60: "0.6",
          70: "0.7",
          75: "0.75",
          80: "0.8",
          90: "0.9",
          95: "0.95",
          100: "1"
        },
        order: {
          first: "-9999",
          last: "9999",
          none: "0",
          1: "1",
          2: "2",
          3: "3",
          4: "4",
          5: "5",
          6: "6",
          7: "7",
          8: "8",
          9: "9",
          10: "10",
          11: "11",
          12: "12"
        },
        outlineColor: ({ theme }) => theme("colors"),
        outlineOffset: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        outlineWidth: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        padding: ({ theme }) => theme("spacing"),
        placeholderColor: ({ theme }) => theme("colors"),
        placeholderOpacity: ({ theme }) => theme("opacity"),
        ringColor: ({ theme }) => ({
          DEFAULT: theme("colors.blue.500", "#3b82f6"),
          ...theme("colors")
        }),
        ringOffsetColor: ({ theme }) => theme("colors"),
        ringOffsetWidth: {
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        ringOpacity: ({ theme }) => ({
          DEFAULT: "0.5",
          ...theme("opacity")
        }),
        ringWidth: {
          DEFAULT: "3px",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        rotate: {
          0: "0deg",
          1: "1deg",
          2: "2deg",
          3: "3deg",
          6: "6deg",
          12: "12deg",
          45: "45deg",
          90: "90deg",
          180: "180deg"
        },
        saturate: {
          0: "0",
          50: ".5",
          100: "1",
          150: "1.5",
          200: "2"
        },
        scale: {
          0: "0",
          50: ".5",
          75: ".75",
          90: ".9",
          95: ".95",
          100: "1",
          105: "1.05",
          110: "1.1",
          125: "1.25",
          150: "1.5"
        },
        screens: {
          sm: "640px",
          md: "768px",
          lg: "1024px",
          xl: "1280px",
          "2xl": "1536px"
        },
        scrollMargin: ({ theme }) => ({
          ...theme("spacing")
        }),
        scrollPadding: ({ theme }) => theme("spacing"),
        sepia: {
          0: "0",
          DEFAULT: "100%"
        },
        skew: {
          0: "0deg",
          1: "1deg",
          2: "2deg",
          3: "3deg",
          6: "6deg",
          12: "12deg"
        },
        space: ({ theme }) => ({
          ...theme("spacing")
        }),
        spacing: {
          px: "1px",
          0: "0px",
          0.5: "0.125rem",
          1: "0.25rem",
          1.5: "0.375rem",
          2: "0.5rem",
          2.5: "0.625rem",
          3: "0.75rem",
          3.5: "0.875rem",
          4: "1rem",
          5: "1.25rem",
          6: "1.5rem",
          7: "1.75rem",
          8: "2rem",
          9: "2.25rem",
          10: "2.5rem",
          11: "2.75rem",
          12: "3rem",
          14: "3.5rem",
          16: "4rem",
          20: "5rem",
          24: "6rem",
          28: "7rem",
          32: "8rem",
          36: "9rem",
          40: "10rem",
          44: "11rem",
          48: "12rem",
          52: "13rem",
          56: "14rem",
          60: "15rem",
          64: "16rem",
          72: "18rem",
          80: "20rem",
          96: "24rem"
        },
        stroke: ({ theme }) => ({
          none: "none",
          ...theme("colors")
        }),
        strokeWidth: {
          0: "0",
          1: "1",
          2: "2"
        },
        supports: {},
        data: {},
        textColor: ({ theme }) => theme("colors"),
        textDecorationColor: ({ theme }) => theme("colors"),
        textDecorationThickness: {
          auto: "auto",
          "from-font": "from-font",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        textIndent: ({ theme }) => ({
          ...theme("spacing")
        }),
        textOpacity: ({ theme }) => theme("opacity"),
        textUnderlineOffset: {
          auto: "auto",
          0: "0px",
          1: "1px",
          2: "2px",
          4: "4px",
          8: "8px"
        },
        transformOrigin: {
          center: "center",
          top: "top",
          "top-right": "top right",
          right: "right",
          "bottom-right": "bottom right",
          bottom: "bottom",
          "bottom-left": "bottom left",
          left: "left",
          "top-left": "top left"
        },
        transitionDelay: {
          0: "0s",
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        },
        transitionDuration: {
          DEFAULT: "150ms",
          0: "0s",
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        },
        transitionProperty: {
          none: "none",
          all: "all",
          DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
          colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
          opacity: "opacity",
          shadow: "box-shadow",
          transform: "transform"
        },
        transitionTimingFunction: {
          DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
          linear: "linear",
          in: "cubic-bezier(0.4, 0, 1, 1)",
          out: "cubic-bezier(0, 0, 0.2, 1)",
          "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
        },
        translate: ({ theme }) => ({
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          full: "100%"
        }),
        width: ({ theme }) => ({
          auto: "auto",
          ...theme("spacing"),
          "1/2": "50%",
          "1/3": "33.333333%",
          "2/3": "66.666667%",
          "1/4": "25%",
          "2/4": "50%",
          "3/4": "75%",
          "1/5": "20%",
          "2/5": "40%",
          "3/5": "60%",
          "4/5": "80%",
          "1/6": "16.666667%",
          "2/6": "33.333333%",
          "3/6": "50%",
          "4/6": "66.666667%",
          "5/6": "83.333333%",
          "1/12": "8.333333%",
          "2/12": "16.666667%",
          "3/12": "25%",
          "4/12": "33.333333%",
          "5/12": "41.666667%",
          "6/12": "50%",
          "7/12": "58.333333%",
          "8/12": "66.666667%",
          "9/12": "75%",
          "10/12": "83.333333%",
          "11/12": "91.666667%",
          full: "100%",
          screen: "100vw",
          min: "min-content",
          max: "max-content",
          fit: "fit-content"
        }),
        willChange: {
          auto: "auto",
          scroll: "scroll-position",
          contents: "contents",
          transform: "transform"
        },
        zIndex: {
          auto: "auto",
          0: "0",
          10: "10",
          20: "20",
          30: "30",
          40: "40",
          50: "50"
        }
      },
      plugins: []
    };
  }
});
function log2() {
}
function dim(input) {
  return input;
}
var log_default = {
  info: log2,
  warn: log2,
  risk: log2
};
function normalizeTailwindDirectives(root2) {
  let tailwindDirectives = /* @__PURE__ */ new Set();
  let layerDirectives = /* @__PURE__ */ new Set();
  let applyDirectives = /* @__PURE__ */ new Set();
  root2.walkAtRules((atRule2) => {
    if (atRule2.name === "apply") {
      applyDirectives.add(atRule2);
    }
    if (atRule2.name === "import") {
      if (atRule2.params === '"tailwindcss/base"' || atRule2.params === "'tailwindcss/base'") {
        atRule2.name = "tailwind";
        atRule2.params = "base";
      } else if (atRule2.params === '"tailwindcss/components"' || atRule2.params === "'tailwindcss/components'") {
        atRule2.name = "tailwind";
        atRule2.params = "components";
      } else if (atRule2.params === '"tailwindcss/utilities"' || atRule2.params === "'tailwindcss/utilities'") {
        atRule2.name = "tailwind";
        atRule2.params = "utilities";
      } else if (atRule2.params === '"tailwindcss/screens"' || atRule2.params === "'tailwindcss/screens'" || atRule2.params === '"tailwindcss/variants"' || atRule2.params === "'tailwindcss/variants'") {
        atRule2.name = "tailwind";
        atRule2.params = "variants";
      }
    }
    if (atRule2.name === "tailwind") {
      if (atRule2.params === "screens") {
        atRule2.params = "variants";
      }
      tailwindDirectives.add(atRule2.params);
    }
    if (["layer", "responsive", "variants"].includes(atRule2.name)) {
      if (["responsive", "variants"].includes(atRule2.name)) {
        log_default.warn(`${atRule2.name}-at-rule-deprecated`, [
          `The \`@${atRule2.name}\` directive has been deprecated in Tailwind CSS v3.0.`,
          `Use \`@layer utilities\` or \`@layer components\` instead.`,
          "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"
        ]);
      }
      layerDirectives.add(atRule2);
    }
  });
  if (!tailwindDirectives.has("base") || !tailwindDirectives.has("components") || !tailwindDirectives.has("utilities")) {
    for (let rule2 of layerDirectives) {
      if (rule2.name === "layer" && ["base", "components", "utilities"].includes(rule2.params)) {
        if (!tailwindDirectives.has(rule2.params)) {
          throw rule2.error(
            `\`@layer ${rule2.params}\` is used but no matching \`@tailwind ${rule2.params}\` directive is present.`
          );
        }
      } else if (rule2.name === "responsive") {
        if (!tailwindDirectives.has("utilities")) {
          throw rule2.error("`@responsive` is used but `@tailwind utilities` is missing.");
        }
      } else if (rule2.name === "variants") {
        if (!tailwindDirectives.has("utilities")) {
          throw rule2.error("`@variants` is used but `@tailwind utilities` is missing.");
        }
      }
    }
  }
  return { tailwindDirectives, applyDirectives };
}
var preflight_default2 = '*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:theme("borderColor.DEFAULT",currentColor)}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:theme("fontFamily.sans",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:theme("fontFamily.sans[1].fontFeatureSettings",normal);font-variation-settings:theme("fontFamily.sans[1].fontVariationSettings",normal)}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:theme("fontFamily.mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:theme("colors.gray.400",#9ca3af)}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}\n';
var fs_default = {
  readFileSync: () => preflight_default2
};
var version = "3.3.0";
var package_default = {
  name: "tailwindcss",
  version,
  description: "A utility-first CSS framework for rapidly building custom user interfaces.",
  license: "MIT",
  main: "lib/index.js",
  types: "types/index.d.ts",
  repository: "https://github.com/tailwindlabs/tailwindcss.git",
  bugs: "https://github.com/tailwindlabs/tailwindcss/issues",
  homepage: "https://tailwindcss.com",
  bin: {
    tailwind: "lib/cli.js",
    tailwindcss: "lib/cli.js"
  },
  tailwindcss: {
    engine: "stable"
  },
  scripts: {
    prebuild: "npm run generate && rimraf lib",
    build: "swc src --out-dir lib --copy-files",
    postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false",
    "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js",
    style: "eslint .",
    pretest: "npm run generate",
    test: "jest",
    "test:integrations": "npm run test --prefix ./integrations",
    "install:integrations": "node scripts/install-integrations.js",
    "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js",
    "generate:types": "node -r @swc/register scripts/generate-types.js",
    generate: "npm run generate:plugin-list && npm run generate:types",
    "release-channel": "node ./scripts/release-channel.js",
    "release-notes": "node ./scripts/release-notes.js",
    prepublishOnly: "npm install --force && npm run build"
  },
  files: [
    "src/*",
    "cli/*",
    "lib/*",
    "peers/*",
    "scripts/*.js",
    "stubs/*",
    "nesting/*",
    "types/**/*",
    "*.d.ts",
    "*.css",
    "*.js"
  ],
  devDependencies: {
    "@swc/cli": "0.1.59",
    "@swc/core": "1.3.24",
    "@swc/jest": "0.2.24",
    "@swc/register": "0.1.10",
    autoprefixer: "^10.4.13",
    browserslist: "^4.21.4",
    concurrently: "^7.5.0",
    cssnano: "^5.1.14",
    esbuild: "^0.16.10",
    eslint: "^8.31.0",
    "eslint-config-prettier": "^8.6.0",
    "eslint-plugin-prettier": "^4.2.1",
    jest: "^28.1.3",
    "jest-diff": "^28.1.3",
    lightningcss: "^1.18.0",
    prettier: "^2.8.1",
    rimraf: "^3.0.0",
    "source-map-js": "^1.0.2",
    turbo: "^1.6.3"
  },
  peerDependencies: {
    postcss: "^8.0.9"
  },
  dependencies: {
    arg: "^5.0.2",
    chokidar: "^3.5.3",
    "color-name": "^1.1.4",
    didyoumean: "^1.2.2",
    dlv: "^1.1.3",
    "fast-glob": "^3.2.12",
    "glob-parent": "^6.0.2",
    "is-glob": "^4.0.3",
    jiti: "^1.17.2",
    lilconfig: "^2.0.6",
    micromatch: "^4.0.5",
    "normalize-path": "^3.0.0",
    "object-hash": "^3.0.0",
    picocolors: "^1.0.0",
    postcss: "^8.0.9",
    "postcss-import": "^14.1.0",
    "postcss-js": "^4.0.0",
    "postcss-load-config": "^3.1.4",
    "postcss-nested": "6.0.0",
    "postcss-selector-parser": "^6.0.11",
    "postcss-value-parser": "^4.2.0",
    "quick-lru": "^5.1.1",
    resolve: "^1.22.1",
    sucrase: "^3.29.0"
  },
  browserslist: [
    "> 1%",
    "not edge <= 18",
    "not ie 11",
    "not op_mini all"
  ],
  jest: {
    testTimeout: 3e4,
    setupFilesAfterEnv: [
      "<rootDir>/jest/customMatchers.js"
    ],
    testPathIgnorePatterns: [
      "/node_modules/",
      "/integrations/",
      "/standalone-cli/",
      "\\.test\\.skip\\.js$"
    ],
    transformIgnorePatterns: [
      "node_modules/(?!lightningcss)"
    ],
    transform: {
      "\\.js$": "@swc/jest",
      "\\.ts$": "@swc/jest"
    }
  },
  engines: {
    node: ">=12.13.0"
  }
};
var OXIDE_DEFAULT_ENABLED = package_default.tailwindcss.engine === "oxide";
var env = {
  NODE_ENV: "development",
  DEBUG: resolveDebug(void 0),
  ENGINE: package_default.tailwindcss.engine,
  OXIDE: resolveBoolean(void 0, OXIDE_DEFAULT_ENABLED)
};
var contextSourcesMap = /* @__PURE__ */ new Map();
var NOT_ON_DEMAND = new String("*");
var NONE = Symbol("__NONE__");
function resolveBoolean(value2, defaultValue) {
  if (value2 === void 0) {
    return defaultValue;
  }
  if (value2 === "0" || value2 === "false") {
    return false;
  }
  return true;
}
function resolveDebug(debug) {
  if (debug === void 0) {
    return false;
  }
  if (debug === "true" || debug === "1") {
    return true;
  }
  if (debug === "false" || debug === "0") {
    return false;
  }
  if (debug === "*") {
    return true;
  }
  let debuggers = debug.split(",").map((d3) => d3.split(":")[0]);
  if (debuggers.includes("-tailwindcss")) {
    return false;
  }
  if (debuggers.includes("tailwindcss")) {
    return true;
  }
  return false;
}
function parseObjectStyles(styles) {
  if (!Array.isArray(styles)) {
    return parseObjectStyles([styles]);
  }
  return styles.flatMap((style) => {
    return postcss_default([
      (0, import_postcss_nested.default)({
        bubble: ["screen"]
      })
    ]).process(style, {
      parser: postcss_js_default
    }).root.nodes;
  });
}
function isPlainObject(value2) {
  if (Object.prototype.toString.call(value2) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value2);
  return prototype === null || prototype === Object.prototype;
}
function prefixSelector_default(prefix3, selector, prependNegative = false) {
  if (prefix3 === "") {
    return selector;
  }
  let ast = typeof selector === "string" ? (0, import_postcss_selector_parser2.default)().astSync(selector) : selector;
  ast.walkClasses((classSelector) => {
    let baseClass = classSelector.value;
    let shouldPlaceNegativeBeforePrefix = prependNegative && baseClass.startsWith("-");
    classSelector.value = shouldPlaceNegativeBeforePrefix ? `-${prefix3}${baseClass.slice(1)}` : `${prefix3}${baseClass}`;
  });
  return typeof selector === "string" ? ast.toString() : ast;
}
function escapeCommas(className) {
  return className.replace(/\\,/g, "\\2c ");
}
var HEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
var SHORT_HEX = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
var VALUE = /(?:\d+|\d*\.\d+)%?/;
var SEP = /(?:\s*,\s*|\s+)/;
var ALPHA_SEP = /\s*[,/]\s*/;
var CUSTOM_PROPERTY = /var\(--(?:[^ )]*?)\)/;
var RGB = new RegExp(
  `^(rgba?)\\(\\s*(${VALUE.source}|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`
);
var HSL = new RegExp(
  `^(hsla?)\\(\\s*((?:${VALUE.source})(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`
);
function parseColor(value2, { loose = false } = {}) {
  if (typeof value2 !== "string") {
    return null;
  }
  value2 = value2.trim();
  if (value2 === "transparent") {
    return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
  }
  if (value2 in import_color_name.default) {
    return { mode: "rgb", color: import_color_name.default[value2].map((v2) => v2.toString()) };
  }
  let hex2 = value2.replace(SHORT_HEX, (_3, r5, g3, b3, a3) => ["#", r5, r5, g3, g3, b3, b3, a3 ? a3 + a3 : ""].join("")).match(HEX);
  if (hex2 !== null) {
    return {
      mode: "rgb",
      color: [parseInt(hex2[1], 16), parseInt(hex2[2], 16), parseInt(hex2[3], 16)].map(
        (v2) => v2.toString()
      ),
      alpha: hex2[4] ? (parseInt(hex2[4], 16) / 255).toString() : void 0
    };
  }
  let match = value2.match(RGB) ?? value2.match(HSL);
  if (match === null) {
    return null;
  }
  let color22 = [match[2], match[3], match[4]].filter(Boolean).map((v2) => v2.toString());
  if (color22.length === 2 && color22[0].startsWith("var(")) {
    return {
      mode: match[1],
      color: [color22[0]],
      alpha: color22[1]
    };
  }
  if (!loose && color22.length !== 3) {
    return null;
  }
  if (color22.length < 3 && !color22.some((part) => /^var\(.*?\)$/.test(part))) {
    return null;
  }
  return {
    mode: match[1],
    color: color22,
    alpha: match[5]?.toString?.()
  };
}
function formatColor({ mode, color: color22, alpha }) {
  let hasAlpha = alpha !== void 0;
  if (mode === "rgba" || mode === "hsla") {
    return `${mode}(${color22.join(", ")}${hasAlpha ? `, ${alpha}` : ""})`;
  }
  return `${mode}(${color22.join(" ")}${hasAlpha ? ` / ${alpha}` : ""})`;
}
function withAlphaValue(color22, alphaValue, defaultValue) {
  if (typeof color22 === "function") {
    return color22({ opacityValue: alphaValue });
  }
  let parsed = parseColor(color22, { loose: true });
  if (parsed === null) {
    return defaultValue;
  }
  return formatColor({ ...parsed, alpha: alphaValue });
}
function withAlphaVariable({ color: color22, property, variable }) {
  let properties = [].concat(property);
  if (typeof color22 === "function") {
    return {
      [variable]: "1",
      ...Object.fromEntries(
        properties.map((p3) => {
          return [p3, color22({ opacityVariable: variable, opacityValue: `var(${variable})` })];
        })
      )
    };
  }
  const parsed = parseColor(color22);
  if (parsed === null) {
    return Object.fromEntries(properties.map((p3) => [p3, color22]));
  }
  if (parsed.alpha !== void 0) {
    return Object.fromEntries(properties.map((p3) => [p3, color22]));
  }
  return {
    [variable]: "1",
    ...Object.fromEntries(
      properties.map((p3) => {
        return [p3, formatColor({ ...parsed, alpha: `var(${variable})` })];
      })
    )
  };
}
function splitAtTopLevelOnly(input, separator) {
  let stack = [];
  let parts = [];
  let lastPos = 0;
  let isEscaped = false;
  for (let idx = 0; idx < input.length; idx++) {
    let char = input[idx];
    if (stack.length === 0 && char === separator[0] && !isEscaped) {
      if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
        parts.push(input.slice(lastPos, idx));
        lastPos = idx + separator.length;
      }
    }
    if (isEscaped) {
      isEscaped = false;
    } else if (char === "\\") {
      isEscaped = true;
    }
    if (char === "(" || char === "[" || char === "{") {
      stack.push(char);
    } else if (char === ")" && stack[stack.length - 1] === "(" || char === "]" && stack[stack.length - 1] === "[" || char === "}" && stack[stack.length - 1] === "{") {
      stack.pop();
    }
  }
  parts.push(input.slice(lastPos));
  return parts;
}
var KEYWORDS = /* @__PURE__ */ new Set(["inset", "inherit", "initial", "revert", "unset"]);
var SPACE = /\ +(?![^(]*\))/g;
var LENGTH = /^-?(\d+|\.\d+)(.*?)$/g;
function parseBoxShadowValue(input) {
  let shadows = splitAtTopLevelOnly(input, ",");
  return shadows.map((shadow2) => {
    let value2 = shadow2.trim();
    let result = { raw: value2 };
    let parts = value2.split(SPACE);
    let seen = /* @__PURE__ */ new Set();
    for (let part of parts) {
      LENGTH.lastIndex = 0;
      if (!seen.has("KEYWORD") && KEYWORDS.has(part)) {
        result.keyword = part;
        seen.add("KEYWORD");
      } else if (LENGTH.test(part)) {
        if (!seen.has("X")) {
          result.x = part;
          seen.add("X");
        } else if (!seen.has("Y")) {
          result.y = part;
          seen.add("Y");
        } else if (!seen.has("BLUR")) {
          result.blur = part;
          seen.add("BLUR");
        } else if (!seen.has("SPREAD")) {
          result.spread = part;
          seen.add("SPREAD");
        }
      } else {
        if (!result.color) {
          result.color = part;
        } else {
          if (!result.unknown)
            result.unknown = [];
          result.unknown.push(part);
        }
      }
    }
    result.valid = result.x !== void 0 && result.y !== void 0;
    return result;
  });
}
function formatBoxShadowValue(shadows) {
  return shadows.map((shadow2) => {
    if (!shadow2.valid) {
      return shadow2.raw;
    }
    return [shadow2.keyword, shadow2.x, shadow2.y, shadow2.blur, shadow2.spread, shadow2.color].filter(Boolean).join(" ");
  }).join(", ");
}
var cssFunctions = ["min", "max", "clamp", "calc"];
function isCSSFunction(value2) {
  return cssFunctions.some((fn) => new RegExp(`^${fn}\\(.*\\)`).test(value2));
}
var placeholder = "--tw-placeholder";
var placeholderRe = new RegExp(placeholder, "g");
function normalize2(value2, isRoot2 = true) {
  if (value2.startsWith("--")) {
    return `var(${value2})`;
  }
  if (value2.includes("url(")) {
    return value2.split(/(url\(.*?\))/g).filter(Boolean).map((part) => {
      if (/^url\(.*?\)$/.test(part)) {
        return part;
      }
      return normalize2(part, false);
    }).join("");
  }
  value2 = value2.replace(
    /([^\\])_+/g,
    (fullMatch, characterBefore) => characterBefore + " ".repeat(fullMatch.length - 1)
  ).replace(/^_/g, " ").replace(/\\_/g, "_");
  if (isRoot2) {
    value2 = value2.trim();
  }
  value2 = value2.replace(/(calc|min|max|clamp)\(.+\)/g, (match) => {
    let vars = [];
    return match.replace(/var\((--.+?)[,)]/g, (match2, g1) => {
      vars.push(g1);
      return match2.replace(g1, placeholder);
    }).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(placeholderRe, () => vars.shift());
  });
  return value2;
}
function url(value2) {
  return value2.startsWith("url(");
}
function number(value2) {
  return !isNaN(Number(value2)) || isCSSFunction(value2);
}
function percentage(value2) {
  return value2.endsWith("%") && number(value2.slice(0, -1)) || isCSSFunction(value2);
}
var lengthUnits = [
  "cm",
  "mm",
  "Q",
  "in",
  "pc",
  "pt",
  "px",
  "em",
  "ex",
  "ch",
  "rem",
  "lh",
  "rlh",
  "vw",
  "vh",
  "vmin",
  "vmax",
  "vb",
  "vi",
  "svw",
  "svh",
  "lvw",
  "lvh",
  "dvw",
  "dvh",
  "cqw",
  "cqh",
  "cqi",
  "cqb",
  "cqmin",
  "cqmax"
];
var lengthUnitsPattern = `(?:${lengthUnits.join("|")})`;
function length(value2) {
  return value2 === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`).test(value2) || isCSSFunction(value2);
}
var lineWidths = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
function lineWidth(value2) {
  return lineWidths.has(value2);
}
function shadow(value2) {
  let parsedShadows = parseBoxShadowValue(normalize2(value2));
  for (let parsedShadow of parsedShadows) {
    if (!parsedShadow.valid) {
      return false;
    }
  }
  return true;
}
function color2(value2) {
  let colors = 0;
  let result = splitAtTopLevelOnly(value2, "_").every((part) => {
    part = normalize2(part);
    if (part.startsWith("var("))
      return true;
    if (parseColor(part, { loose: true }) !== null)
      return colors++, true;
    return false;
  });
  if (!result)
    return false;
  return colors > 0;
}
function image(value2) {
  let images = 0;
  let result = splitAtTopLevelOnly(value2, ",").every((part) => {
    part = normalize2(part);
    if (part.startsWith("var("))
      return true;
    if (url(part) || gradient(part) || ["element(", "image(", "cross-fade(", "image-set("].some((fn) => part.startsWith(fn))) {
      images++;
      return true;
    }
    return false;
  });
  if (!result)
    return false;
  return images > 0;
}
var gradientTypes = /* @__PURE__ */ new Set([
  "linear-gradient",
  "radial-gradient",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "conic-gradient"
]);
function gradient(value2) {
  value2 = normalize2(value2);
  for (let type of gradientTypes) {
    if (value2.startsWith(`${type}(`)) {
      return true;
    }
  }
  return false;
}
var validPositions = /* @__PURE__ */ new Set(["center", "top", "right", "bottom", "left"]);
function position(value2) {
  let positions = 0;
  let result = splitAtTopLevelOnly(value2, "_").every((part) => {
    part = normalize2(part);
    if (part.startsWith("var("))
      return true;
    if (validPositions.has(part) || length(part) || percentage(part)) {
      positions++;
      return true;
    }
    return false;
  });
  if (!result)
    return false;
  return positions > 0;
}
function familyName(value2) {
  let fonts = 0;
  let result = splitAtTopLevelOnly(value2, ",").every((part) => {
    part = normalize2(part);
    if (part.startsWith("var("))
      return true;
    if (part.includes(" ")) {
      if (!/(['"])([^"']+)\1/g.test(part)) {
        return false;
      }
    }
    if (/^\d/g.test(part)) {
      return false;
    }
    fonts++;
    return true;
  });
  if (!result)
    return false;
  return fonts > 0;
}
var genericNames = /* @__PURE__ */ new Set([
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui",
  "ui-serif",
  "ui-sans-serif",
  "ui-monospace",
  "ui-rounded",
  "math",
  "emoji",
  "fangsong"
]);
function genericName(value2) {
  return genericNames.has(value2);
}
var absoluteSizes = /* @__PURE__ */ new Set([
  "xx-small",
  "x-small",
  "small",
  "medium",
  "large",
  "x-large",
  "x-large",
  "xxx-large"
]);
function absoluteSize(value2) {
  return absoluteSizes.has(value2);
}
var relativeSizes = /* @__PURE__ */ new Set(["larger", "smaller"]);
function relativeSize(value2) {
  return relativeSizes.has(value2);
}
function negateValue(value2) {
  value2 = `${value2}`;
  if (value2 === "0") {
    return "0";
  }
  if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(value2)) {
    return value2.replace(/^[+-]?/, (sign2) => sign2 === "-" ? "" : "-");
  }
  let numericFunctions = ["var", "calc", "min", "max", "clamp"];
  for (const fn of numericFunctions) {
    if (value2.includes(`${fn}(`)) {
      return `calc(${value2} * -1)`;
    }
  }
}
function backgroundSize(value2) {
  let keywordValues = ["cover", "contain"];
  return splitAtTopLevelOnly(value2, ",").every((part) => {
    let sizes = splitAtTopLevelOnly(part, "_").filter(Boolean);
    if (sizes.length === 1 && keywordValues.includes(sizes[0]))
      return true;
    if (sizes.length !== 1 && sizes.length !== 2)
      return false;
    return sizes.every((size) => length(size) || percentage(size) || size === "auto");
  });
}
var picocolors_default = {
  yellow: (input) => input
};
var defaults = {
  optimizeUniversalDefaults: false,
  generalizedModifiers: true,
  get disableColorOpacityUtilitiesByDefault() {
    return env.OXIDE;
  },
  get relativeContentPathsByDefault() {
    return env.OXIDE;
  }
};
var featureFlags = {
  future: [
    "hoverOnlyWhenSupported",
    "respectDefaultRingColorOpacity",
    "disableColorOpacityUtilitiesByDefault",
    "relativeContentPathsByDefault"
  ],
  experimental: [
    "optimizeUniversalDefaults",
    "generalizedModifiers"
  ]
};
function flagEnabled(config, flag) {
  if (featureFlags.future.includes(flag)) {
    return config.future === "all" || (config?.future?.[flag] ?? defaults[flag] ?? false);
  }
  if (featureFlags.experimental.includes(flag)) {
    return config.experimental === "all" || (config?.experimental?.[flag] ?? defaults[flag] ?? false);
  }
  return false;
}
function experimentalFlagsEnabled(config) {
  if (config.experimental === "all") {
    return featureFlags.experimental;
  }
  return Object.keys(config?.experimental ?? {}).filter(
    (flag) => featureFlags.experimental.includes(flag) && config.experimental[flag]
  );
}
function issueFlagNotices(config) {
  if (true) {
    return;
  }
  if (experimentalFlagsEnabled(config).length > 0) {
    let changes = experimentalFlagsEnabled(config).map((s2) => picocolors_default.yellow(s2)).join(", ");
    log_default.warn("experimental-flags-enabled", [
      `You have enabled experimental features: ${changes}`,
      "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
    ]);
  }
}
function updateAllClasses(selectors, updateClass) {
  selectors.walkClasses((sel) => {
    sel.value = updateClass(sel.value);
    if (sel.raws && sel.raws.value) {
      sel.raws.value = escapeCommas(sel.raws.value);
    }
  });
}
function resolveArbitraryValue(modifier, validate) {
  if (!isArbitraryValue(modifier)) {
    return void 0;
  }
  let value2 = modifier.slice(1, -1);
  if (!validate(value2)) {
    return void 0;
  }
  return normalize2(value2);
}
function asNegativeValue(modifier, lookup = {}, validate) {
  let positiveValue = lookup[modifier];
  if (positiveValue !== void 0) {
    return negateValue(positiveValue);
  }
  if (isArbitraryValue(modifier)) {
    let resolved = resolveArbitraryValue(modifier, validate);
    if (resolved === void 0) {
      return void 0;
    }
    return negateValue(resolved);
  }
}
function asValue(modifier, options = {}, { validate = () => true } = {}) {
  let value2 = options.values?.[modifier];
  if (value2 !== void 0) {
    return value2;
  }
  if (options.supportsNegativeValues && modifier.startsWith("-")) {
    return asNegativeValue(modifier.slice(1), options.values, validate);
  }
  return resolveArbitraryValue(modifier, validate);
}
function isArbitraryValue(input) {
  return input.startsWith("[") && input.endsWith("]");
}
function splitUtilityModifier(modifier) {
  let slashIdx = modifier.lastIndexOf("/");
  if (slashIdx === -1 || slashIdx === modifier.length - 1) {
    return [modifier, void 0];
  }
  let arbitrary = isArbitraryValue(modifier);
  if (arbitrary && !modifier.includes("]/[")) {
    return [modifier, void 0];
  }
  return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)];
}
function parseColorFormat(value2) {
  if (typeof value2 === "string" && value2.includes("<alpha-value>")) {
    let oldValue = value2;
    return ({ opacityValue = 1 }) => oldValue.replace("<alpha-value>", opacityValue);
  }
  return value2;
}
function unwrapArbitraryModifier(modifier) {
  modifier = modifier.slice(1, -1);
  if (modifier.startsWith("--")) {
    modifier = `var(${modifier})`;
  }
  return modifier;
}
function asColor(modifier, options = {}, { tailwindConfig = {} } = {}) {
  if (options.values?.[modifier] !== void 0) {
    return parseColorFormat(options.values?.[modifier]);
  }
  let [color22, alpha] = splitUtilityModifier(modifier);
  if (alpha !== void 0) {
    let normalizedColor = options.values?.[color22] ?? (isArbitraryValue(color22) ? color22.slice(1, -1) : void 0);
    if (normalizedColor === void 0) {
      return void 0;
    }
    normalizedColor = parseColorFormat(normalizedColor);
    if (isArbitraryValue(alpha)) {
      return withAlphaValue(normalizedColor, unwrapArbitraryModifier(alpha));
    }
    if (tailwindConfig.theme?.opacity?.[alpha] === void 0) {
      return void 0;
    }
    return withAlphaValue(normalizedColor, tailwindConfig.theme.opacity[alpha]);
  }
  return asValue(modifier, options, { validate: color2 });
}
function asLookupValue(modifier, options = {}) {
  return options.values?.[modifier];
}
function guess(validate) {
  return (modifier, options) => {
    return asValue(modifier, options, { validate });
  };
}
var typeMap = {
  any: asValue,
  color: asColor,
  url: guess(url),
  image: guess(image),
  length: guess(length),
  percentage: guess(percentage),
  position: guess(position),
  lookup: asLookupValue,
  "generic-name": guess(genericName),
  "family-name": guess(familyName),
  number: guess(number),
  "line-width": guess(lineWidth),
  "absolute-size": guess(absoluteSize),
  "relative-size": guess(relativeSize),
  shadow: guess(shadow),
  size: guess(backgroundSize)
};
var supportedTypes = Object.keys(typeMap);
function splitAtFirst(input, delim) {
  let idx = input.indexOf(delim);
  if (idx === -1)
    return [void 0, input];
  return [input.slice(0, idx), input.slice(idx + 1)];
}
function coerceValue(types2, modifier, options, tailwindConfig) {
  if (options.values && modifier in options.values) {
    for (let { type } of types2 ?? []) {
      let result = typeMap[type](modifier, options, {
        tailwindConfig
      });
      if (result === void 0) {
        continue;
      }
      return [result, type, null];
    }
  }
  if (isArbitraryValue(modifier)) {
    let arbitraryValue = modifier.slice(1, -1);
    let [explicitType, value2] = splitAtFirst(arbitraryValue, ":");
    if (!/^[\w-_]+$/g.test(explicitType)) {
      value2 = arbitraryValue;
    } else if (explicitType !== void 0 && !supportedTypes.includes(explicitType)) {
      return [];
    }
    if (value2.length > 0 && supportedTypes.includes(explicitType)) {
      return [asValue(`[${value2}]`, options), explicitType, null];
    }
  }
  let matches2 = getMatchingTypes(types2, modifier, options, tailwindConfig);
  for (let match of matches2) {
    return match;
  }
  return [];
}
function* getMatchingTypes(types2, rawModifier, options, tailwindConfig) {
  let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
  let [modifier, utilityModifier] = splitUtilityModifier(rawModifier);
  let canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === "any" || typeof options.modifiers === "object" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));
  if (!canUseUtilityModifier) {
    modifier = rawModifier;
    utilityModifier = void 0;
  }
  if (utilityModifier !== void 0 && modifier === "") {
    modifier = "DEFAULT";
  }
  if (utilityModifier !== void 0) {
    if (typeof options.modifiers === "object") {
      let configValue = options.modifiers?.[utilityModifier] ?? null;
      if (configValue !== null) {
        utilityModifier = configValue;
      } else if (isArbitraryValue(utilityModifier)) {
        utilityModifier = unwrapArbitraryModifier(utilityModifier);
      }
    }
  }
  for (let { type } of types2 ?? []) {
    let result = typeMap[type](modifier, options, {
      tailwindConfig
    });
    if (result === void 0) {
      continue;
    }
    yield [result, type, utilityModifier ?? null];
  }
}
function escapeClassName(className) {
  let node = import_postcss_selector_parser4.default.className();
  node.value = className;
  return escapeCommas(node?.raws?.value ?? node.value);
}
var MERGE = ":merge";
function formatVariantSelector(formats, { context, candidate }) {
  let prefix3 = context?.tailwindConfig.prefix ?? "";
  let parsedFormats = formats.map((format2) => {
    let ast = (0, import_postcss_selector_parser3.default)().astSync(format2.format);
    return {
      ...format2,
      ast: format2.isArbitraryVariant ? ast : prefixSelector_default(prefix3, ast)
    };
  });
  let formatAst = import_postcss_selector_parser3.default.root({
    nodes: [
      import_postcss_selector_parser3.default.selector({
        nodes: [import_postcss_selector_parser3.default.className({ value: escapeClassName(candidate) })]
      })
    ]
  });
  for (let { ast } of parsedFormats) {
    ;
    [formatAst, ast] = handleMergePseudo(formatAst, ast);
    ast.walkNesting((nesting) => nesting.replaceWith(...formatAst.nodes[0].nodes));
    formatAst = ast;
  }
  return formatAst;
}
function simpleSelectorForNode(node) {
  let nodes = [];
  while (node.prev() && node.prev().type !== "combinator") {
    node = node.prev();
  }
  while (node && node.type !== "combinator") {
    nodes.push(node);
    node = node.next();
  }
  return nodes;
}
function resortSelector(sel) {
  sel.sort((a3, b3) => {
    if (a3.type === "tag" && b3.type === "class") {
      return -1;
    } else if (a3.type === "class" && b3.type === "tag") {
      return 1;
    } else if (a3.type === "class" && b3.type === "pseudo" && b3.value.startsWith("::")) {
      return -1;
    } else if (a3.type === "pseudo" && a3.value.startsWith("::") && b3.type === "class") {
      return 1;
    }
    return sel.index(a3) - sel.index(b3);
  });
  return sel;
}
function eliminateIrrelevantSelectors(sel, base) {
  let hasClassesMatchingCandidate = false;
  sel.walk((child) => {
    if (child.type === "class" && child.value === base) {
      hasClassesMatchingCandidate = true;
      return false;
    }
  });
  if (!hasClassesMatchingCandidate) {
    sel.remove();
  }
}
function finalizeSelector(current, formats, { context, candidate, base }) {
  let separator = context?.tailwindConfig?.separator ?? ":";
  base = base ?? candidate.split(new RegExp(`\\${separator}(?![^[]*\\])`)).pop();
  let selector = (0, import_postcss_selector_parser3.default)().astSync(current);
  selector.walkClasses((node) => {
    if (node.raws && node.value.includes(base)) {
      node.raws.value = escapeClassName((0, import_unesc.default)(node.raws.value));
    }
  });
  selector.each((sel) => eliminateIrrelevantSelectors(sel, base));
  let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, { context, candidate }) : formats;
  if (formatAst === null) {
    return selector.toString();
  }
  let simpleStart = import_postcss_selector_parser3.default.comment({ value: "/*__simple__*/" });
  let simpleEnd = import_postcss_selector_parser3.default.comment({ value: "/*__simple__*/" });
  selector.walkClasses((node) => {
    if (node.value !== base) {
      return;
    }
    let parent = node.parent;
    let formatNodes = formatAst.nodes[0].nodes;
    if (parent.nodes.length === 1) {
      node.replaceWith(...formatNodes);
      return;
    }
    let simpleSelector = simpleSelectorForNode(node);
    parent.insertBefore(simpleSelector[0], simpleStart);
    parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);
    for (let child of formatNodes) {
      parent.insertBefore(simpleSelector[0], child.clone());
    }
    node.remove();
    simpleSelector = simpleSelectorForNode(simpleStart);
    let firstNode = parent.index(simpleStart);
    parent.nodes.splice(
      firstNode,
      simpleSelector.length,
      ...resortSelector(import_postcss_selector_parser3.default.selector({ nodes: simpleSelector })).nodes
    );
    simpleStart.remove();
    simpleEnd.remove();
  });
  selector.walkPseudos((p3) => {
    if (p3.value === MERGE) {
      p3.replaceWith(p3.nodes);
    }
  });
  selector.each((sel) => {
    let pseudoElements = collectPseudoElements(sel);
    if (pseudoElements.length > 0) {
      sel.nodes.push(pseudoElements.sort(sortSelector));
    }
  });
  return selector.toString();
}
function handleMergePseudo(selector, format2) {
  let merges = [];
  selector.walkPseudos((pseudo) => {
    if (pseudo.value === MERGE) {
      merges.push({
        pseudo,
        value: pseudo.nodes[0].toString()
      });
    }
  });
  format2.walkPseudos((pseudo) => {
    if (pseudo.value !== MERGE) {
      return;
    }
    let value2 = pseudo.nodes[0].toString();
    let existing = merges.find((merge) => merge.value === value2);
    if (!existing) {
      return;
    }
    let attachments = [];
    let next = pseudo.next();
    while (next && next.type !== "combinator") {
      attachments.push(next);
      next = next.next();
    }
    let combinator = next;
    existing.pseudo.parent.insertAfter(
      existing.pseudo,
      import_postcss_selector_parser3.default.selector({ nodes: attachments.map((node) => node.clone()) })
    );
    pseudo.remove();
    attachments.forEach((node) => node.remove());
    if (combinator && combinator.type === "combinator") {
      combinator.remove();
    }
  });
  return [selector, format2];
}
var pseudoElementsBC = [":before", ":after", ":first-line", ":first-letter"];
var pseudoElementExceptions = [
  "::file-selector-button",
  "::-webkit-scrollbar",
  "::-webkit-scrollbar-button",
  "::-webkit-scrollbar-thumb",
  "::-webkit-scrollbar-track",
  "::-webkit-scrollbar-track-piece",
  "::-webkit-scrollbar-corner",
  "::-webkit-resizer"
];
function collectPseudoElements(selector) {
  let nodes = [];
  for (let node of selector.nodes) {
    if (isPseudoElement(node)) {
      nodes.push(node);
      selector.removeChild(node);
    }
    if (node?.nodes) {
      nodes.push(...collectPseudoElements(node));
    }
  }
  return nodes;
}
function sortSelector(a3, z3) {
  if (a3.type !== "pseudo" && z3.type !== "pseudo") {
    return 0;
  }
  if (a3.type === "combinator" ^ z3.type === "combinator") {
    return 0;
  }
  if (a3.type === "pseudo" ^ z3.type === "pseudo") {
    return (a3.type === "pseudo") - (z3.type === "pseudo");
  }
  return isPseudoElement(a3) - isPseudoElement(z3);
}
function isPseudoElement(node) {
  if (node.type !== "pseudo")
    return false;
  if (pseudoElementExceptions.includes(node.value))
    return false;
  return node.value.startsWith("::") || pseudoElementsBC.includes(node.value);
}
function asClass(name) {
  return escapeCommas(`.${escapeClassName(name)}`);
}
function nameClass(classPrefix, key) {
  return asClass(formatClass(classPrefix, key));
}
function formatClass(classPrefix, key) {
  if (key === "DEFAULT") {
    return classPrefix;
  }
  if (key === "-" || key === "-DEFAULT") {
    return `-${classPrefix}`;
  }
  if (key.startsWith("-")) {
    return `-${classPrefix}${key}`;
  }
  if (key.startsWith("/")) {
    return `${classPrefix}${key}`;
  }
  return `${classPrefix}-${key}`;
}
function transformThemeValue(themeSection) {
  if (["fontSize", "outline"].includes(themeSection)) {
    return (value2) => {
      if (typeof value2 === "function")
        value2 = value2({});
      if (Array.isArray(value2))
        value2 = value2[0];
      return value2;
    };
  }
  if (themeSection === "fontFamily") {
    return (value2) => {
      if (typeof value2 === "function")
        value2 = value2({});
      let families = Array.isArray(value2) && isPlainObject(value2[1]) ? value2[0] : value2;
      return Array.isArray(families) ? families.join(", ") : families;
    };
  }
  if ([
    "boxShadow",
    "transitionProperty",
    "transitionDuration",
    "transitionDelay",
    "transitionTimingFunction",
    "backgroundImage",
    "backgroundSize",
    "backgroundColor",
    "cursor",
    "animation"
  ].includes(themeSection)) {
    return (value2) => {
      if (typeof value2 === "function")
        value2 = value2({});
      if (Array.isArray(value2))
        value2 = value2.join(", ");
      return value2;
    };
  }
  if (["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(themeSection)) {
    return (value2) => {
      if (typeof value2 === "function")
        value2 = value2({});
      if (typeof value2 === "string")
        value2 = postcss_default.list.comma(value2).join(" ");
      return value2;
    };
  }
  return (value2, opts = {}) => {
    if (typeof value2 === "function") {
      value2 = value2(opts);
    }
    return value2;
  };
}
var join = () => "";
function createUtilityPlugin(themeKey, utilityVariations = [[themeKey, [themeKey]]], { filterDefault = false, ...options } = {}) {
  let transformValue = transformThemeValue(themeKey);
  return function({ matchUtilities, theme }) {
    for (let utilityVariation of utilityVariations) {
      let group = Array.isArray(utilityVariation[0]) ? utilityVariation : [utilityVariation];
      matchUtilities(
        group.reduce((obj, [classPrefix, properties]) => {
          return Object.assign(obj, {
            [classPrefix]: (value2) => {
              return properties.reduce((obj2, name) => {
                if (Array.isArray(name)) {
                  return Object.assign(obj2, { [name[0]]: name[1] });
                }
                return Object.assign(obj2, { [name]: transformValue(value2) });
              }, {});
            }
          });
        }, {}),
        {
          ...options,
          values: filterDefault ? Object.fromEntries(
            Object.entries(theme(themeKey) ?? {}).filter(([modifier]) => modifier !== "DEFAULT")
          ) : theme(themeKey)
        }
      );
    }
  };
}
function buildMediaQuery(screens) {
  screens = Array.isArray(screens) ? screens : [screens];
  return screens.map((screen) => {
    let values = screen.values.map((screen2) => {
      if (screen2.raw !== void 0) {
        return screen2.raw;
      }
      return [
        screen2.min && `(min-width: ${screen2.min})`,
        screen2.max && `(max-width: ${screen2.max})`
      ].filter(Boolean).join(" and ");
    });
    return screen.not ? `not all and ${values}` : values;
  }).join(", ");
}
var DIRECTIONS = /* @__PURE__ */ new Set(["normal", "reverse", "alternate", "alternate-reverse"]);
var PLAY_STATES = /* @__PURE__ */ new Set(["running", "paused"]);
var FILL_MODES = /* @__PURE__ */ new Set(["none", "forwards", "backwards", "both"]);
var ITERATION_COUNTS = /* @__PURE__ */ new Set(["infinite"]);
var TIMINGS = /* @__PURE__ */ new Set([
  "linear",
  "ease",
  "ease-in",
  "ease-out",
  "ease-in-out",
  "step-start",
  "step-end"
]);
var TIMING_FNS = ["cubic-bezier", "steps"];
var COMMA = /\,(?![^(]*\))/g;
var SPACE2 = /\ +(?![^(]*\))/g;
var TIME = /^(-?[\d.]+m?s)$/;
var DIGIT = /^(\d+)$/;
function parseAnimationValue(input) {
  let animations = input.split(COMMA);
  return animations.map((animation) => {
    let value2 = animation.trim();
    let result = { value: value2 };
    let parts = value2.split(SPACE2);
    let seen = /* @__PURE__ */ new Set();
    for (let part of parts) {
      if (!seen.has("DIRECTIONS") && DIRECTIONS.has(part)) {
        result.direction = part;
        seen.add("DIRECTIONS");
      } else if (!seen.has("PLAY_STATES") && PLAY_STATES.has(part)) {
        result.playState = part;
        seen.add("PLAY_STATES");
      } else if (!seen.has("FILL_MODES") && FILL_MODES.has(part)) {
        result.fillMode = part;
        seen.add("FILL_MODES");
      } else if (!seen.has("ITERATION_COUNTS") && (ITERATION_COUNTS.has(part) || DIGIT.test(part))) {
        result.iterationCount = part;
        seen.add("ITERATION_COUNTS");
      } else if (!seen.has("TIMING_FUNCTION") && TIMINGS.has(part)) {
        result.timingFunction = part;
        seen.add("TIMING_FUNCTION");
      } else if (!seen.has("TIMING_FUNCTION") && TIMING_FNS.some((f2) => part.startsWith(`${f2}(`))) {
        result.timingFunction = part;
        seen.add("TIMING_FUNCTION");
      } else if (!seen.has("DURATION") && TIME.test(part)) {
        result.duration = part;
        seen.add("DURATION");
      } else if (!seen.has("DELAY") && TIME.test(part)) {
        result.delay = part;
        seen.add("DELAY");
      } else if (!seen.has("NAME")) {
        result.name = part;
        seen.add("NAME");
      } else {
        if (!result.unknown)
          result.unknown = [];
        result.unknown.push(part);
      }
    }
    return result;
  });
}
var flattenColorPalette = (colors) => Object.assign(
  {},
  ...Object.entries(colors ?? {}).flatMap(
    ([color22, values]) => typeof values == "object" ? Object.entries(flattenColorPalette(values)).map(([number2, hex2]) => ({
      [color22 + (number2 === "DEFAULT" ? "" : `-${number2}`)]: hex2
    })) : [{ [`${color22}`]: values }]
  )
);
var flattenColorPalette_default = flattenColorPalette;
function toColorValue(maybeFunction) {
  return typeof maybeFunction === "function" ? maybeFunction({}) : maybeFunction;
}
function normalizeScreens(screens, root2 = true) {
  if (Array.isArray(screens)) {
    return screens.map((screen) => {
      if (root2 && Array.isArray(screen)) {
        throw new Error("The tuple syntax is not supported for `screens`.");
      }
      if (typeof screen === "string") {
        return { name: screen.toString(), not: false, values: [{ min: screen, max: void 0 }] };
      }
      let [name, options] = screen;
      name = name.toString();
      if (typeof options === "string") {
        return { name, not: false, values: [{ min: options, max: void 0 }] };
      }
      if (Array.isArray(options)) {
        return { name, not: false, values: options.map((option) => resolveValue(option)) };
      }
      return { name, not: false, values: [resolveValue(options)] };
    });
  }
  return normalizeScreens(Object.entries(screens ?? {}), false);
}
function isScreenSortable(screen) {
  if (screen.values.length !== 1) {
    return { result: false, reason: "multiple-values" };
  } else if (screen.values[0].raw !== void 0) {
    return { result: false, reason: "raw-values" };
  } else if (screen.values[0].min !== void 0 && screen.values[0].max !== void 0) {
    return { result: false, reason: "min-and-max" };
  }
  return { result: true, reason: null };
}
function compareScreens(type, a3, z3) {
  let aScreen = toScreen(a3, type);
  let zScreen = toScreen(z3, type);
  let aSorting = isScreenSortable(aScreen);
  let bSorting = isScreenSortable(zScreen);
  if (aSorting.reason === "multiple-values" || bSorting.reason === "multiple-values") {
    throw new Error(
      "Attempted to sort a screen with multiple values. This should never happen. Please open a bug report."
    );
  } else if (aSorting.reason === "raw-values" || bSorting.reason === "raw-values") {
    throw new Error(
      "Attempted to sort a screen with raw values. This should never happen. Please open a bug report."
    );
  } else if (aSorting.reason === "min-and-max" || bSorting.reason === "min-and-max") {
    throw new Error(
      "Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report."
    );
  }
  let { min: aMin, max: aMax } = aScreen.values[0];
  let { min: zMin, max: zMax } = zScreen.values[0];
  if (a3.not)
    [aMin, aMax] = [aMax, aMin];
  if (z3.not)
    [zMin, zMax] = [zMax, zMin];
  aMin = aMin === void 0 ? aMin : parseFloat(aMin);
  aMax = aMax === void 0 ? aMax : parseFloat(aMax);
  zMin = zMin === void 0 ? zMin : parseFloat(zMin);
  zMax = zMax === void 0 ? zMax : parseFloat(zMax);
  let [aValue, zValue] = type === "min" ? [aMin, zMin] : [zMax, aMax];
  return aValue - zValue;
}
function toScreen(value2, type) {
  if (typeof value2 === "object") {
    return value2;
  }
  return {
    name: "arbitrary-screen",
    values: [{ [type]: value2 }]
  };
}
function resolveValue({ "min-width": _minWidth, min: min2 = _minWidth, max: max22, raw } = {}) {
  return { min: min2, max: max22, raw };
}
function removeAlphaVariables(container, toRemove) {
  container.walkDecls((decl2) => {
    if (toRemove.includes(decl2.prop)) {
      decl2.remove();
      return;
    }
    for (let varName of toRemove) {
      if (decl2.value.includes(`/ var(${varName})`)) {
        decl2.value = decl2.value.replace(`/ var(${varName})`, "");
      }
    }
  });
}
var variantPlugins = {
  pseudoElementVariants: ({ addVariant }) => {
    addVariant("first-letter", "&::first-letter");
    addVariant("first-line", "&::first-line");
    addVariant("marker", [
      ({ container }) => {
        removeAlphaVariables(container, ["--tw-text-opacity"]);
        return "& *::marker";
      },
      ({ container }) => {
        removeAlphaVariables(container, ["--tw-text-opacity"]);
        return "&::marker";
      }
    ]);
    addVariant("selection", ["& *::selection", "&::selection"]);
    addVariant("file", "&::file-selector-button");
    addVariant("placeholder", "&::placeholder");
    addVariant("backdrop", "&::backdrop");
    addVariant("before", ({ container }) => {
      container.walkRules((rule2) => {
        let foundContent = false;
        rule2.walkDecls("content", () => {
          foundContent = true;
        });
        if (!foundContent) {
          rule2.prepend(postcss_default.decl({ prop: "content", value: "var(--tw-content)" }));
        }
      });
      return "&::before";
    });
    addVariant("after", ({ container }) => {
      container.walkRules((rule2) => {
        let foundContent = false;
        rule2.walkDecls("content", () => {
          foundContent = true;
        });
        if (!foundContent) {
          rule2.prepend(postcss_default.decl({ prop: "content", value: "var(--tw-content)" }));
        }
      });
      return "&::after";
    });
  },
  pseudoClassVariants: ({ addVariant, matchVariant, config }) => {
    let pseudoVariants = [
      ["first", "&:first-child"],
      ["last", "&:last-child"],
      ["only", "&:only-child"],
      ["odd", "&:nth-child(odd)"],
      ["even", "&:nth-child(even)"],
      "first-of-type",
      "last-of-type",
      "only-of-type",
      [
        "visited",
        ({ container }) => {
          removeAlphaVariables(container, [
            "--tw-text-opacity",
            "--tw-border-opacity",
            "--tw-bg-opacity"
          ]);
          return "&:visited";
        }
      ],
      "target",
      ["open", "&[open]"],
      "default",
      "checked",
      "indeterminate",
      "placeholder-shown",
      "autofill",
      "optional",
      "required",
      "valid",
      "invalid",
      "in-range",
      "out-of-range",
      "read-only",
      "empty",
      "focus-within",
      [
        "hover",
        !flagEnabled(config(), "hoverOnlyWhenSupported") ? "&:hover" : "@media (hover: hover) and (pointer: fine) { &:hover }"
      ],
      "focus",
      "focus-visible",
      "active",
      "enabled",
      "disabled"
    ].map((variant) => Array.isArray(variant) ? variant : [variant, `&:${variant}`]);
    for (let [variantName, state] of pseudoVariants) {
      addVariant(variantName, (ctx) => {
        let result = typeof state === "function" ? state(ctx) : state;
        return result;
      });
    }
    let variants = {
      group: (_3, { modifier }) => modifier ? [`:merge(.group\\/${escapeClassName(modifier)})`, " &"] : [`:merge(.group)`, " &"],
      peer: (_3, { modifier }) => modifier ? [`:merge(.peer\\/${escapeClassName(modifier)})`, " ~ &"] : [`:merge(.peer)`, " ~ &"]
    };
    for (let [name, fn] of Object.entries(variants)) {
      matchVariant(
        name,
        (value2 = "", extra) => {
          let result = normalize2(typeof value2 === "function" ? value2(extra) : value2);
          if (!result.includes("&"))
            result = "&" + result;
          let [a3, b3] = fn("", extra);
          let start = null;
          let end = null;
          let quotes2 = 0;
          for (let i5 = 0; i5 < result.length; ++i5) {
            let c2 = result[i5];
            if (c2 === "&") {
              start = i5;
            } else if (c2 === "'" || c2 === '"') {
              quotes2 += 1;
            } else if (start !== null && c2 === " " && !quotes2) {
              end = i5;
            }
          }
          if (start !== null && end === null) {
            end = result.length;
          }
          return result.slice(0, start) + a3 + result.slice(start + 1, end) + b3 + result.slice(end);
        },
        { values: Object.fromEntries(pseudoVariants) }
      );
    }
  },
  directionVariants: ({ addVariant }) => {
    addVariant("ltr", ':is([dir="ltr"] &)');
    addVariant("rtl", ':is([dir="rtl"] &)');
  },
  reducedMotionVariants: ({ addVariant }) => {
    addVariant("motion-safe", "@media (prefers-reduced-motion: no-preference)");
    addVariant("motion-reduce", "@media (prefers-reduced-motion: reduce)");
  },
  darkVariants: ({ config, addVariant }) => {
    let [mode, className = ".dark"] = [].concat(config("darkMode", "media"));
    if (mode === false) {
      mode = "media";
      log_default.warn("darkmode-false", [
        "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
        "Change `darkMode` to `media` or remove it entirely.",
        "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
      ]);
    }
    if (mode === "class") {
      addVariant("dark", `:is(${className} &)`);
    } else if (mode === "media") {
      addVariant("dark", "@media (prefers-color-scheme: dark)");
    }
  },
  printVariant: ({ addVariant }) => {
    addVariant("print", "@media print");
  },
  screenVariants: ({ theme, addVariant, matchVariant }) => {
    let rawScreens = theme("screens") ?? {};
    let areSimpleScreens = Object.values(rawScreens).every((v2) => typeof v2 === "string");
    let screens = normalizeScreens(theme("screens"));
    let unitCache = /* @__PURE__ */ new Set([]);
    function units(value2) {
      return value2.match(/(\D+)$/)?.[1] ?? "(none)";
    }
    function recordUnits(value2) {
      if (value2 !== void 0) {
        unitCache.add(units(value2));
      }
    }
    function canUseUnits(value2) {
      recordUnits(value2);
      return unitCache.size === 1;
    }
    for (const screen of screens) {
      for (const value2 of screen.values) {
        recordUnits(value2.min);
        recordUnits(value2.max);
      }
    }
    let screensUseConsistentUnits = unitCache.size <= 1;
    function buildScreenValues(type) {
      return Object.fromEntries(
        screens.filter((screen) => isScreenSortable(screen).result).map((screen) => {
          let { min: min2, max: max22 } = screen.values[0];
          if (type === "min" && min2 !== void 0) {
            return screen;
          } else if (type === "min" && max22 !== void 0) {
            return { ...screen, not: !screen.not };
          } else if (type === "max" && max22 !== void 0) {
            return screen;
          } else if (type === "max" && min2 !== void 0) {
            return { ...screen, not: !screen.not };
          }
        }).map((screen) => [screen.name, screen])
      );
    }
    function buildSort(type) {
      return (a3, z3) => compareScreens(type, a3.value, z3.value);
    }
    let maxSort = buildSort("max");
    let minSort = buildSort("min");
    function buildScreenVariant(type) {
      return (value2) => {
        if (!areSimpleScreens) {
          log_default.warn("complex-screen-config", [
            "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
          ]);
          return [];
        } else if (!screensUseConsistentUnits) {
          log_default.warn("mixed-screen-units", [
            "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
          ]);
          return [];
        } else if (typeof value2 === "string" && !canUseUnits(value2)) {
          log_default.warn("minmax-have-mixed-units", [
            "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
          ]);
          return [];
        }
        return [`@media ${buildMediaQuery(toScreen(value2, type))}`];
      };
    }
    matchVariant("max", buildScreenVariant("max"), {
      sort: maxSort,
      values: areSimpleScreens ? buildScreenValues("max") : {}
    });
    let id = "min-screens";
    for (let screen of screens) {
      addVariant(screen.name, `@media ${buildMediaQuery(screen)}`, {
        id,
        sort: areSimpleScreens && screensUseConsistentUnits ? minSort : void 0,
        value: screen
      });
    }
    matchVariant("min", buildScreenVariant("min"), {
      id,
      sort: minSort
    });
  },
  supportsVariants: ({ matchVariant, theme }) => {
    matchVariant(
      "supports",
      (value2 = "") => {
        let check = normalize2(value2);
        let isRaw = /^\w*\s*\(/.test(check);
        check = isRaw ? check.replace(/\b(and|or|not)\b/g, " $1 ") : check;
        if (isRaw) {
          return `@supports ${check}`;
        }
        if (!check.includes(":")) {
          check = `${check}: var(--tw)`;
        }
        if (!(check.startsWith("(") && check.endsWith(")"))) {
          check = `(${check})`;
        }
        return `@supports ${check}`;
      },
      { values: theme("supports") ?? {} }
    );
  },
  ariaVariants: ({ matchVariant, theme }) => {
    matchVariant("aria", (value2) => `&[aria-${normalize2(value2)}]`, { values: theme("aria") ?? {} });
    matchVariant(
      "group-aria",
      (value2, { modifier }) => modifier ? `:merge(.group\\/${modifier})[aria-${normalize2(value2)}] &` : `:merge(.group)[aria-${normalize2(value2)}] &`,
      { values: theme("aria") ?? {} }
    );
    matchVariant(
      "peer-aria",
      (value2, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[aria-${normalize2(value2)}] ~ &` : `:merge(.peer)[aria-${normalize2(value2)}] ~ &`,
      { values: theme("aria") ?? {} }
    );
  },
  dataVariants: ({ matchVariant, theme }) => {
    matchVariant("data", (value2) => `&[data-${normalize2(value2)}]`, { values: theme("data") ?? {} });
    matchVariant(
      "group-data",
      (value2, { modifier }) => modifier ? `:merge(.group\\/${modifier})[data-${normalize2(value2)}] &` : `:merge(.group)[data-${normalize2(value2)}] &`,
      { values: theme("data") ?? {} }
    );
    matchVariant(
      "peer-data",
      (value2, { modifier }) => modifier ? `:merge(.peer\\/${modifier})[data-${normalize2(value2)}] ~ &` : `:merge(.peer)[data-${normalize2(value2)}] ~ &`,
      { values: theme("data") ?? {} }
    );
  },
  orientationVariants: ({ addVariant }) => {
    addVariant("portrait", "@media (orientation: portrait)");
    addVariant("landscape", "@media (orientation: landscape)");
  },
  prefersContrastVariants: ({ addVariant }) => {
    addVariant("contrast-more", "@media (prefers-contrast: more)");
    addVariant("contrast-less", "@media (prefers-contrast: less)");
  }
};
var cssTransformValue = [
  "translate(var(--tw-translate-x), var(--tw-translate-y))",
  "rotate(var(--tw-rotate))",
  "skewX(var(--tw-skew-x))",
  "skewY(var(--tw-skew-y))",
  "scaleX(var(--tw-scale-x))",
  "scaleY(var(--tw-scale-y))"
].join(" ");
var cssFilterValue = [
  "var(--tw-blur)",
  "var(--tw-brightness)",
  "var(--tw-contrast)",
  "var(--tw-grayscale)",
  "var(--tw-hue-rotate)",
  "var(--tw-invert)",
  "var(--tw-saturate)",
  "var(--tw-sepia)",
  "var(--tw-drop-shadow)"
].join(" ");
var cssBackdropFilterValue = [
  "var(--tw-backdrop-blur)",
  "var(--tw-backdrop-brightness)",
  "var(--tw-backdrop-contrast)",
  "var(--tw-backdrop-grayscale)",
  "var(--tw-backdrop-hue-rotate)",
  "var(--tw-backdrop-invert)",
  "var(--tw-backdrop-opacity)",
  "var(--tw-backdrop-saturate)",
  "var(--tw-backdrop-sepia)"
].join(" ");
var corePlugins = {
  preflight: ({ addBase }) => {
    let preflightStyles = postcss_default.parse(
      fs_default.readFileSync(join("/", "./css/preflight.css"), "utf8")
    );
    addBase([
      postcss_default.comment({
        text: `! tailwindcss v${version} | MIT License | https://tailwindcss.com`
      }),
      ...preflightStyles.nodes
    ]);
  },
  container: /* @__PURE__ */ (() => {
    function extractMinWidths(breakpoints = []) {
      return breakpoints.flatMap((breakpoint) => breakpoint.values.map((breakpoint2) => breakpoint2.min)).filter((v2) => v2 !== void 0);
    }
    function mapMinWidthsToPadding(minWidths, screens, paddings) {
      if (typeof paddings === "undefined") {
        return [];
      }
      if (!(typeof paddings === "object" && paddings !== null)) {
        return [
          {
            screen: "DEFAULT",
            minWidth: 0,
            padding: paddings
          }
        ];
      }
      let mapping = [];
      if (paddings.DEFAULT) {
        mapping.push({
          screen: "DEFAULT",
          minWidth: 0,
          padding: paddings.DEFAULT
        });
      }
      for (let minWidth of minWidths) {
        for (let screen of screens) {
          for (let { min: min2 } of screen.values) {
            if (min2 === minWidth) {
              mapping.push({ minWidth, padding: paddings[screen.name] });
            }
          }
        }
      }
      return mapping;
    }
    return function({ addComponents, theme }) {
      let screens = normalizeScreens(theme("container.screens", theme("screens")));
      let minWidths = extractMinWidths(screens);
      let paddings = mapMinWidthsToPadding(minWidths, screens, theme("container.padding"));
      let generatePaddingFor = (minWidth) => {
        let paddingConfig = paddings.find((padding) => padding.minWidth === minWidth);
        if (!paddingConfig) {
          return {};
        }
        return {
          paddingRight: paddingConfig.padding,
          paddingLeft: paddingConfig.padding
        };
      };
      let atRules = Array.from(
        new Set(minWidths.slice().sort((a3, z3) => parseInt(a3) - parseInt(z3)))
      ).map((minWidth) => ({
        [`@media (min-width: ${minWidth})`]: {
          ".container": {
            "max-width": minWidth,
            ...generatePaddingFor(minWidth)
          }
        }
      }));
      addComponents([
        {
          ".container": Object.assign(
            { width: "100%" },
            theme("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {},
            generatePaddingFor(0)
          )
        },
        ...atRules
      ]);
    };
  })(),
  accessibility: ({ addUtilities }) => {
    addUtilities({
      ".sr-only": {
        position: "absolute",
        width: "1px",
        height: "1px",
        padding: "0",
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        borderWidth: "0"
      },
      ".not-sr-only": {
        position: "static",
        width: "auto",
        height: "auto",
        padding: "0",
        margin: "0",
        overflow: "visible",
        clip: "auto",
        whiteSpace: "normal"
      }
    });
  },
  pointerEvents: ({ addUtilities }) => {
    addUtilities({
      ".pointer-events-none": { "pointer-events": "none" },
      ".pointer-events-auto": { "pointer-events": "auto" }
    });
  },
  visibility: ({ addUtilities }) => {
    addUtilities({
      ".visible": { visibility: "visible" },
      ".invisible": { visibility: "hidden" },
      ".collapse": { visibility: "collapse" }
    });
  },
  position: ({ addUtilities }) => {
    addUtilities({
      ".static": { position: "static" },
      ".fixed": { position: "fixed" },
      ".absolute": { position: "absolute" },
      ".relative": { position: "relative" },
      ".sticky": { position: "sticky" }
    });
  },
  inset: createUtilityPlugin(
    "inset",
    [
      ["inset", ["inset"]],
      [
        ["inset-x", ["left", "right"]],
        ["inset-y", ["top", "bottom"]]
      ],
      [
        ["start", ["inset-inline-start"]],
        ["end", ["inset-inline-end"]],
        ["top", ["top"]],
        ["right", ["right"]],
        ["bottom", ["bottom"]],
        ["left", ["left"]]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  isolation: ({ addUtilities }) => {
    addUtilities({
      ".isolate": { isolation: "isolate" },
      ".isolation-auto": { isolation: "auto" }
    });
  },
  zIndex: createUtilityPlugin("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }),
  order: createUtilityPlugin("order", void 0, { supportsNegativeValues: true }),
  gridColumn: createUtilityPlugin("gridColumn", [["col", ["gridColumn"]]]),
  gridColumnStart: createUtilityPlugin("gridColumnStart", [["col-start", ["gridColumnStart"]]]),
  gridColumnEnd: createUtilityPlugin("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]),
  gridRow: createUtilityPlugin("gridRow", [["row", ["gridRow"]]]),
  gridRowStart: createUtilityPlugin("gridRowStart", [["row-start", ["gridRowStart"]]]),
  gridRowEnd: createUtilityPlugin("gridRowEnd", [["row-end", ["gridRowEnd"]]]),
  float: ({ addUtilities }) => {
    addUtilities({
      ".float-right": { float: "right" },
      ".float-left": { float: "left" },
      ".float-none": { float: "none" }
    });
  },
  clear: ({ addUtilities }) => {
    addUtilities({
      ".clear-left": { clear: "left" },
      ".clear-right": { clear: "right" },
      ".clear-both": { clear: "both" },
      ".clear-none": { clear: "none" }
    });
  },
  margin: createUtilityPlugin(
    "margin",
    [
      ["m", ["margin"]],
      [
        ["mx", ["margin-left", "margin-right"]],
        ["my", ["margin-top", "margin-bottom"]]
      ],
      [
        ["ms", ["margin-inline-start"]],
        ["me", ["margin-inline-end"]],
        ["mt", ["margin-top"]],
        ["mr", ["margin-right"]],
        ["mb", ["margin-bottom"]],
        ["ml", ["margin-left"]]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  boxSizing: ({ addUtilities }) => {
    addUtilities({
      ".box-border": { "box-sizing": "border-box" },
      ".box-content": { "box-sizing": "content-box" }
    });
  },
  lineClamp: ({ matchUtilities, addUtilities, theme }) => {
    matchUtilities(
      {
        "line-clamp": (value2) => ({
          overflow: "hidden",
          display: "-webkit-box",
          "-webkit-box-orient": "vertical",
          "-webkit-line-clamp": `${value2}`
        })
      },
      { values: theme("lineClamp") }
    );
    addUtilities({
      ".line-clamp-none": {
        overflow: "visible",
        display: "block",
        "-webkit-box-orient": "horizontal",
        "-webkit-line-clamp": "none"
      }
    });
  },
  display: ({ addUtilities }) => {
    addUtilities({
      ".block": { display: "block" },
      ".inline-block": { display: "inline-block" },
      ".inline": { display: "inline" },
      ".flex": { display: "flex" },
      ".inline-flex": { display: "inline-flex" },
      ".table": { display: "table" },
      ".inline-table": { display: "inline-table" },
      ".table-caption": { display: "table-caption" },
      ".table-cell": { display: "table-cell" },
      ".table-column": { display: "table-column" },
      ".table-column-group": { display: "table-column-group" },
      ".table-footer-group": { display: "table-footer-group" },
      ".table-header-group": { display: "table-header-group" },
      ".table-row-group": { display: "table-row-group" },
      ".table-row": { display: "table-row" },
      ".flow-root": { display: "flow-root" },
      ".grid": { display: "grid" },
      ".inline-grid": { display: "inline-grid" },
      ".contents": { display: "contents" },
      ".list-item": { display: "list-item" },
      ".hidden": { display: "none" }
    });
  },
  aspectRatio: createUtilityPlugin("aspectRatio", [["aspect", ["aspect-ratio"]]]),
  height: createUtilityPlugin("height", [["h", ["height"]]]),
  maxHeight: createUtilityPlugin("maxHeight", [["max-h", ["maxHeight"]]]),
  minHeight: createUtilityPlugin("minHeight", [["min-h", ["minHeight"]]]),
  width: createUtilityPlugin("width", [["w", ["width"]]]),
  minWidth: createUtilityPlugin("minWidth", [["min-w", ["minWidth"]]]),
  maxWidth: createUtilityPlugin("maxWidth", [["max-w", ["maxWidth"]]]),
  flex: createUtilityPlugin("flex"),
  flexShrink: createUtilityPlugin("flexShrink", [
    ["flex-shrink", ["flex-shrink"]],
    ["shrink", ["flex-shrink"]]
  ]),
  flexGrow: createUtilityPlugin("flexGrow", [
    ["flex-grow", ["flex-grow"]],
    ["grow", ["flex-grow"]]
  ]),
  flexBasis: createUtilityPlugin("flexBasis", [["basis", ["flex-basis"]]]),
  tableLayout: ({ addUtilities }) => {
    addUtilities({
      ".table-auto": { "table-layout": "auto" },
      ".table-fixed": { "table-layout": "fixed" }
    });
  },
  captionSide: ({ addUtilities }) => {
    addUtilities({
      ".caption-top": { "caption-side": "top" },
      ".caption-bottom": { "caption-side": "bottom" }
    });
  },
  borderCollapse: ({ addUtilities }) => {
    addUtilities({
      ".border-collapse": { "border-collapse": "collapse" },
      ".border-separate": { "border-collapse": "separate" }
    });
  },
  borderSpacing: ({ addDefaults, matchUtilities, theme }) => {
    addDefaults("border-spacing", {
      "--tw-border-spacing-x": 0,
      "--tw-border-spacing-y": 0
    });
    matchUtilities(
      {
        "border-spacing": (value2) => {
          return {
            "--tw-border-spacing-x": value2,
            "--tw-border-spacing-y": value2,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          };
        },
        "border-spacing-x": (value2) => {
          return {
            "--tw-border-spacing-x": value2,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          };
        },
        "border-spacing-y": (value2) => {
          return {
            "--tw-border-spacing-y": value2,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          };
        }
      },
      { values: theme("borderSpacing") }
    );
  },
  transformOrigin: createUtilityPlugin("transformOrigin", [["origin", ["transformOrigin"]]]),
  translate: createUtilityPlugin(
    "translate",
    [
      [
        [
          "translate-x",
          [["@defaults transform", {}], "--tw-translate-x", ["transform", cssTransformValue]]
        ],
        [
          "translate-y",
          [["@defaults transform", {}], "--tw-translate-y", ["transform", cssTransformValue]]
        ]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  rotate: createUtilityPlugin(
    "rotate",
    [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", cssTransformValue]]]],
    { supportsNegativeValues: true }
  ),
  skew: createUtilityPlugin(
    "skew",
    [
      [
        ["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", cssTransformValue]]],
        ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", cssTransformValue]]]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  scale: createUtilityPlugin(
    "scale",
    [
      [
        "scale",
        [
          ["@defaults transform", {}],
          "--tw-scale-x",
          "--tw-scale-y",
          ["transform", cssTransformValue]
        ]
      ],
      [
        [
          "scale-x",
          [["@defaults transform", {}], "--tw-scale-x", ["transform", cssTransformValue]]
        ],
        [
          "scale-y",
          [["@defaults transform", {}], "--tw-scale-y", ["transform", cssTransformValue]]
        ]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  transform: ({ addDefaults, addUtilities }) => {
    addDefaults("transform", {
      "--tw-translate-x": "0",
      "--tw-translate-y": "0",
      "--tw-rotate": "0",
      "--tw-skew-x": "0",
      "--tw-skew-y": "0",
      "--tw-scale-x": "1",
      "--tw-scale-y": "1"
    });
    addUtilities({
      ".transform": { "@defaults transform": {}, transform: cssTransformValue },
      ".transform-cpu": {
        transform: cssTransformValue
      },
      ".transform-gpu": {
        transform: cssTransformValue.replace(
          "translate(var(--tw-translate-x), var(--tw-translate-y))",
          "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)"
        )
      },
      ".transform-none": { transform: "none" }
    });
  },
  animation: ({ matchUtilities, theme, config }) => {
    let prefixName = (name) => `${config("prefix")}${escapeClassName(name)}`;
    let keyframes = Object.fromEntries(
      Object.entries(theme("keyframes") ?? {}).map(([key, value2]) => {
        return [key, { [`@keyframes ${prefixName(key)}`]: value2 }];
      })
    );
    matchUtilities(
      {
        animate: (value2) => {
          let animations = parseAnimationValue(value2);
          return [
            ...animations.flatMap((animation) => keyframes[animation.name]),
            {
              animation: animations.map(({ name, value: value3 }) => {
                if (name === void 0 || keyframes[name] === void 0) {
                  return value3;
                }
                return value3.replace(name, prefixName(name));
              }).join(", ")
            }
          ];
        }
      },
      { values: theme("animation") }
    );
  },
  cursor: createUtilityPlugin("cursor"),
  touchAction: ({ addDefaults, addUtilities }) => {
    addDefaults("touch-action", {
      "--tw-pan-x": " ",
      "--tw-pan-y": " ",
      "--tw-pinch-zoom": " "
    });
    let cssTouchActionValue = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
    addUtilities({
      ".touch-auto": { "touch-action": "auto" },
      ".touch-none": { "touch-action": "none" },
      ".touch-pan-x": {
        "@defaults touch-action": {},
        "--tw-pan-x": "pan-x",
        "touch-action": cssTouchActionValue
      },
      ".touch-pan-left": {
        "@defaults touch-action": {},
        "--tw-pan-x": "pan-left",
        "touch-action": cssTouchActionValue
      },
      ".touch-pan-right": {
        "@defaults touch-action": {},
        "--tw-pan-x": "pan-right",
        "touch-action": cssTouchActionValue
      },
      ".touch-pan-y": {
        "@defaults touch-action": {},
        "--tw-pan-y": "pan-y",
        "touch-action": cssTouchActionValue
      },
      ".touch-pan-up": {
        "@defaults touch-action": {},
        "--tw-pan-y": "pan-up",
        "touch-action": cssTouchActionValue
      },
      ".touch-pan-down": {
        "@defaults touch-action": {},
        "--tw-pan-y": "pan-down",
        "touch-action": cssTouchActionValue
      },
      ".touch-pinch-zoom": {
        "@defaults touch-action": {},
        "--tw-pinch-zoom": "pinch-zoom",
        "touch-action": cssTouchActionValue
      },
      ".touch-manipulation": { "touch-action": "manipulation" }
    });
  },
  userSelect: ({ addUtilities }) => {
    addUtilities({
      ".select-none": { "user-select": "none" },
      ".select-text": { "user-select": "text" },
      ".select-all": { "user-select": "all" },
      ".select-auto": { "user-select": "auto" }
    });
  },
  resize: ({ addUtilities }) => {
    addUtilities({
      ".resize-none": { resize: "none" },
      ".resize-y": { resize: "vertical" },
      ".resize-x": { resize: "horizontal" },
      ".resize": { resize: "both" }
    });
  },
  scrollSnapType: ({ addDefaults, addUtilities }) => {
    addDefaults("scroll-snap-type", {
      "--tw-scroll-snap-strictness": "proximity"
    });
    addUtilities({
      ".snap-none": { "scroll-snap-type": "none" },
      ".snap-x": {
        "@defaults scroll-snap-type": {},
        "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
      },
      ".snap-y": {
        "@defaults scroll-snap-type": {},
        "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
      },
      ".snap-both": {
        "@defaults scroll-snap-type": {},
        "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
      },
      ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" },
      ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" }
    });
  },
  scrollSnapAlign: ({ addUtilities }) => {
    addUtilities({
      ".snap-start": { "scroll-snap-align": "start" },
      ".snap-end": { "scroll-snap-align": "end" },
      ".snap-center": { "scroll-snap-align": "center" },
      ".snap-align-none": { "scroll-snap-align": "none" }
    });
  },
  scrollSnapStop: ({ addUtilities }) => {
    addUtilities({
      ".snap-normal": { "scroll-snap-stop": "normal" },
      ".snap-always": { "scroll-snap-stop": "always" }
    });
  },
  scrollMargin: createUtilityPlugin(
    "scrollMargin",
    [
      ["scroll-m", ["scroll-margin"]],
      [
        ["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]],
        ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]
      ],
      [
        ["scroll-ms", ["scroll-margin-inline-start"]],
        ["scroll-me", ["scroll-margin-inline-end"]],
        ["scroll-mt", ["scroll-margin-top"]],
        ["scroll-mr", ["scroll-margin-right"]],
        ["scroll-mb", ["scroll-margin-bottom"]],
        ["scroll-ml", ["scroll-margin-left"]]
      ]
    ],
    { supportsNegativeValues: true }
  ),
  scrollPadding: createUtilityPlugin("scrollPadding", [
    ["scroll-p", ["scroll-padding"]],
    [
      ["scroll-px", ["scroll-padding-left", "scroll-padding-right"]],
      ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]
    ],
    [
      ["scroll-ps", ["scroll-padding-inline-start"]],
      ["scroll-pe", ["scroll-padding-inline-end"]],
      ["scroll-pt", ["scroll-padding-top"]],
      ["scroll-pr", ["scroll-padding-right"]],
      ["scroll-pb", ["scroll-padding-bottom"]],
      ["scroll-pl", ["scroll-padding-left"]]
    ]
  ]),
  listStylePosition: ({ addUtilities }) => {
    addUtilities({
      ".list-inside": { "list-style-position": "inside" },
      ".list-outside": { "list-style-position": "outside" }
    });
  },
  listStyleType: createUtilityPlugin("listStyleType", [["list", ["listStyleType"]]]),
  listStyleImage: createUtilityPlugin("listStyleImage", [["list-image", ["listStyleImage"]]]),
  appearance: ({ addUtilities }) => {
    addUtilities({
      ".appearance-none": { appearance: "none" }
    });
  },
  columns: createUtilityPlugin("columns", [["columns", ["columns"]]]),
  breakBefore: ({ addUtilities }) => {
    addUtilities({
      ".break-before-auto": { "break-before": "auto" },
      ".break-before-avoid": { "break-before": "avoid" },
      ".break-before-all": { "break-before": "all" },
      ".break-before-avoid-page": { "break-before": "avoid-page" },
      ".break-before-page": { "break-before": "page" },
      ".break-before-left": { "break-before": "left" },
      ".break-before-right": { "break-before": "right" },
      ".break-before-column": { "break-before": "column" }
    });
  },
  breakInside: ({ addUtilities }) => {
    addUtilities({
      ".break-inside-auto": { "break-inside": "auto" },
      ".break-inside-avoid": { "break-inside": "avoid" },
      ".break-inside-avoid-page": { "break-inside": "avoid-page" },
      ".break-inside-avoid-column": { "break-inside": "avoid-column" }
    });
  },
  breakAfter: ({ addUtilities }) => {
    addUtilities({
      ".break-after-auto": { "break-after": "auto" },
      ".break-after-avoid": { "break-after": "avoid" },
      ".break-after-all": { "break-after": "all" },
      ".break-after-avoid-page": { "break-after": "avoid-page" },
      ".break-after-page": { "break-after": "page" },
      ".break-after-left": { "break-after": "left" },
      ".break-after-right": { "break-after": "right" },
      ".break-after-column": { "break-after": "column" }
    });
  },
  gridAutoColumns: createUtilityPlugin("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]),
  gridAutoFlow: ({ addUtilities }) => {
    addUtilities({
      ".grid-flow-row": { gridAutoFlow: "row" },
      ".grid-flow-col": { gridAutoFlow: "column" },
      ".grid-flow-dense": { gridAutoFlow: "dense" },
      ".grid-flow-row-dense": { gridAutoFlow: "row dense" },
      ".grid-flow-col-dense": { gridAutoFlow: "column dense" }
    });
  },
  gridAutoRows: createUtilityPlugin("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]),
  gridTemplateColumns: createUtilityPlugin("gridTemplateColumns", [
    ["grid-cols", ["gridTemplateColumns"]]
  ]),
  gridTemplateRows: createUtilityPlugin("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]),
  flexDirection: ({ addUtilities }) => {
    addUtilities({
      ".flex-row": { "flex-direction": "row" },
      ".flex-row-reverse": { "flex-direction": "row-reverse" },
      ".flex-col": { "flex-direction": "column" },
      ".flex-col-reverse": { "flex-direction": "column-reverse" }
    });
  },
  flexWrap: ({ addUtilities }) => {
    addUtilities({
      ".flex-wrap": { "flex-wrap": "wrap" },
      ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" },
      ".flex-nowrap": { "flex-wrap": "nowrap" }
    });
  },
  placeContent: ({ addUtilities }) => {
    addUtilities({
      ".place-content-center": { "place-content": "center" },
      ".place-content-start": { "place-content": "start" },
      ".place-content-end": { "place-content": "end" },
      ".place-content-between": { "place-content": "space-between" },
      ".place-content-around": { "place-content": "space-around" },
      ".place-content-evenly": { "place-content": "space-evenly" },
      ".place-content-baseline": { "place-content": "baseline" },
      ".place-content-stretch": { "place-content": "stretch" }
    });
  },
  placeItems: ({ addUtilities }) => {
    addUtilities({
      ".place-items-start": { "place-items": "start" },
      ".place-items-end": { "place-items": "end" },
      ".place-items-center": { "place-items": "center" },
      ".place-items-baseline": { "place-items": "baseline" },
      ".place-items-stretch": { "place-items": "stretch" }
    });
  },
  alignContent: ({ addUtilities }) => {
    addUtilities({
      ".content-normal": { "align-content": "normal" },
      ".content-center": { "align-content": "center" },
      ".content-start": { "align-content": "flex-start" },
      ".content-end": { "align-content": "flex-end" },
      ".content-between": { "align-content": "space-between" },
      ".content-around": { "align-content": "space-around" },
      ".content-evenly": { "align-content": "space-evenly" },
      ".content-baseline": { "align-content": "baseline" },
      ".content-stretch": { "align-content": "stretch" }
    });
  },
  alignItems: ({ addUtilities }) => {
    addUtilities({
      ".items-start": { "align-items": "flex-start" },
      ".items-end": { "align-items": "flex-end" },
      ".items-center": { "align-items": "center" },
      ".items-baseline": { "align-items": "baseline" },
      ".items-stretch": { "align-items": "stretch" }
    });
  },
  justifyContent: ({ addUtilities }) => {
    addUtilities({
      ".justify-normal": { "justify-content": "normal" },
      ".justify-start": { "justify-content": "flex-start" },
      ".justify-end": { "justify-content": "flex-end" },
      ".justify-center": { "justify-content": "center" },
      ".justify-between": { "justify-content": "space-between" },
      ".justify-around": { "justify-content": "space-around" },
      ".justify-evenly": { "justify-content": "space-evenly" },
      ".justify-stretch": { "justify-content": "stretch" }
    });
  },
  justifyItems: ({ addUtilities }) => {
    addUtilities({
      ".justify-items-start": { "justify-items": "start" },
      ".justify-items-end": { "justify-items": "end" },
      ".justify-items-center": { "justify-items": "center" },
      ".justify-items-stretch": { "justify-items": "stretch" }
    });
  },
  gap: createUtilityPlugin("gap", [
    ["gap", ["gap"]],
    [
      ["gap-x", ["columnGap"]],
      ["gap-y", ["rowGap"]]
    ]
  ]),
  space: ({ matchUtilities, addUtilities, theme }) => {
    matchUtilities(
      {
        "space-x": (value2) => {
          value2 = value2 === "0" ? "0px" : value2;
          if (env.OXIDE) {
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-x-reverse": "0",
                "margin-inline-end": `calc(${value2} * var(--tw-space-x-reverse))`,
                "margin-inline-start": `calc(${value2} * calc(1 - var(--tw-space-x-reverse)))`
              }
            };
          }
          return {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-x-reverse": "0",
              "margin-right": `calc(${value2} * var(--tw-space-x-reverse))`,
              "margin-left": `calc(${value2} * calc(1 - var(--tw-space-x-reverse)))`
            }
          };
        },
        "space-y": (value2) => {
          value2 = value2 === "0" ? "0px" : value2;
          return {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-y-reverse": "0",
              "margin-top": `calc(${value2} * calc(1 - var(--tw-space-y-reverse)))`,
              "margin-bottom": `calc(${value2} * var(--tw-space-y-reverse))`
            }
          };
        }
      },
      { values: theme("space"), supportsNegativeValues: true }
    );
    addUtilities({
      ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" },
      ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" }
    });
  },
  divideWidth: ({ matchUtilities, addUtilities, theme }) => {
    matchUtilities(
      {
        "divide-x": (value2) => {
          value2 = value2 === "0" ? "0px" : value2;
          if (env.OXIDE) {
            return {
              "& > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-x-reverse": "0",
                "border-inline-end-width": `calc(${value2} * var(--tw-divide-x-reverse))`,
                "border-inline-start-width": `calc(${value2} * calc(1 - var(--tw-divide-x-reverse)))`
              }
            };
          }
          return {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-x-reverse": "0",
              "border-right-width": `calc(${value2} * var(--tw-divide-x-reverse))`,
              "border-left-width": `calc(${value2} * calc(1 - var(--tw-divide-x-reverse)))`
            }
          };
        },
        "divide-y": (value2) => {
          value2 = value2 === "0" ? "0px" : value2;
          return {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-y-reverse": "0",
              "border-top-width": `calc(${value2} * calc(1 - var(--tw-divide-y-reverse)))`,
              "border-bottom-width": `calc(${value2} * var(--tw-divide-y-reverse))`
            }
          };
        }
      },
      { values: theme("divideWidth"), type: ["line-width", "length", "any"] }
    );
    addUtilities({
      ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
        "@defaults border-width": {},
        "--tw-divide-y-reverse": "1"
      },
      ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
        "@defaults border-width": {},
        "--tw-divide-x-reverse": "1"
      }
    });
  },
  divideStyle: ({ addUtilities }) => {
    addUtilities({
      ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" },
      ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" },
      ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" },
      ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" },
      ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" }
    });
  },
  divideColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        divide: (value2) => {
          if (!corePlugins2("divideOpacity")) {
            return {
              ["& > :not([hidden]) ~ :not([hidden])"]: {
                "border-color": toColorValue(value2)
              }
            };
          }
          return {
            ["& > :not([hidden]) ~ :not([hidden])"]: withAlphaVariable({
              color: value2,
              property: "border-color",
              variable: "--tw-divide-opacity"
            })
          };
        }
      },
      {
        values: (({ DEFAULT: _3, ...colors }) => colors)(flattenColorPalette_default(theme("divideColor"))),
        type: ["color", "any"]
      }
    );
  },
  divideOpacity: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "divide-opacity": (value2) => {
          return { [`& > :not([hidden]) ~ :not([hidden])`]: { "--tw-divide-opacity": value2 } };
        }
      },
      { values: theme("divideOpacity") }
    );
  },
  placeSelf: ({ addUtilities }) => {
    addUtilities({
      ".place-self-auto": { "place-self": "auto" },
      ".place-self-start": { "place-self": "start" },
      ".place-self-end": { "place-self": "end" },
      ".place-self-center": { "place-self": "center" },
      ".place-self-stretch": { "place-self": "stretch" }
    });
  },
  alignSelf: ({ addUtilities }) => {
    addUtilities({
      ".self-auto": { "align-self": "auto" },
      ".self-start": { "align-self": "flex-start" },
      ".self-end": { "align-self": "flex-end" },
      ".self-center": { "align-self": "center" },
      ".self-stretch": { "align-self": "stretch" },
      ".self-baseline": { "align-self": "baseline" }
    });
  },
  justifySelf: ({ addUtilities }) => {
    addUtilities({
      ".justify-self-auto": { "justify-self": "auto" },
      ".justify-self-start": { "justify-self": "start" },
      ".justify-self-end": { "justify-self": "end" },
      ".justify-self-center": { "justify-self": "center" },
      ".justify-self-stretch": { "justify-self": "stretch" }
    });
  },
  overflow: ({ addUtilities }) => {
    addUtilities({
      ".overflow-auto": { overflow: "auto" },
      ".overflow-hidden": { overflow: "hidden" },
      ".overflow-clip": { overflow: "clip" },
      ".overflow-visible": { overflow: "visible" },
      ".overflow-scroll": { overflow: "scroll" },
      ".overflow-x-auto": { "overflow-x": "auto" },
      ".overflow-y-auto": { "overflow-y": "auto" },
      ".overflow-x-hidden": { "overflow-x": "hidden" },
      ".overflow-y-hidden": { "overflow-y": "hidden" },
      ".overflow-x-clip": { "overflow-x": "clip" },
      ".overflow-y-clip": { "overflow-y": "clip" },
      ".overflow-x-visible": { "overflow-x": "visible" },
      ".overflow-y-visible": { "overflow-y": "visible" },
      ".overflow-x-scroll": { "overflow-x": "scroll" },
      ".overflow-y-scroll": { "overflow-y": "scroll" }
    });
  },
  overscrollBehavior: ({ addUtilities }) => {
    addUtilities({
      ".overscroll-auto": { "overscroll-behavior": "auto" },
      ".overscroll-contain": { "overscroll-behavior": "contain" },
      ".overscroll-none": { "overscroll-behavior": "none" },
      ".overscroll-y-auto": { "overscroll-behavior-y": "auto" },
      ".overscroll-y-contain": { "overscroll-behavior-y": "contain" },
      ".overscroll-y-none": { "overscroll-behavior-y": "none" },
      ".overscroll-x-auto": { "overscroll-behavior-x": "auto" },
      ".overscroll-x-contain": { "overscroll-behavior-x": "contain" },
      ".overscroll-x-none": { "overscroll-behavior-x": "none" }
    });
  },
  scrollBehavior: ({ addUtilities }) => {
    addUtilities({
      ".scroll-auto": { "scroll-behavior": "auto" },
      ".scroll-smooth": { "scroll-behavior": "smooth" }
    });
  },
  textOverflow: ({ addUtilities }) => {
    addUtilities({
      ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" },
      ".overflow-ellipsis": { "text-overflow": "ellipsis" },
      ".text-ellipsis": { "text-overflow": "ellipsis" },
      ".text-clip": { "text-overflow": "clip" }
    });
  },
  hyphens: ({ addUtilities }) => {
    addUtilities({
      ".hyphens-none": { hyphens: "none" },
      ".hyphens-manual": { hyphens: "manual" },
      ".hyphens-auto": { hyphens: "auto" }
    });
  },
  whitespace: ({ addUtilities }) => {
    addUtilities({
      ".whitespace-normal": { "white-space": "normal" },
      ".whitespace-nowrap": { "white-space": "nowrap" },
      ".whitespace-pre": { "white-space": "pre" },
      ".whitespace-pre-line": { "white-space": "pre-line" },
      ".whitespace-pre-wrap": { "white-space": "pre-wrap" },
      ".whitespace-break-spaces": { "white-space": "break-spaces" }
    });
  },
  wordBreak: ({ addUtilities }) => {
    addUtilities({
      ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" },
      ".break-words": { "overflow-wrap": "break-word" },
      ".break-all": { "word-break": "break-all" },
      ".break-keep": { "word-break": "keep-all" }
    });
  },
  borderRadius: createUtilityPlugin("borderRadius", [
    ["rounded", ["border-radius"]],
    [
      ["rounded-s", ["border-start-start-radius", "border-end-start-radius"]],
      ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]],
      ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]],
      ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]],
      ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]],
      ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]
    ],
    [
      ["rounded-ss", ["border-start-start-radius"]],
      ["rounded-se", ["border-start-end-radius"]],
      ["rounded-ee", ["border-end-end-radius"]],
      ["rounded-es", ["border-end-start-radius"]],
      ["rounded-tl", ["border-top-left-radius"]],
      ["rounded-tr", ["border-top-right-radius"]],
      ["rounded-br", ["border-bottom-right-radius"]],
      ["rounded-bl", ["border-bottom-left-radius"]]
    ]
  ]),
  borderWidth: createUtilityPlugin(
    "borderWidth",
    [
      ["border", [["@defaults border-width", {}], "border-width"]],
      [
        ["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]],
        ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]
      ],
      [
        ["border-s", [["@defaults border-width", {}], "border-inline-start-width"]],
        ["border-e", [["@defaults border-width", {}], "border-inline-end-width"]],
        ["border-t", [["@defaults border-width", {}], "border-top-width"]],
        ["border-r", [["@defaults border-width", {}], "border-right-width"]],
        ["border-b", [["@defaults border-width", {}], "border-bottom-width"]],
        ["border-l", [["@defaults border-width", {}], "border-left-width"]]
      ]
    ],
    { type: ["line-width", "length"] }
  ),
  borderStyle: ({ addUtilities }) => {
    addUtilities({
      ".border-solid": { "border-style": "solid" },
      ".border-dashed": { "border-style": "dashed" },
      ".border-dotted": { "border-style": "dotted" },
      ".border-double": { "border-style": "double" },
      ".border-hidden": { "border-style": "hidden" },
      ".border-none": { "border-style": "none" }
    });
  },
  borderColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        border: (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-color",
            variable: "--tw-border-opacity"
          });
        }
      },
      {
        values: (({ DEFAULT: _3, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
        type: ["color", "any"]
      }
    );
    matchUtilities(
      {
        "border-x": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-left-color": toColorValue(value2),
              "border-right-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: ["border-left-color", "border-right-color"],
            variable: "--tw-border-opacity"
          });
        },
        "border-y": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-top-color": toColorValue(value2),
              "border-bottom-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: ["border-top-color", "border-bottom-color"],
            variable: "--tw-border-opacity"
          });
        }
      },
      {
        values: (({ DEFAULT: _3, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
        type: ["color", "any"]
      }
    );
    matchUtilities(
      {
        "border-s": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-inline-start-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-inline-start-color",
            variable: "--tw-border-opacity"
          });
        },
        "border-e": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-inline-end-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-inline-end-color",
            variable: "--tw-border-opacity"
          });
        },
        "border-t": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-top-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-top-color",
            variable: "--tw-border-opacity"
          });
        },
        "border-r": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-right-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-right-color",
            variable: "--tw-border-opacity"
          });
        },
        "border-b": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-bottom-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-bottom-color",
            variable: "--tw-border-opacity"
          });
        },
        "border-l": (value2) => {
          if (!corePlugins2("borderOpacity")) {
            return {
              "border-left-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "border-left-color",
            variable: "--tw-border-opacity"
          });
        }
      },
      {
        values: (({ DEFAULT: _3, ...colors }) => colors)(flattenColorPalette_default(theme("borderColor"))),
        type: ["color", "any"]
      }
    );
  },
  borderOpacity: createUtilityPlugin("borderOpacity", [
    ["border-opacity", ["--tw-border-opacity"]]
  ]),
  backgroundColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        bg: (value2) => {
          if (!corePlugins2("backgroundOpacity")) {
            return {
              "background-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "background-color",
            variable: "--tw-bg-opacity"
          });
        }
      },
      { values: flattenColorPalette_default(theme("backgroundColor")), type: ["color", "any"] }
    );
  },
  backgroundOpacity: createUtilityPlugin("backgroundOpacity", [
    ["bg-opacity", ["--tw-bg-opacity"]]
  ]),
  backgroundImage: createUtilityPlugin("backgroundImage", [["bg", ["background-image"]]], {
    type: ["lookup", "image", "url"]
  }),
  gradientColorStops: /* @__PURE__ */ (() => {
    function transparentTo(value2) {
      return withAlphaValue(value2, 0, "rgb(255 255 255 / 0)");
    }
    return function({ matchUtilities, theme }) {
      let options = {
        values: flattenColorPalette_default(theme("gradientColorStops")),
        type: ["color", "any"]
      };
      let positionOptions = {
        values: theme("gradientColorStopPositions"),
        type: ["length", "percentage"]
      };
      matchUtilities(
        {
          from: (value2) => {
            let transparentToValue = transparentTo(value2);
            return {
              "--tw-gradient-from": `${toColorValue(
                value2,
                "from"
              )} var(--tw-gradient-from-position)`,
              "--tw-gradient-from-position": " ",
              "--tw-gradient-to": `${transparentToValue}  var(--tw-gradient-from-position)`,
              "--tw-gradient-to-position": " ",
              "--tw-gradient-stops": `var(--tw-gradient-from), var(--tw-gradient-to)`
            };
          }
        },
        options
      );
      matchUtilities(
        {
          from: (value2) => {
            return {
              "--tw-gradient-from-position": value2
            };
          }
        },
        positionOptions
      );
      matchUtilities(
        {
          via: (value2) => {
            let transparentToValue = transparentTo(value2);
            return {
              "--tw-gradient-via-position": " ",
              "--tw-gradient-to": `${transparentToValue}  var(--tw-gradient-to-position)`,
              "--tw-gradient-to-position": " ",
              "--tw-gradient-stops": `var(--tw-gradient-from), ${toColorValue(
                value2,
                "via"
              )} var(--tw-gradient-via-position), var(--tw-gradient-to)`
            };
          }
        },
        options
      );
      matchUtilities(
        {
          via: (value2) => {
            return {
              "--tw-gradient-via-position": value2
            };
          }
        },
        positionOptions
      );
      matchUtilities(
        {
          to: (value2) => ({
            "--tw-gradient-to": `${toColorValue(value2, "to")} var(--tw-gradient-to-position)`,
            "--tw-gradient-to-position": " "
          })
        },
        options
      );
      matchUtilities(
        {
          to: (value2) => {
            return {
              "--tw-gradient-to-position": value2
            };
          }
        },
        positionOptions
      );
    };
  })(),
  boxDecorationBreak: ({ addUtilities }) => {
    addUtilities({
      ".decoration-slice": { "box-decoration-break": "slice" },
      ".decoration-clone": { "box-decoration-break": "clone" },
      ".box-decoration-slice": { "box-decoration-break": "slice" },
      ".box-decoration-clone": { "box-decoration-break": "clone" }
    });
  },
  backgroundSize: createUtilityPlugin("backgroundSize", [["bg", ["background-size"]]], {
    type: ["lookup", "length", "percentage", "size"]
  }),
  backgroundAttachment: ({ addUtilities }) => {
    addUtilities({
      ".bg-fixed": { "background-attachment": "fixed" },
      ".bg-local": { "background-attachment": "local" },
      ".bg-scroll": { "background-attachment": "scroll" }
    });
  },
  backgroundClip: ({ addUtilities }) => {
    addUtilities({
      ".bg-clip-border": { "background-clip": "border-box" },
      ".bg-clip-padding": { "background-clip": "padding-box" },
      ".bg-clip-content": { "background-clip": "content-box" },
      ".bg-clip-text": { "background-clip": "text" }
    });
  },
  backgroundPosition: createUtilityPlugin("backgroundPosition", [["bg", ["background-position"]]], {
    type: ["lookup", ["position", { preferOnConflict: true }]]
  }),
  backgroundRepeat: ({ addUtilities }) => {
    addUtilities({
      ".bg-repeat": { "background-repeat": "repeat" },
      ".bg-no-repeat": { "background-repeat": "no-repeat" },
      ".bg-repeat-x": { "background-repeat": "repeat-x" },
      ".bg-repeat-y": { "background-repeat": "repeat-y" },
      ".bg-repeat-round": { "background-repeat": "round" },
      ".bg-repeat-space": { "background-repeat": "space" }
    });
  },
  backgroundOrigin: ({ addUtilities }) => {
    addUtilities({
      ".bg-origin-border": { "background-origin": "border-box" },
      ".bg-origin-padding": { "background-origin": "padding-box" },
      ".bg-origin-content": { "background-origin": "content-box" }
    });
  },
  fill: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        fill: (value2) => {
          return { fill: toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("fill")), type: ["color", "any"] }
    );
  },
  stroke: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        stroke: (value2) => {
          return { stroke: toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("stroke")), type: ["color", "url", "any"] }
    );
  },
  strokeWidth: createUtilityPlugin("strokeWidth", [["stroke", ["stroke-width"]]], {
    type: ["length", "number", "percentage"]
  }),
  objectFit: ({ addUtilities }) => {
    addUtilities({
      ".object-contain": { "object-fit": "contain" },
      ".object-cover": { "object-fit": "cover" },
      ".object-fill": { "object-fit": "fill" },
      ".object-none": { "object-fit": "none" },
      ".object-scale-down": { "object-fit": "scale-down" }
    });
  },
  objectPosition: createUtilityPlugin("objectPosition", [["object", ["object-position"]]]),
  padding: createUtilityPlugin("padding", [
    ["p", ["padding"]],
    [
      ["px", ["padding-left", "padding-right"]],
      ["py", ["padding-top", "padding-bottom"]]
    ],
    [
      ["ps", ["padding-inline-start"]],
      ["pe", ["padding-inline-end"]],
      ["pt", ["padding-top"]],
      ["pr", ["padding-right"]],
      ["pb", ["padding-bottom"]],
      ["pl", ["padding-left"]]
    ]
  ]),
  textAlign: ({ addUtilities }) => {
    addUtilities({
      ".text-left": { "text-align": "left" },
      ".text-center": { "text-align": "center" },
      ".text-right": { "text-align": "right" },
      ".text-justify": { "text-align": "justify" },
      ".text-start": { "text-align": "start" },
      ".text-end": { "text-align": "end" }
    });
  },
  textIndent: createUtilityPlugin("textIndent", [["indent", ["text-indent"]]], {
    supportsNegativeValues: true
  }),
  verticalAlign: ({ addUtilities, matchUtilities }) => {
    addUtilities({
      ".align-baseline": { "vertical-align": "baseline" },
      ".align-top": { "vertical-align": "top" },
      ".align-middle": { "vertical-align": "middle" },
      ".align-bottom": { "vertical-align": "bottom" },
      ".align-text-top": { "vertical-align": "text-top" },
      ".align-text-bottom": { "vertical-align": "text-bottom" },
      ".align-sub": { "vertical-align": "sub" },
      ".align-super": { "vertical-align": "super" }
    });
    matchUtilities({ align: (value2) => ({ "vertical-align": value2 }) });
  },
  fontFamily: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        font: (value2) => {
          let [families, options = {}] = Array.isArray(value2) && isPlainObject(value2[1]) ? value2 : [value2];
          let { fontFeatureSettings, fontVariationSettings } = options;
          return {
            "font-family": Array.isArray(families) ? families.join(", ") : families,
            ...fontFeatureSettings === void 0 ? {} : { "font-feature-settings": fontFeatureSettings },
            ...fontVariationSettings === void 0 ? {} : { "font-variation-settings": fontVariationSettings }
          };
        }
      },
      {
        values: theme("fontFamily"),
        type: ["lookup", "generic-name", "family-name"]
      }
    );
  },
  fontSize: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        text: (value2, { modifier }) => {
          let [fontSize, options] = Array.isArray(value2) ? value2 : [value2];
          if (modifier) {
            return {
              "font-size": fontSize,
              "line-height": modifier
            };
          }
          let { lineHeight, letterSpacing, fontWeight } = isPlainObject(options) ? options : { lineHeight: options };
          return {
            "font-size": fontSize,
            ...lineHeight === void 0 ? {} : { "line-height": lineHeight },
            ...letterSpacing === void 0 ? {} : { "letter-spacing": letterSpacing },
            ...fontWeight === void 0 ? {} : { "font-weight": fontWeight }
          };
        }
      },
      {
        values: theme("fontSize"),
        modifiers: theme("lineHeight"),
        type: ["absolute-size", "relative-size", "length", "percentage"]
      }
    );
  },
  fontWeight: createUtilityPlugin("fontWeight", [["font", ["fontWeight"]]], {
    type: ["lookup", "number", "any"]
  }),
  textTransform: ({ addUtilities }) => {
    addUtilities({
      ".uppercase": { "text-transform": "uppercase" },
      ".lowercase": { "text-transform": "lowercase" },
      ".capitalize": { "text-transform": "capitalize" },
      ".normal-case": { "text-transform": "none" }
    });
  },
  fontStyle: ({ addUtilities }) => {
    addUtilities({
      ".italic": { "font-style": "italic" },
      ".not-italic": { "font-style": "normal" }
    });
  },
  fontVariantNumeric: ({ addDefaults, addUtilities }) => {
    let cssFontVariantNumericValue = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
    addDefaults("font-variant-numeric", {
      "--tw-ordinal": " ",
      "--tw-slashed-zero": " ",
      "--tw-numeric-figure": " ",
      "--tw-numeric-spacing": " ",
      "--tw-numeric-fraction": " "
    });
    addUtilities({
      ".normal-nums": { "font-variant-numeric": "normal" },
      ".ordinal": {
        "@defaults font-variant-numeric": {},
        "--tw-ordinal": "ordinal",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".slashed-zero": {
        "@defaults font-variant-numeric": {},
        "--tw-slashed-zero": "slashed-zero",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".lining-nums": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-figure": "lining-nums",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".oldstyle-nums": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-figure": "oldstyle-nums",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".proportional-nums": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-spacing": "proportional-nums",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".tabular-nums": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-spacing": "tabular-nums",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".diagonal-fractions": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-fraction": "diagonal-fractions",
        "font-variant-numeric": cssFontVariantNumericValue
      },
      ".stacked-fractions": {
        "@defaults font-variant-numeric": {},
        "--tw-numeric-fraction": "stacked-fractions",
        "font-variant-numeric": cssFontVariantNumericValue
      }
    });
  },
  lineHeight: createUtilityPlugin("lineHeight", [["leading", ["lineHeight"]]]),
  letterSpacing: createUtilityPlugin("letterSpacing", [["tracking", ["letterSpacing"]]], {
    supportsNegativeValues: true
  }),
  textColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        text: (value2) => {
          if (!corePlugins2("textOpacity")) {
            return { color: toColorValue(value2) };
          }
          return withAlphaVariable({
            color: value2,
            property: "color",
            variable: "--tw-text-opacity"
          });
        }
      },
      { values: flattenColorPalette_default(theme("textColor")), type: ["color", "any"] }
    );
  },
  textOpacity: createUtilityPlugin("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]),
  textDecoration: ({ addUtilities }) => {
    addUtilities({
      ".underline": { "text-decoration-line": "underline" },
      ".overline": { "text-decoration-line": "overline" },
      ".line-through": { "text-decoration-line": "line-through" },
      ".no-underline": { "text-decoration-line": "none" }
    });
  },
  textDecorationColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        decoration: (value2) => {
          return { "text-decoration-color": toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("textDecorationColor")), type: ["color", "any"] }
    );
  },
  textDecorationStyle: ({ addUtilities }) => {
    addUtilities({
      ".decoration-solid": { "text-decoration-style": "solid" },
      ".decoration-double": { "text-decoration-style": "double" },
      ".decoration-dotted": { "text-decoration-style": "dotted" },
      ".decoration-dashed": { "text-decoration-style": "dashed" },
      ".decoration-wavy": { "text-decoration-style": "wavy" }
    });
  },
  textDecorationThickness: createUtilityPlugin(
    "textDecorationThickness",
    [["decoration", ["text-decoration-thickness"]]],
    { type: ["length", "percentage"] }
  ),
  textUnderlineOffset: createUtilityPlugin(
    "textUnderlineOffset",
    [["underline-offset", ["text-underline-offset"]]],
    { type: ["length", "percentage", "any"] }
  ),
  fontSmoothing: ({ addUtilities }) => {
    addUtilities({
      ".antialiased": {
        "-webkit-font-smoothing": "antialiased",
        "-moz-osx-font-smoothing": "grayscale"
      },
      ".subpixel-antialiased": {
        "-webkit-font-smoothing": "auto",
        "-moz-osx-font-smoothing": "auto"
      }
    });
  },
  placeholderColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        placeholder: (value2) => {
          if (!corePlugins2("placeholderOpacity")) {
            return {
              "&::placeholder": {
                color: toColorValue(value2)
              }
            };
          }
          return {
            "&::placeholder": withAlphaVariable({
              color: value2,
              property: "color",
              variable: "--tw-placeholder-opacity"
            })
          };
        }
      },
      { values: flattenColorPalette_default(theme("placeholderColor")), type: ["color", "any"] }
    );
  },
  placeholderOpacity: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "placeholder-opacity": (value2) => {
          return { ["&::placeholder"]: { "--tw-placeholder-opacity": value2 } };
        }
      },
      { values: theme("placeholderOpacity") }
    );
  },
  caretColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        caret: (value2) => {
          return { "caret-color": toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("caretColor")), type: ["color", "any"] }
    );
  },
  accentColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        accent: (value2) => {
          return { "accent-color": toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("accentColor")), type: ["color", "any"] }
    );
  },
  opacity: createUtilityPlugin("opacity", [["opacity", ["opacity"]]]),
  backgroundBlendMode: ({ addUtilities }) => {
    addUtilities({
      ".bg-blend-normal": { "background-blend-mode": "normal" },
      ".bg-blend-multiply": { "background-blend-mode": "multiply" },
      ".bg-blend-screen": { "background-blend-mode": "screen" },
      ".bg-blend-overlay": { "background-blend-mode": "overlay" },
      ".bg-blend-darken": { "background-blend-mode": "darken" },
      ".bg-blend-lighten": { "background-blend-mode": "lighten" },
      ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" },
      ".bg-blend-color-burn": { "background-blend-mode": "color-burn" },
      ".bg-blend-hard-light": { "background-blend-mode": "hard-light" },
      ".bg-blend-soft-light": { "background-blend-mode": "soft-light" },
      ".bg-blend-difference": { "background-blend-mode": "difference" },
      ".bg-blend-exclusion": { "background-blend-mode": "exclusion" },
      ".bg-blend-hue": { "background-blend-mode": "hue" },
      ".bg-blend-saturation": { "background-blend-mode": "saturation" },
      ".bg-blend-color": { "background-blend-mode": "color" },
      ".bg-blend-luminosity": { "background-blend-mode": "luminosity" }
    });
  },
  mixBlendMode: ({ addUtilities }) => {
    addUtilities({
      ".mix-blend-normal": { "mix-blend-mode": "normal" },
      ".mix-blend-multiply": { "mix-blend-mode": "multiply" },
      ".mix-blend-screen": { "mix-blend-mode": "screen" },
      ".mix-blend-overlay": { "mix-blend-mode": "overlay" },
      ".mix-blend-darken": { "mix-blend-mode": "darken" },
      ".mix-blend-lighten": { "mix-blend-mode": "lighten" },
      ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" },
      ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" },
      ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" },
      ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" },
      ".mix-blend-difference": { "mix-blend-mode": "difference" },
      ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" },
      ".mix-blend-hue": { "mix-blend-mode": "hue" },
      ".mix-blend-saturation": { "mix-blend-mode": "saturation" },
      ".mix-blend-color": { "mix-blend-mode": "color" },
      ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" },
      ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" }
    });
  },
  boxShadow: (() => {
    let transformValue = transformThemeValue("boxShadow");
    let defaultBoxShadow = [
      `var(--tw-ring-offset-shadow, 0 0 #0000)`,
      `var(--tw-ring-shadow, 0 0 #0000)`,
      `var(--tw-shadow)`
    ].join(", ");
    return function({ matchUtilities, addDefaults, theme }) {
      addDefaults(" box-shadow", {
        "--tw-ring-offset-shadow": "0 0 #0000",
        "--tw-ring-shadow": "0 0 #0000",
        "--tw-shadow": "0 0 #0000",
        "--tw-shadow-colored": "0 0 #0000"
      });
      matchUtilities(
        {
          shadow: (value2) => {
            value2 = transformValue(value2);
            let ast = parseBoxShadowValue(value2);
            for (let shadow2 of ast) {
              if (!shadow2.valid) {
                continue;
              }
              shadow2.color = "var(--tw-shadow-color)";
            }
            return {
              "@defaults box-shadow": {},
              "--tw-shadow": value2 === "none" ? "0 0 #0000" : value2,
              "--tw-shadow-colored": value2 === "none" ? "0 0 #0000" : formatBoxShadowValue(ast),
              "box-shadow": defaultBoxShadow
            };
          }
        },
        { values: theme("boxShadow"), type: ["shadow"] }
      );
    };
  })(),
  boxShadowColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        shadow: (value2) => {
          return {
            "--tw-shadow-color": toColorValue(value2),
            "--tw-shadow": "var(--tw-shadow-colored)"
          };
        }
      },
      { values: flattenColorPalette_default(theme("boxShadowColor")), type: ["color", "any"] }
    );
  },
  outlineStyle: ({ addUtilities }) => {
    addUtilities({
      ".outline-none": {
        outline: "2px solid transparent",
        "outline-offset": "2px"
      },
      ".outline": { "outline-style": "solid" },
      ".outline-dashed": { "outline-style": "dashed" },
      ".outline-dotted": { "outline-style": "dotted" },
      ".outline-double": { "outline-style": "double" }
    });
  },
  outlineWidth: createUtilityPlugin("outlineWidth", [["outline", ["outline-width"]]], {
    type: ["length", "number", "percentage"]
  }),
  outlineOffset: createUtilityPlugin("outlineOffset", [["outline-offset", ["outline-offset"]]], {
    type: ["length", "number", "percentage", "any"],
    supportsNegativeValues: true
  }),
  outlineColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        outline: (value2) => {
          return { "outline-color": toColorValue(value2) };
        }
      },
      { values: flattenColorPalette_default(theme("outlineColor")), type: ["color", "any"] }
    );
  },
  ringWidth: ({ matchUtilities, addDefaults, addUtilities, theme, config }) => {
    let ringColorDefault = (() => {
      if (flagEnabled(config(), "respectDefaultRingColorOpacity")) {
        return theme("ringColor.DEFAULT");
      }
      let ringOpacityDefault = theme("ringOpacity.DEFAULT", "0.5");
      if (!theme("ringColor")?.DEFAULT) {
        return `rgb(147 197 253 / ${ringOpacityDefault})`;
      }
      return withAlphaValue(
        theme("ringColor")?.DEFAULT,
        ringOpacityDefault,
        `rgb(147 197 253 / ${ringOpacityDefault})`
      );
    })();
    addDefaults("ring-width", {
      "--tw-ring-inset": " ",
      "--tw-ring-offset-width": theme("ringOffsetWidth.DEFAULT", "0px"),
      "--tw-ring-offset-color": theme("ringOffsetColor.DEFAULT", "#fff"),
      "--tw-ring-color": ringColorDefault,
      "--tw-ring-offset-shadow": "0 0 #0000",
      "--tw-ring-shadow": "0 0 #0000",
      "--tw-shadow": "0 0 #0000",
      "--tw-shadow-colored": "0 0 #0000"
    });
    matchUtilities(
      {
        ring: (value2) => {
          return {
            "@defaults ring-width": {},
            "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
            "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${value2} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
            "box-shadow": [
              `var(--tw-ring-offset-shadow)`,
              `var(--tw-ring-shadow)`,
              `var(--tw-shadow, 0 0 #0000)`
            ].join(", ")
          };
        }
      },
      { values: theme("ringWidth"), type: "length" }
    );
    addUtilities({
      ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" }
    });
  },
  ringColor: ({ matchUtilities, theme, corePlugins: corePlugins2 }) => {
    matchUtilities(
      {
        ring: (value2) => {
          if (!corePlugins2("ringOpacity")) {
            return {
              "--tw-ring-color": toColorValue(value2)
            };
          }
          return withAlphaVariable({
            color: value2,
            property: "--tw-ring-color",
            variable: "--tw-ring-opacity"
          });
        }
      },
      {
        values: Object.fromEntries(
          Object.entries(flattenColorPalette_default(theme("ringColor"))).filter(
            ([modifier]) => modifier !== "DEFAULT"
          )
        ),
        type: ["color", "any"]
      }
    );
  },
  ringOpacity: (helpers) => {
    let { config } = helpers;
    return createUtilityPlugin("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], {
      filterDefault: !flagEnabled(config(), "respectDefaultRingColorOpacity")
    })(helpers);
  },
  ringOffsetWidth: createUtilityPlugin(
    "ringOffsetWidth",
    [["ring-offset", ["--tw-ring-offset-width"]]],
    { type: "length" }
  ),
  ringOffsetColor: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "ring-offset": (value2) => {
          return {
            "--tw-ring-offset-color": toColorValue(value2)
          };
        }
      },
      { values: flattenColorPalette_default(theme("ringOffsetColor")), type: ["color", "any"] }
    );
  },
  blur: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        blur: (value2) => {
          return {
            "--tw-blur": `blur(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("blur") }
    );
  },
  brightness: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        brightness: (value2) => {
          return {
            "--tw-brightness": `brightness(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("brightness") }
    );
  },
  contrast: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        contrast: (value2) => {
          return {
            "--tw-contrast": `contrast(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("contrast") }
    );
  },
  dropShadow: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "drop-shadow": (value2) => {
          return {
            "--tw-drop-shadow": Array.isArray(value2) ? value2.map((v2) => `drop-shadow(${v2})`).join(" ") : `drop-shadow(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("dropShadow") }
    );
  },
  grayscale: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        grayscale: (value2) => {
          return {
            "--tw-grayscale": `grayscale(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("grayscale") }
    );
  },
  hueRotate: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "hue-rotate": (value2) => {
          return {
            "--tw-hue-rotate": `hue-rotate(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("hueRotate"), supportsNegativeValues: true }
    );
  },
  invert: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        invert: (value2) => {
          return {
            "--tw-invert": `invert(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("invert") }
    );
  },
  saturate: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        saturate: (value2) => {
          return {
            "--tw-saturate": `saturate(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("saturate") }
    );
  },
  sepia: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        sepia: (value2) => {
          return {
            "--tw-sepia": `sepia(${value2})`,
            "@defaults filter": {},
            filter: cssFilterValue
          };
        }
      },
      { values: theme("sepia") }
    );
  },
  filter: ({ addDefaults, addUtilities }) => {
    addDefaults("filter", {
      "--tw-blur": " ",
      "--tw-brightness": " ",
      "--tw-contrast": " ",
      "--tw-grayscale": " ",
      "--tw-hue-rotate": " ",
      "--tw-invert": " ",
      "--tw-saturate": " ",
      "--tw-sepia": " ",
      "--tw-drop-shadow": " "
    });
    addUtilities({
      ".filter": { "@defaults filter": {}, filter: cssFilterValue },
      ".filter-none": { filter: "none" }
    });
  },
  backdropBlur: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-blur": (value2) => {
          return {
            "--tw-backdrop-blur": `blur(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropBlur") }
    );
  },
  backdropBrightness: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-brightness": (value2) => {
          return {
            "--tw-backdrop-brightness": `brightness(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropBrightness") }
    );
  },
  backdropContrast: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-contrast": (value2) => {
          return {
            "--tw-backdrop-contrast": `contrast(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropContrast") }
    );
  },
  backdropGrayscale: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-grayscale": (value2) => {
          return {
            "--tw-backdrop-grayscale": `grayscale(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropGrayscale") }
    );
  },
  backdropHueRotate: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-hue-rotate": (value2) => {
          return {
            "--tw-backdrop-hue-rotate": `hue-rotate(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropHueRotate"), supportsNegativeValues: true }
    );
  },
  backdropInvert: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-invert": (value2) => {
          return {
            "--tw-backdrop-invert": `invert(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropInvert") }
    );
  },
  backdropOpacity: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-opacity": (value2) => {
          return {
            "--tw-backdrop-opacity": `opacity(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropOpacity") }
    );
  },
  backdropSaturate: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-saturate": (value2) => {
          return {
            "--tw-backdrop-saturate": `saturate(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropSaturate") }
    );
  },
  backdropSepia: ({ matchUtilities, theme }) => {
    matchUtilities(
      {
        "backdrop-sepia": (value2) => {
          return {
            "--tw-backdrop-sepia": `sepia(${value2})`,
            "@defaults backdrop-filter": {},
            "backdrop-filter": cssBackdropFilterValue
          };
        }
      },
      { values: theme("backdropSepia") }
    );
  },
  backdropFilter: ({ addDefaults, addUtilities }) => {
    addDefaults("backdrop-filter", {
      "--tw-backdrop-blur": " ",
      "--tw-backdrop-brightness": " ",
      "--tw-backdrop-contrast": " ",
      "--tw-backdrop-grayscale": " ",
      "--tw-backdrop-hue-rotate": " ",
      "--tw-backdrop-invert": " ",
      "--tw-backdrop-opacity": " ",
      "--tw-backdrop-saturate": " ",
      "--tw-backdrop-sepia": " "
    });
    addUtilities({
      ".backdrop-filter": {
        "@defaults backdrop-filter": {},
        "backdrop-filter": cssBackdropFilterValue
      },
      ".backdrop-filter-none": { "backdrop-filter": "none" }
    });
  },
  transitionProperty: ({ matchUtilities, theme }) => {
    let defaultTimingFunction = theme("transitionTimingFunction.DEFAULT");
    let defaultDuration = theme("transitionDuration.DEFAULT");
    matchUtilities(
      {
        transition: (value2) => {
          return {
            "transition-property": value2,
            ...value2 === "none" ? {} : {
              "transition-timing-function": defaultTimingFunction,
              "transition-duration": defaultDuration
            }
          };
        }
      },
      { values: theme("transitionProperty") }
    );
  },
  transitionDelay: createUtilityPlugin("transitionDelay", [["delay", ["transitionDelay"]]]),
  transitionDuration: createUtilityPlugin(
    "transitionDuration",
    [["duration", ["transitionDuration"]]],
    { filterDefault: true }
  ),
  transitionTimingFunction: createUtilityPlugin(
    "transitionTimingFunction",
    [["ease", ["transitionTimingFunction"]]],
    { filterDefault: true }
  ),
  willChange: createUtilityPlugin("willChange", [["will-change", ["will-change"]]]),
  content: createUtilityPlugin("content", [
    ["content", ["--tw-content", ["content", "var(--tw-content)"]]]
  ])
};
function toPath(path) {
  if (Array.isArray(path))
    return path;
  let openBrackets = path.split("[").length - 1;
  let closedBrackets = path.split("]").length - 1;
  if (openBrackets !== closedBrackets) {
    throw new Error(`Path is invalid. Has unbalanced brackets: ${path}`);
  }
  return path.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
}
var matchingBrackets = /* @__PURE__ */ new Map([
  ["{", "}"],
  ["[", "]"],
  ["(", ")"]
]);
var inverseMatchingBrackets = new Map(
  Array.from(matchingBrackets.entries()).map(([k3, v2]) => [v2, k3])
);
var quotes = /* @__PURE__ */ new Set(['"', "'", "`"]);
function isSyntacticallyValidPropertyValue(value2) {
  let stack = [];
  let inQuotes = false;
  for (let i5 = 0; i5 < value2.length; i5++) {
    let char = value2[i5];
    if (char === ":" && !inQuotes && stack.length === 0) {
      return false;
    }
    if (quotes.has(char) && value2[i5 - 1] !== "\\") {
      inQuotes = !inQuotes;
    }
    if (inQuotes)
      continue;
    if (value2[i5 - 1] === "\\")
      continue;
    if (matchingBrackets.has(char)) {
      stack.push(char);
    } else if (inverseMatchingBrackets.has(char)) {
      let inverse = inverseMatchingBrackets.get(char);
      if (stack.length <= 0) {
        return false;
      }
      if (stack.pop() !== inverse) {
        return false;
      }
    }
  }
  if (stack.length > 0) {
    return false;
  }
  return true;
}
function bigSign(bigIntValue) {
  return (bigIntValue > 0n) - (bigIntValue < 0n);
}
function remapBitfield(num, mapping) {
  let oldMask = 0n;
  let newMask = 0n;
  for (let [oldBit, newBit] of mapping) {
    if (num & oldBit) {
      oldMask = oldMask | oldBit;
      newMask = newMask | newBit;
    }
  }
  return num & ~oldMask | newMask;
}
var Offsets = class {
  constructor() {
    this.offsets = {
      defaults: 0n,
      base: 0n,
      components: 0n,
      utilities: 0n,
      variants: 0n,
      user: 0n
    };
    this.layerPositions = {
      defaults: 0n,
      base: 1n,
      components: 2n,
      utilities: 3n,
      user: 4n,
      variants: 5n
    };
    this.reservedVariantBits = 0n;
    this.variantOffsets = /* @__PURE__ */ new Map();
  }
  create(layer) {
    return {
      layer,
      parentLayer: layer,
      arbitrary: 0n,
      variants: 0n,
      parallelIndex: 0n,
      index: this.offsets[layer]++,
      options: []
    };
  }
  arbitraryProperty() {
    return {
      ...this.create("utilities"),
      arbitrary: 1n
    };
  }
  forVariant(variant, index2 = 0) {
    let offset = this.variantOffsets.get(variant);
    if (offset === void 0) {
      throw new Error(`Cannot find offset for unknown variant ${variant}`);
    }
    return {
      ...this.create("variants"),
      variants: offset << BigInt(index2)
    };
  }
  applyVariantOffset(rule2, variant, options) {
    options.variant = variant.variants;
    return {
      ...rule2,
      layer: "variants",
      parentLayer: rule2.layer === "variants" ? rule2.parentLayer : rule2.layer,
      variants: rule2.variants | variant.variants,
      options: options.sort ? [].concat(options, rule2.options) : rule2.options,
      parallelIndex: max2([rule2.parallelIndex, variant.parallelIndex])
    };
  }
  applyParallelOffset(offset, parallelIndex) {
    return {
      ...offset,
      parallelIndex: BigInt(parallelIndex)
    };
  }
  recordVariants(variants, getLength) {
    for (let variant of variants) {
      this.recordVariant(variant, getLength(variant));
    }
  }
  recordVariant(variant, fnCount = 1) {
    this.variantOffsets.set(variant, 1n << this.reservedVariantBits);
    this.reservedVariantBits += BigInt(fnCount);
    return {
      ...this.create("variants"),
      variants: this.variantOffsets.get(variant)
    };
  }
  compare(a3, b3) {
    if (a3.layer !== b3.layer) {
      return this.layerPositions[a3.layer] - this.layerPositions[b3.layer];
    }
    if (a3.parentLayer !== b3.parentLayer) {
      return this.layerPositions[a3.parentLayer] - this.layerPositions[b3.parentLayer];
    }
    for (let aOptions of a3.options) {
      for (let bOptions of b3.options) {
        if (aOptions.id !== bOptions.id)
          continue;
        if (!aOptions.sort || !bOptions.sort)
          continue;
        let maxFnVariant = max2([aOptions.variant, bOptions.variant]) ?? 0n;
        let mask = ~(maxFnVariant | maxFnVariant - 1n);
        let aVariantsAfterFn = a3.variants & mask;
        let bVariantsAfterFn = b3.variants & mask;
        if (aVariantsAfterFn !== bVariantsAfterFn) {
          continue;
        }
        let result = aOptions.sort(
          {
            value: aOptions.value,
            modifier: aOptions.modifier
          },
          {
            value: bOptions.value,
            modifier: bOptions.modifier
          }
        );
        if (result !== 0)
          return result;
      }
    }
    if (a3.variants !== b3.variants) {
      return a3.variants - b3.variants;
    }
    if (a3.parallelIndex !== b3.parallelIndex) {
      return a3.parallelIndex - b3.parallelIndex;
    }
    if (a3.arbitrary !== b3.arbitrary) {
      return a3.arbitrary - b3.arbitrary;
    }
    return a3.index - b3.index;
  }
  recalculateVariantOffsets() {
    let variants = Array.from(this.variantOffsets.entries()).filter(([v2]) => v2.startsWith("[")).sort(([a3], [z3]) => fastCompare(a3, z3));
    let newOffsets = variants.map(([, offset]) => offset).sort((a3, z3) => bigSign(a3 - z3));
    let mapping = variants.map(([, oldOffset], i5) => [oldOffset, newOffsets[i5]]);
    return mapping.filter(([a3, z3]) => a3 !== z3);
  }
  remapArbitraryVariantOffsets(list22) {
    let mapping = this.recalculateVariantOffsets();
    if (mapping.length === 0) {
      return list22;
    }
    return list22.map((item) => {
      let [offset, rule2] = item;
      offset = {
        ...offset,
        variants: remapBitfield(offset.variants, mapping)
      };
      return [offset, rule2];
    });
  }
  sort(list22) {
    list22 = this.remapArbitraryVariantOffsets(list22);
    return list22.sort(([a3], [b3]) => bigSign(this.compare(a3, b3)));
  }
};
function max2(nums) {
  let max22 = null;
  for (const num of nums) {
    max22 = max22 ?? num;
    max22 = max22 > num ? max22 : num;
  }
  return max22;
}
function fastCompare(a3, b3) {
  let aLen = a3.length;
  let bLen = b3.length;
  let minLen = aLen < bLen ? aLen : bLen;
  for (let i5 = 0; i5 < minLen; i5++) {
    let cmp = a3.charCodeAt(i5) - b3.charCodeAt(i5);
    if (cmp !== 0)
      return cmp;
  }
  return aLen - bLen;
}
var VARIANT_TYPES = {
  AddVariant: Symbol.for("ADD_VARIANT"),
  MatchVariant: Symbol.for("MATCH_VARIANT")
};
var VARIANT_INFO = {
  Base: 1 << 0,
  Dynamic: 1 << 1
};
function prefix(context, selector) {
  let prefix3 = context.tailwindConfig.prefix;
  return typeof prefix3 === "function" ? prefix3(selector) : prefix3 + selector;
}
function normalizeOptionTypes({ type = "any", ...options }) {
  let types2 = [].concat(type);
  return {
    ...options,
    types: types2.map((type2) => {
      if (Array.isArray(type2)) {
        return { type: type2[0], ...type2[1] };
      }
      return { type: type2, preferOnConflict: false };
    })
  };
}
function parseVariantFormatString(input) {
  let parts = [];
  let current = "";
  let depth = 0;
  for (let idx = 0; idx < input.length; idx++) {
    let char = input[idx];
    if (char === "\\") {
      current += "\\" + input[++idx];
    } else if (char === "{") {
      ++depth;
      parts.push(current.trim());
      current = "";
    } else if (char === "}") {
      if (--depth < 0) {
        throw new Error(`Your { and } are unbalanced.`);
      }
      parts.push(current.trim());
      current = "";
    } else {
      current += char;
    }
  }
  if (current.length > 0) {
    parts.push(current.trim());
  }
  parts = parts.filter((part) => part !== "");
  return parts;
}
function insertInto(list22, value2, { before = [] } = {}) {
  before = [].concat(before);
  if (before.length <= 0) {
    list22.push(value2);
    return;
  }
  let idx = list22.length - 1;
  for (let other of before) {
    let iidx = list22.indexOf(other);
    if (iidx === -1)
      continue;
    idx = Math.min(idx, iidx);
  }
  list22.splice(idx, 0, value2);
}
function parseStyles(styles) {
  if (!Array.isArray(styles)) {
    return parseStyles([styles]);
  }
  return styles.flatMap((style) => {
    let isNode = !Array.isArray(style) && !isPlainObject(style);
    return isNode ? style : parseObjectStyles(style);
  });
}
function getClasses(selector, mutate) {
  let parser4 = (0, import_postcss_selector_parser5.default)((selectors) => {
    let allClasses = [];
    if (mutate) {
      mutate(selectors);
    }
    selectors.walkClasses((classNode) => {
      allClasses.push(classNode.value);
    });
    return allClasses;
  });
  return parser4.transformSync(selector);
}
function extractCandidates(node, state = { containsNonOnDemandable: false }, depth = 0) {
  let classes = [];
  if (node.type === "rule") {
    let ignoreNot = function(selectors) {
      selectors.walkPseudos((pseudo) => {
        if (pseudo.value === ":not") {
          pseudo.remove();
        }
      });
    };
    for (let selector of node.selectors) {
      let classCandidates = getClasses(selector, ignoreNot);
      if (classCandidates.length === 0) {
        state.containsNonOnDemandable = true;
      }
      for (let classCandidate of classCandidates) {
        classes.push(classCandidate);
      }
    }
  } else if (node.type === "atrule") {
    node.walkRules((rule2) => {
      for (let classCandidate of rule2.selectors.flatMap((selector) => getClasses(selector))) {
        classes.push(classCandidate);
      }
    });
  }
  if (depth === 0) {
    return [state.containsNonOnDemandable || classes.length === 0, classes];
  }
  return classes;
}
function withIdentifiers(styles) {
  return parseStyles(styles).flatMap((node) => {
    let nodeMap = /* @__PURE__ */ new Map();
    let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);
    if (containsNonOnDemandableSelectors) {
      candidates.unshift(NOT_ON_DEMAND);
    }
    return candidates.map((c2) => {
      if (!nodeMap.has(node)) {
        nodeMap.set(node, node);
      }
      return [c2, nodeMap.get(node)];
    });
  });
}
function isValidVariantFormatString(format2) {
  return format2.startsWith("@") || format2.includes("&");
}
function parseVariant(variant) {
  variant = variant.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
  let fns = parseVariantFormatString(variant).map((str) => {
    if (!str.startsWith("@")) {
      return ({ format: format2 }) => format2(str);
    }
    let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);
    return ({ wrap }) => wrap(postcss_default.atRule({ name, params: params.trim() }));
  }).reverse();
  return (api3) => {
    for (let fn of fns) {
      fn(api3);
    }
  };
}
function buildPluginApi(tailwindConfig, context, { variantList, variantMap, offsets, classList }) {
  function getConfigValue(path, defaultValue) {
    return path ? (0, import_dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;
  }
  function applyConfiguredPrefix(selector) {
    return prefixSelector_default(tailwindConfig.prefix, selector);
  }
  function prefixIdentifier(identifier, options) {
    if (identifier === NOT_ON_DEMAND) {
      return NOT_ON_DEMAND;
    }
    if (!options.respectPrefix) {
      return identifier;
    }
    return context.tailwindConfig.prefix + identifier;
  }
  function resolveThemeValue(path, defaultValue, opts = {}) {
    let parts = toPath(path);
    let value2 = getConfigValue(["theme", ...parts], defaultValue);
    return transformThemeValue(parts[0])(value2, opts);
  }
  let variantIdentifier = 0;
  let api3 = {
    postcss: postcss_default,
    prefix: applyConfiguredPrefix,
    e: escapeClassName,
    config: getConfigValue,
    theme: resolveThemeValue,
    corePlugins: (path) => {
      if (Array.isArray(tailwindConfig.corePlugins)) {
        return tailwindConfig.corePlugins.includes(path);
      }
      return getConfigValue(["corePlugins", path], true);
    },
    variants: () => {
      return [];
    },
    addBase(base) {
      for (let [identifier, rule2] of withIdentifiers(base)) {
        let prefixedIdentifier = prefixIdentifier(identifier, {});
        let offset = offsets.create("base");
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offset, layer: "base" }, rule2]);
      }
    },
    addDefaults(group, declarations) {
      const groups = {
        [`@defaults ${group}`]: declarations
      };
      for (let [identifier, rule2] of withIdentifiers(groups)) {
        let prefixedIdentifier = prefixIdentifier(identifier, {});
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("defaults"), layer: "defaults" }, rule2]);
      }
    },
    addComponents(components, options) {
      let defaultOptions = {
        preserveSource: false,
        respectPrefix: true,
        respectImportant: false
      };
      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
      for (let [identifier, rule2] of withIdentifiers(components)) {
        let prefixedIdentifier = prefixIdentifier(identifier, options);
        classList.add(prefixedIdentifier);
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("components"), layer: "components", options }, rule2]);
      }
    },
    addUtilities(utilities, options) {
      let defaultOptions = {
        preserveSource: false,
        respectPrefix: true,
        respectImportant: true
      };
      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
      for (let [identifier, rule2] of withIdentifiers(utilities)) {
        let prefixedIdentifier = prefixIdentifier(identifier, options);
        classList.add(prefixedIdentifier);
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push([{ sort: offsets.create("utilities"), layer: "utilities", options }, rule2]);
      }
    },
    matchUtilities: function(utilities, options) {
      let defaultOptions = {
        respectPrefix: true,
        respectImportant: true,
        modifiers: false
      };
      options = normalizeOptionTypes({ ...defaultOptions, ...options });
      let offset = offsets.create("utilities");
      for (let identifier in utilities) {
        let wrapped = function(modifier, { isOnlyPlugin }) {
          let [value2, coercedType, utilityModifier] = coerceValue(
            options.types,
            modifier,
            options,
            tailwindConfig
          );
          if (value2 === void 0) {
            return [];
          }
          if (!options.types.some(({ type }) => type === coercedType)) {
            if (isOnlyPlugin) {
              log_default.warn([
                `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                `You can safely update it to \`${identifier}-${modifier.replace(
                  coercedType + ":",
                  ""
                )}\`.`
              ]);
            } else {
              return [];
            }
          }
          if (!isSyntacticallyValidPropertyValue(value2)) {
            return [];
          }
          let extras = {
            get modifier() {
              if (!options.modifiers) {
                log_default.warn(`modifier-used-without-options-for-${identifier}`, [
                  "Your plugin must set `modifiers: true` in its options to support modifiers."
                ]);
              }
              return utilityModifier;
            }
          };
          let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
          let ruleSets = [].concat(modifiersEnabled ? rule2(value2, extras) : rule2(value2)).filter(Boolean).map((declaration) => ({
            [nameClass(identifier, modifier)]: declaration
          }));
          return ruleSets;
        };
        let prefixedIdentifier = prefixIdentifier(identifier, options);
        let rule2 = utilities[identifier];
        classList.add([prefixedIdentifier, options]);
        let withOffsets = [{ sort: offset, layer: "utilities", options }, wrapped];
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
      }
    },
    matchComponents: function(components, options) {
      let defaultOptions = {
        respectPrefix: true,
        respectImportant: false,
        modifiers: false
      };
      options = normalizeOptionTypes({ ...defaultOptions, ...options });
      let offset = offsets.create("components");
      for (let identifier in components) {
        let wrapped = function(modifier, { isOnlyPlugin }) {
          let [value2, coercedType, utilityModifier] = coerceValue(
            options.types,
            modifier,
            options,
            tailwindConfig
          );
          if (value2 === void 0) {
            return [];
          }
          if (!options.types.some(({ type }) => type === coercedType)) {
            if (isOnlyPlugin) {
              log_default.warn([
                `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                `You can safely update it to \`${identifier}-${modifier.replace(
                  coercedType + ":",
                  ""
                )}\`.`
              ]);
            } else {
              return [];
            }
          }
          if (!isSyntacticallyValidPropertyValue(value2)) {
            return [];
          }
          let extras = {
            get modifier() {
              if (!options.modifiers) {
                log_default.warn(`modifier-used-without-options-for-${identifier}`, [
                  "Your plugin must set `modifiers: true` in its options to support modifiers."
                ]);
              }
              return utilityModifier;
            }
          };
          let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
          let ruleSets = [].concat(modifiersEnabled ? rule2(value2, extras) : rule2(value2)).filter(Boolean).map((declaration) => ({
            [nameClass(identifier, modifier)]: declaration
          }));
          return ruleSets;
        };
        let prefixedIdentifier = prefixIdentifier(identifier, options);
        let rule2 = components[identifier];
        classList.add([prefixedIdentifier, options]);
        let withOffsets = [{ sort: offset, layer: "components", options }, wrapped];
        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }
        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
      }
    },
    addVariant(variantName, variantFunctions, options = {}) {
      variantFunctions = [].concat(variantFunctions).map((variantFunction) => {
        if (typeof variantFunction !== "string") {
          return (api22 = {}) => {
            let { args, modifySelectors, container, separator, wrap, format: format2 } = api22;
            let result = variantFunction(
              Object.assign(
                { modifySelectors, container, separator },
                options.type === VARIANT_TYPES.MatchVariant && { args, wrap, format: format2 }
              )
            );
            if (typeof result === "string" && !isValidVariantFormatString(result)) {
              throw new Error(
                `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
              );
            }
            if (Array.isArray(result)) {
              return result.filter((variant) => typeof variant === "string").map((variant) => parseVariant(variant));
            }
            return result && typeof result === "string" && parseVariant(result)(api22);
          };
        }
        if (!isValidVariantFormatString(variantFunction)) {
          throw new Error(
            `Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`
          );
        }
        return parseVariant(variantFunction);
      });
      insertInto(variantList, variantName, options);
      variantMap.set(variantName, variantFunctions);
      context.variantOptions.set(variantName, options);
    },
    matchVariant(variant, variantFn, options) {
      let id = options?.id ?? ++variantIdentifier;
      let isSpecial = variant === "@";
      let modifiersEnabled = flagEnabled(tailwindConfig, "generalizedModifiers");
      for (let [key, value2] of Object.entries(options?.values ?? {})) {
        if (key === "DEFAULT")
          continue;
        api3.addVariant(
          isSpecial ? `${variant}${key}` : `${variant}-${key}`,
          ({ args, container }) => {
            return variantFn(
              value2,
              modifiersEnabled ? { modifier: args?.modifier, container } : { container }
            );
          },
          {
            ...options,
            value: value2,
            id,
            type: VARIANT_TYPES.MatchVariant,
            variantInfo: VARIANT_INFO.Base
          }
        );
      }
      let hasDefault = "DEFAULT" in (options?.values ?? {});
      api3.addVariant(
        variant,
        ({ args, container }) => {
          if (args?.value === NONE && !hasDefault) {
            return null;
          }
          return variantFn(
            args?.value === NONE ? options.values.DEFAULT : args?.value ?? (typeof args === "string" ? args : ""),
            modifiersEnabled ? { modifier: args?.modifier, container } : { container }
          );
        },
        {
          ...options,
          id,
          type: VARIANT_TYPES.MatchVariant,
          variantInfo: VARIANT_INFO.Dynamic
        }
      );
    }
  };
  return api3;
}
function extractVariantAtRules(node) {
  node.walkAtRules((atRule2) => {
    if (["responsive", "variants"].includes(atRule2.name)) {
      extractVariantAtRules(atRule2);
      atRule2.before(atRule2.nodes);
      atRule2.remove();
    }
  });
}
function collectLayerPlugins(root2) {
  let layerPlugins = [];
  root2.each((node) => {
    if (node.type === "atrule" && ["responsive", "variants"].includes(node.name)) {
      node.name = "layer";
      node.params = "utilities";
    }
  });
  root2.walkAtRules("layer", (layerRule) => {
    extractVariantAtRules(layerRule);
    if (layerRule.params === "base") {
      for (let node of layerRule.nodes) {
        layerPlugins.push(function({ addBase }) {
          addBase(node, { respectPrefix: false });
        });
      }
      layerRule.remove();
    } else if (layerRule.params === "components") {
      for (let node of layerRule.nodes) {
        layerPlugins.push(function({ addComponents }) {
          addComponents(node, { respectPrefix: false, preserveSource: true });
        });
      }
      layerRule.remove();
    } else if (layerRule.params === "utilities") {
      for (let node of layerRule.nodes) {
        layerPlugins.push(function({ addUtilities }) {
          addUtilities(node, { respectPrefix: false, preserveSource: true });
        });
      }
      layerRule.remove();
    }
  });
  return layerPlugins;
}
function resolvePlugins(context, root2) {
  let corePluginList = Object.entries({ ...variantPlugins, ...corePlugins }).map(([name, plugin2]) => {
    if (!context.tailwindConfig.corePlugins.includes(name)) {
      return null;
    }
    return plugin2;
  }).filter(Boolean);
  let userPlugins = context.tailwindConfig.plugins.map((plugin2) => {
    if (plugin2.__isOptionsFunction) {
      plugin2 = plugin2();
    }
    return typeof plugin2 === "function" ? plugin2 : plugin2.handler;
  });
  let layerPlugins = collectLayerPlugins(root2);
  let beforeVariants = [
    variantPlugins["pseudoElementVariants"],
    variantPlugins["pseudoClassVariants"],
    variantPlugins["ariaVariants"],
    variantPlugins["dataVariants"]
  ];
  let afterVariants = [
    variantPlugins["supportsVariants"],
    variantPlugins["directionVariants"],
    variantPlugins["reducedMotionVariants"],
    variantPlugins["prefersContrastVariants"],
    variantPlugins["darkVariants"],
    variantPlugins["printVariant"],
    variantPlugins["screenVariants"],
    variantPlugins["orientationVariants"]
  ];
  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];
}
function registerPlugins(plugins, context) {
  let variantList = [];
  let variantMap = /* @__PURE__ */ new Map();
  context.variantMap = variantMap;
  let offsets = new Offsets();
  context.offsets = offsets;
  let classList = /* @__PURE__ */ new Set();
  let pluginApi = buildPluginApi(context.tailwindConfig, context, {
    variantList,
    variantMap,
    offsets,
    classList
  });
  for (let plugin2 of plugins) {
    if (Array.isArray(plugin2)) {
      for (let pluginItem of plugin2) {
        pluginItem(pluginApi);
      }
    } else {
      plugin2?.(pluginApi);
    }
  }
  offsets.recordVariants(variantList, (variant) => variantMap.get(variant).length);
  for (let [variantName, variantFunctions] of variantMap.entries()) {
    context.variantMap.set(
      variantName,
      variantFunctions.map((variantFunction, idx) => [
        offsets.forVariant(variantName, idx),
        variantFunction
      ])
    );
  }
  let safelist = (context.tailwindConfig.safelist ?? []).filter(Boolean);
  if (safelist.length > 0) {
    let checks = [];
    for (let value2 of safelist) {
      if (typeof value2 === "string") {
        context.changedContent.push({ content: value2, extension: "html" });
        continue;
      }
      if (value2 instanceof RegExp) {
        log_default.warn("root-regex", [
          "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
          "Update your `safelist` configuration to eliminate this warning.",
          "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
        ]);
        continue;
      }
      checks.push(value2);
    }
    if (checks.length > 0) {
      let patternMatchingCount = /* @__PURE__ */ new Map();
      let prefixLength = context.tailwindConfig.prefix.length;
      let checkImportantUtils = checks.some((check) => check.pattern.source.includes("!"));
      for (let util2 of classList) {
        let utils = Array.isArray(util2) ? (() => {
          let [utilName, options] = util2;
          let values = Object.keys(options?.values ?? {});
          let classes = values.map((value2) => formatClass(utilName, value2));
          if (options?.supportsNegativeValues) {
            classes = [...classes, ...classes.map((cls) => "-" + cls)];
            classes = [
              ...classes,
              ...classes.map(
                (cls) => cls.slice(0, prefixLength) + "-" + cls.slice(prefixLength)
              )
            ];
          }
          if (options.types.some(({ type }) => type === "color")) {
            classes = [
              ...classes,
              ...classes.flatMap(
                (cls) => Object.keys(context.tailwindConfig.theme.opacity).map(
                  (opacity) => `${cls}/${opacity}`
                )
              )
            ];
          }
          if (checkImportantUtils && options?.respectImportant) {
            classes = [...classes, ...classes.map((cls) => "!" + cls)];
          }
          return classes;
        })() : [util2];
        for (let util22 of utils) {
          for (let { pattern: pattern2, variants = [] } of checks) {
            pattern2.lastIndex = 0;
            if (!patternMatchingCount.has(pattern2)) {
              patternMatchingCount.set(pattern2, 0);
            }
            if (!pattern2.test(util22))
              continue;
            patternMatchingCount.set(pattern2, patternMatchingCount.get(pattern2) + 1);
            context.changedContent.push({ content: util22, extension: "html" });
            for (let variant of variants) {
              context.changedContent.push({
                content: variant + context.tailwindConfig.separator + util22,
                extension: "html"
              });
            }
          }
        }
      }
      for (let [regex, count] of patternMatchingCount.entries()) {
        if (count !== 0)
          continue;
        log_default.warn([
          `The safelist pattern \`${regex}\` doesn't match any Tailwind CSS classes.`,
          "Fix this pattern or remove it from your `safelist` configuration.",
          "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
        ]);
      }
    }
  }
  let darkClassName = [].concat(context.tailwindConfig.darkMode ?? "media")[1] ?? "dark";
  let parasiteUtilities = [
    prefix(context, darkClassName),
    prefix(context, "group"),
    prefix(context, "peer")
  ];
  context.getClassOrder = function getClassOrder(classes) {
    let sorted = [...classes].sort((a3, z3) => {
      if (a3 === z3)
        return 0;
      if (a3 < z3)
        return -1;
      return 1;
    });
    let sortedClassNames = new Map(sorted.map((className) => [className, null]));
    let rules = generateRules(new Set(sorted), context);
    rules = context.offsets.sort(rules);
    let idx = BigInt(parasiteUtilities.length);
    for (const [, rule2] of rules) {
      sortedClassNames.set(rule2.raws.tailwind.candidate, idx++);
    }
    return classes.map((className) => {
      let order = sortedClassNames.get(className) ?? null;
      let parasiteIndex = parasiteUtilities.indexOf(className);
      if (order === null && parasiteIndex !== -1) {
        order = BigInt(parasiteIndex);
      }
      return [className, order];
    });
  };
  context.getClassList = function getClassList(options = {}) {
    let output = [];
    for (let util2 of classList) {
      if (Array.isArray(util2)) {
        let [utilName, utilOptions] = util2;
        let negativeClasses = [];
        let modifiers = Object.keys(utilOptions?.modifiers ?? {});
        if (utilOptions?.types?.some(({ type }) => type === "color")) {
          modifiers.push(...Object.keys(context.tailwindConfig.theme.opacity ?? {}));
        }
        let metadata = { modifiers };
        let includeMetadata = options.includeMetadata && modifiers.length > 0;
        for (let [key, value2] of Object.entries(utilOptions?.values ?? {})) {
          if (value2 == null) {
            continue;
          }
          let cls = formatClass(utilName, key);
          output.push(includeMetadata ? [cls, metadata] : cls);
          if (utilOptions?.supportsNegativeValues && negateValue(value2)) {
            let cls2 = formatClass(utilName, `-${key}`);
            negativeClasses.push(includeMetadata ? [cls2, metadata] : cls2);
          }
        }
        output.push(...negativeClasses);
      } else {
        output.push(util2);
      }
    }
    return output;
  };
  context.getVariants = function getVariants() {
    let result = [];
    for (let [name, options] of context.variantOptions.entries()) {
      if (options.variantInfo === VARIANT_INFO.Base)
        continue;
      result.push({
        name,
        isArbitrary: options.type === Symbol.for("MATCH_VARIANT"),
        values: Object.keys(options.values ?? {}),
        hasDash: name !== "@",
        selectors({ modifier, value: value2 } = {}) {
          let candidate = "__TAILWIND_PLACEHOLDER__";
          let rule2 = postcss_default.rule({ selector: `.${candidate}` });
          let container = postcss_default.root({ nodes: [rule2.clone()] });
          let before = container.toString();
          let fns = (context.variantMap.get(name) ?? []).flatMap(([_3, fn]) => fn);
          let formatStrings = [];
          for (let fn of fns) {
            let localFormatStrings = [];
            let api3 = {
              args: { modifier, value: options.values?.[value2] ?? value2 },
              separator: context.tailwindConfig.separator,
              modifySelectors(modifierFunction) {
                container.each((rule22) => {
                  if (rule22.type !== "rule") {
                    return;
                  }
                  rule22.selectors = rule22.selectors.map((selector) => {
                    return modifierFunction({
                      get className() {
                        return getClassNameFromSelector(selector);
                      },
                      selector
                    });
                  });
                });
                return container;
              },
              format(str) {
                localFormatStrings.push(str);
              },
              wrap(wrapper) {
                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);
              },
              container
            };
            let ruleWithVariant = fn(api3);
            if (localFormatStrings.length > 0) {
              formatStrings.push(localFormatStrings);
            }
            if (Array.isArray(ruleWithVariant)) {
              for (let variantFunction of ruleWithVariant) {
                localFormatStrings = [];
                variantFunction(api3);
                formatStrings.push(localFormatStrings);
              }
            }
          }
          let manualFormatStrings = [];
          let after = container.toString();
          if (before !== after) {
            container.walkRules((rule22) => {
              let modified = rule22.selector;
              let rebuiltBase = (0, import_postcss_selector_parser5.default)((selectors) => {
                selectors.walkClasses((classNode) => {
                  classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;
                });
              }).processSync(modified);
              manualFormatStrings.push(modified.replace(rebuiltBase, "&").replace(candidate, "&"));
            });
            container.walkAtRules((atrule) => {
              manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);
            });
          }
          let isArbitraryVariant = !(value2 in (options.values ?? {}));
          formatStrings = formatStrings.map(
            (format2) => format2.map((str) => ({
              format: str,
              isArbitraryVariant
            }))
          );
          manualFormatStrings = manualFormatStrings.map((format2) => ({
            format: format2,
            isArbitraryVariant
          }));
          let opts = {
            candidate,
            context
          };
          let result2 = formatStrings.map(
            (formats) => finalizeSelector(`.${candidate}`, formatVariantSelector(formats, opts), opts).replace(`.${candidate}`, "&").replace("{ & }", "").trim()
          );
          if (manualFormatStrings.length > 0) {
            result2.push(
              formatVariantSelector(manualFormatStrings, opts).toString().replace(`.${candidate}`, "&")
            );
          }
          return result2;
        }
      });
    }
    return result;
  };
}
function markInvalidUtilityCandidate(context, candidate) {
  if (!context.classCache.has(candidate)) {
    return;
  }
  context.notClassCache.add(candidate);
  context.classCache.delete(candidate);
  context.applyClassCache.delete(candidate);
  context.candidateRuleMap.delete(candidate);
  context.candidateRuleCache.delete(candidate);
  context.stylesheetCache = null;
}
function markInvalidUtilityNode(context, node) {
  let candidate = node.raws.tailwind.candidate;
  if (!candidate) {
    return;
  }
  for (const entry of context.ruleCache) {
    if (entry[1].raws.tailwind.candidate === candidate) {
      context.ruleCache.delete(entry);
    }
  }
  markInvalidUtilityCandidate(context, candidate);
}
function createContext(tailwindConfig, changedContent = [], root2 = postcss_default.root()) {
  let context = {
    disposables: [],
    ruleCache: /* @__PURE__ */ new Set(),
    candidateRuleCache: /* @__PURE__ */ new Map(),
    classCache: /* @__PURE__ */ new Map(),
    applyClassCache: /* @__PURE__ */ new Map(),
    notClassCache: new Set(tailwindConfig.blocklist ?? []),
    postCssNodeCache: /* @__PURE__ */ new Map(),
    candidateRuleMap: /* @__PURE__ */ new Map(),
    tailwindConfig,
    changedContent,
    variantMap: /* @__PURE__ */ new Map(),
    stylesheetCache: null,
    variantOptions: /* @__PURE__ */ new Map(),
    markInvalidUtilityCandidate: (candidate) => markInvalidUtilityCandidate(context, candidate),
    markInvalidUtilityNode: (node) => markInvalidUtilityNode(context, node)
  };
  let resolvedPlugins = resolvePlugins(context, root2);
  registerPlugins(resolvedPlugins, context);
  return context;
}
function applyImportantSelector(selector, important) {
  let matches2 = /^(.*?)(:before|:after|::[\w-]+)(\)*)$/g.exec(selector);
  if (!matches2)
    return `${important} ${wrapWithIs(selector)}`;
  let [, before, pseudo, brackets] = matches2;
  return `${important} ${wrapWithIs(before + brackets)}${pseudo}`;
}
function wrapWithIs(selector) {
  let parts = splitAtTopLevelOnly(selector, " ");
  if (parts.length === 1 && parts[0].startsWith(":is(") && parts[0].endsWith(")")) {
    return selector;
  }
  return `:is(${selector})`;
}
var classNameParser = (0, import_postcss_selector_parser.default)((selectors) => {
  return selectors.first.filter(({ type }) => type === "class").pop().value;
});
function getClassNameFromSelector(selector) {
  return classNameParser.transformSync(selector);
}
function* candidatePermutations(candidate) {
  let lastIndex = Infinity;
  while (lastIndex >= 0) {
    let dashIdx;
    let wasSlash = false;
    if (lastIndex === Infinity && candidate.endsWith("]")) {
      let bracketIdx = candidate.indexOf("[");
      if (candidate[bracketIdx - 1] === "-") {
        dashIdx = bracketIdx - 1;
      } else if (candidate[bracketIdx - 1] === "/") {
        dashIdx = bracketIdx - 1;
        wasSlash = true;
      } else {
        dashIdx = -1;
      }
    } else if (lastIndex === Infinity && candidate.includes("/")) {
      dashIdx = candidate.lastIndexOf("/");
      wasSlash = true;
    } else {
      dashIdx = candidate.lastIndexOf("-", lastIndex);
    }
    if (dashIdx < 0) {
      break;
    }
    let prefix3 = candidate.slice(0, dashIdx);
    let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);
    lastIndex = dashIdx - 1;
    if (prefix3 === "" || modifier === "/") {
      continue;
    }
    yield [prefix3, modifier];
  }
}
function applyPrefix(matches2, context) {
  if (matches2.length === 0 || context.tailwindConfig.prefix === "") {
    return matches2;
  }
  for (let match of matches2) {
    let [meta] = match;
    if (meta.options.respectPrefix) {
      let container = postcss_default.root({ nodes: [match[1].clone()] });
      let classCandidate = match[1].raws.tailwind.classCandidate;
      container.walkRules((r5) => {
        let shouldPrependNegative = classCandidate.startsWith("-");
        r5.selector = prefixSelector_default(
          context.tailwindConfig.prefix,
          r5.selector,
          shouldPrependNegative
        );
      });
      match[1] = container.nodes[0];
    }
  }
  return matches2;
}
function applyImportant(matches2, classCandidate) {
  if (matches2.length === 0) {
    return matches2;
  }
  let result = [];
  for (let [meta, rule2] of matches2) {
    let container = postcss_default.root({ nodes: [rule2.clone()] });
    container.walkRules((r5) => {
      let ast = (0, import_postcss_selector_parser.default)().astSync(r5.selector);
      ast.each((sel) => eliminateIrrelevantSelectors(sel, classCandidate));
      updateAllClasses(
        ast,
        (className) => className === classCandidate ? `!${className}` : className
      );
      r5.selector = ast.toString();
      r5.walkDecls((d3) => d3.important = true);
    });
    result.push([{ ...meta, important: true }, container.nodes[0]]);
  }
  return result;
}
function applyVariant(variant, matches2, context) {
  if (matches2.length === 0) {
    return matches2;
  }
  let args = { modifier: null, value: NONE };
  {
    let [baseVariant, ...modifiers] = splitAtTopLevelOnly(variant, "/");
    if (modifiers.length > 1) {
      baseVariant = baseVariant + "/" + modifiers.slice(0, -1).join("/");
      modifiers = modifiers.slice(-1);
    }
    if (modifiers.length && !context.variantMap.has(variant)) {
      variant = baseVariant;
      args.modifier = modifiers[0];
      if (!flagEnabled(context.tailwindConfig, "generalizedModifiers")) {
        return [];
      }
    }
  }
  if (variant.endsWith("]") && !variant.startsWith("[")) {
    let match = /(.)(-?)\[(.*)\]/g.exec(variant);
    if (match) {
      let [, char, seperator, value2] = match;
      if (char === "@" && seperator === "-")
        return [];
      if (char !== "@" && seperator === "")
        return [];
      variant = variant.replace(`${seperator}[${value2}]`, "");
      args.value = value2;
    }
  }
  if (isArbitraryValue2(variant) && !context.variantMap.has(variant)) {
    let sort = context.offsets.recordVariant(variant);
    let selector = normalize2(variant.slice(1, -1));
    let selectors = splitAtTopLevelOnly(selector, ",");
    if (selectors.length > 1) {
      return [];
    }
    if (!selectors.every(isValidVariantFormatString)) {
      return [];
    }
    let records = selectors.map((sel, idx) => [
      context.offsets.applyParallelOffset(sort, idx),
      parseVariant(sel.trim())
    ]);
    context.variantMap.set(variant, records);
  }
  if (context.variantMap.has(variant)) {
    let isArbitraryVariant = isArbitraryValue2(variant);
    let variantFunctionTuples = context.variantMap.get(variant).slice();
    let result = [];
    for (let [meta, rule2] of matches2) {
      if (meta.layer === "user") {
        continue;
      }
      let container = postcss_default.root({ nodes: [rule2.clone()] });
      for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples) {
        let prepareBackup = function() {
          if (clone.raws.neededBackup) {
            return;
          }
          clone.raws.neededBackup = true;
          clone.walkRules((rule22) => rule22.raws.originalSelector = rule22.selector);
        }, modifySelectors = function(modifierFunction) {
          prepareBackup();
          clone.each((rule22) => {
            if (rule22.type !== "rule") {
              return;
            }
            rule22.selectors = rule22.selectors.map((selector) => {
              return modifierFunction({
                get className() {
                  return getClassNameFromSelector(selector);
                },
                selector
              });
            });
          });
          return clone;
        };
        let clone = (containerFromArray ?? container).clone();
        let collectedFormats = [];
        let ruleWithVariant = variantFunction({
          get container() {
            prepareBackup();
            return clone;
          },
          separator: context.tailwindConfig.separator,
          modifySelectors,
          wrap(wrapper) {
            let nodes = clone.nodes;
            clone.removeAll();
            wrapper.append(nodes);
            clone.append(wrapper);
          },
          format(selectorFormat) {
            collectedFormats.push({
              format: selectorFormat,
              isArbitraryVariant
            });
          },
          args
        });
        if (Array.isArray(ruleWithVariant)) {
          for (let [idx, variantFunction2] of ruleWithVariant.entries()) {
            variantFunctionTuples.push([
              context.offsets.applyParallelOffset(variantSort, idx),
              variantFunction2,
              clone.clone()
            ]);
          }
          continue;
        }
        if (typeof ruleWithVariant === "string") {
          collectedFormats.push({
            format: ruleWithVariant,
            isArbitraryVariant
          });
        }
        if (ruleWithVariant === null) {
          continue;
        }
        if (clone.raws.neededBackup) {
          delete clone.raws.neededBackup;
          clone.walkRules((rule22) => {
            let before = rule22.raws.originalSelector;
            if (!before)
              return;
            delete rule22.raws.originalSelector;
            if (before === rule22.selector)
              return;
            let modified = rule22.selector;
            let rebuiltBase = (0, import_postcss_selector_parser.default)((selectors) => {
              selectors.walkClasses((classNode) => {
                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;
              });
            }).processSync(before);
            collectedFormats.push({
              format: modified.replace(rebuiltBase, "&"),
              isArbitraryVariant
            });
            rule22.selector = before;
          });
        }
        clone.nodes[0].raws.tailwind = { ...clone.nodes[0].raws.tailwind, parentLayer: meta.layer };
        let withOffset = [
          {
            ...meta,
            sort: context.offsets.applyVariantOffset(
              meta.sort,
              variantSort,
              Object.assign(args, context.variantOptions.get(variant))
            ),
            collectedFormats: (meta.collectedFormats ?? []).concat(collectedFormats)
          },
          clone.nodes[0]
        ];
        result.push(withOffset);
      }
    }
    return result;
  }
  return [];
}
function parseRules(rule2, cache2, options = {}) {
  if (!isPlainObject(rule2) && !Array.isArray(rule2)) {
    return [[rule2], options];
  }
  if (Array.isArray(rule2)) {
    return parseRules(rule2[0], cache2, rule2[1]);
  }
  if (!cache2.has(rule2)) {
    cache2.set(rule2, parseObjectStyles(rule2));
  }
  return [cache2.get(rule2), options];
}
var IS_VALID_PROPERTY_NAME = /^[a-z_-]/;
function isValidPropName(name) {
  return IS_VALID_PROPERTY_NAME.test(name);
}
function looksLikeUri(declaration) {
  if (!declaration.includes("://")) {
    return false;
  }
  try {
    const url2 = new URL(declaration);
    return url2.scheme !== "" && url2.host !== "";
  } catch (err) {
    return false;
  }
}
function isParsableNode(node) {
  let isParsable = true;
  node.walkDecls((decl2) => {
    if (!isParsableCssValue(decl2.prop, decl2.value)) {
      isParsable = false;
      return false;
    }
  });
  return isParsable;
}
function isParsableCssValue(property, value2) {
  if (looksLikeUri(`${property}:${value2}`)) {
    return false;
  }
  try {
    postcss_default.parse(`a{${property}:${value2}}`).toResult();
    return true;
  } catch (err) {
    return false;
  }
}
function extractArbitraryProperty(classCandidate, context) {
  let [, property, value2] = classCandidate.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/) ?? [];
  if (value2 === void 0) {
    return null;
  }
  if (!isValidPropName(property)) {
    return null;
  }
  if (!isSyntacticallyValidPropertyValue(value2)) {
    return null;
  }
  let normalized = normalize2(value2);
  if (!isParsableCssValue(property, normalized)) {
    return null;
  }
  let sort = context.offsets.arbitraryProperty();
  return [
    [
      { sort, layer: "utilities" },
      () => ({
        [asClass(classCandidate)]: {
          [property]: normalized
        }
      })
    ]
  ];
}
function* resolveMatchedPlugins(classCandidate, context) {
  if (context.candidateRuleMap.has(classCandidate)) {
    yield [context.candidateRuleMap.get(classCandidate), "DEFAULT"];
  }
  yield* function* (arbitraryPropertyRule) {
    if (arbitraryPropertyRule !== null) {
      yield [arbitraryPropertyRule, "DEFAULT"];
    }
  }(extractArbitraryProperty(classCandidate, context));
  let candidatePrefix = classCandidate;
  let negative = false;
  const twConfigPrefix = context.tailwindConfig.prefix;
  const twConfigPrefixLen = twConfigPrefix.length;
  const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);
  if (candidatePrefix[twConfigPrefixLen] === "-" && hasMatchingPrefix) {
    negative = true;
    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);
  }
  if (negative && context.candidateRuleMap.has(candidatePrefix)) {
    yield [context.candidateRuleMap.get(candidatePrefix), "-DEFAULT"];
  }
  for (let [prefix3, modifier] of candidatePermutations(candidatePrefix)) {
    if (context.candidateRuleMap.has(prefix3)) {
      yield [context.candidateRuleMap.get(prefix3), negative ? `-${modifier}` : modifier];
    }
  }
}
function splitWithSeparator(input, separator) {
  if (input === NOT_ON_DEMAND) {
    return [NOT_ON_DEMAND];
  }
  return splitAtTopLevelOnly(input, separator);
}
function* recordCandidates(matches2, classCandidate) {
  for (const match of matches2) {
    match[1].raws.tailwind = {
      ...match[1].raws.tailwind,
      classCandidate,
      preserveSource: match[0].options?.preserveSource ?? false
    };
    yield match;
  }
}
function* resolveMatches(candidate, context, original = candidate) {
  let separator = context.tailwindConfig.separator;
  let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();
  let important = false;
  if (classCandidate.startsWith("!")) {
    important = true;
    classCandidate = classCandidate.slice(1);
  }
  if (flagEnabled(context.tailwindConfig, "variantGrouping")) {
    if (classCandidate.startsWith("(") && classCandidate.endsWith(")")) {
      let base = variants.slice().reverse().join(separator);
      for (let part of splitAtTopLevelOnly(classCandidate.slice(1, -1), ",")) {
        yield* resolveMatches(base + separator + part, context, original);
      }
    }
  }
  for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {
    let matches2 = [];
    let typesByMatches = /* @__PURE__ */ new Map();
    let [plugins, modifier] = matchedPlugins;
    let isOnlyPlugin = plugins.length === 1;
    for (let [sort, plugin2] of plugins) {
      let matchesPerPlugin = [];
      if (typeof plugin2 === "function") {
        for (let ruleSet of [].concat(plugin2(modifier, { isOnlyPlugin }))) {
          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
          for (let rule2 of rules) {
            matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule2]);
          }
        }
      } else if (modifier === "DEFAULT" || modifier === "-DEFAULT") {
        let ruleSet = plugin2;
        let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
        for (let rule2 of rules) {
          matchesPerPlugin.push([{ ...sort, options: { ...sort.options, ...options } }, rule2]);
        }
      }
      if (matchesPerPlugin.length > 0) {
        let matchingTypes = Array.from(
          getMatchingTypes(
            sort.options?.types ?? [],
            modifier,
            sort.options ?? {},
            context.tailwindConfig
          )
        ).map(([_3, type]) => type);
        if (matchingTypes.length > 0) {
          typesByMatches.set(matchesPerPlugin, matchingTypes);
        }
        matches2.push(matchesPerPlugin);
      }
    }
    if (isArbitraryValue2(modifier)) {
      if (matches2.length > 1) {
        let findFallback = function(matches22) {
          if (matches22.length === 1) {
            return matches22[0];
          }
          return matches22.find((rules) => {
            let matchingTypes = typesByMatches.get(rules);
            return rules.some(([{ options }, rule2]) => {
              if (!isParsableNode(rule2)) {
                return false;
              }
              return options.types.some(
                ({ type, preferOnConflict }) => matchingTypes.includes(type) && preferOnConflict
              );
            });
          });
        };
        let [withAny, withoutAny] = matches2.reduce(
          (group, plugin2) => {
            let hasAnyType = plugin2.some(
              ([{ options }]) => options.types.some(({ type }) => type === "any")
            );
            if (hasAnyType) {
              group[0].push(plugin2);
            } else {
              group[1].push(plugin2);
            }
            return group;
          },
          [[], []]
        );
        let fallback = findFallback(withoutAny) ?? findFallback(withAny);
        if (fallback) {
          matches2 = [fallback];
        } else {
          let typesPerPlugin = matches2.map(
            (match) => /* @__PURE__ */ new Set([...typesByMatches.get(match) ?? []])
          );
          for (let pluginTypes of typesPerPlugin) {
            for (let type of pluginTypes) {
              let removeFromOwnGroup = false;
              for (let otherGroup of typesPerPlugin) {
                if (pluginTypes === otherGroup)
                  continue;
                if (otherGroup.has(type)) {
                  otherGroup.delete(type);
                  removeFromOwnGroup = true;
                }
              }
              if (removeFromOwnGroup)
                pluginTypes.delete(type);
            }
          }
          let messages = [];
          for (let [idx, group] of typesPerPlugin.entries()) {
            for (let type of group) {
              let rules = matches2[idx].map(([, rule2]) => rule2).flat().map(
                (rule2) => rule2.toString().split("\n").slice(1, -1).map((line) => line.trim()).map((x3) => `      ${x3}`).join("\n")
              ).join("\n\n");
              messages.push(
                `  Use \`${candidate.replace("[", `[${type}:`)}\` for \`${rules.trim()}\``
              );
              break;
            }
          }
          log_default.warn([
            `The class \`${candidate}\` is ambiguous and matches multiple utilities.`,
            ...messages,
            `If this is content and not a class, replace it with \`${candidate.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
          ]);
          continue;
        }
      }
      matches2 = matches2.map((list22) => list22.filter((match) => isParsableNode(match[1])));
    }
    matches2 = matches2.flat();
    matches2 = Array.from(recordCandidates(matches2, classCandidate));
    matches2 = applyPrefix(matches2, context);
    if (important) {
      matches2 = applyImportant(matches2, classCandidate);
    }
    for (let variant of variants) {
      matches2 = applyVariant(variant, matches2, context);
    }
    for (let match of matches2) {
      match[1].raws.tailwind = { ...match[1].raws.tailwind, candidate };
      match = applyFinalFormat(match, { context, candidate, original });
      if (match === null) {
        continue;
      }
      yield match;
    }
  }
}
function applyFinalFormat(match, { context, candidate, original }) {
  if (!match[0].collectedFormats) {
    return match;
  }
  let isValid = true;
  let finalFormat;
  try {
    finalFormat = formatVariantSelector(match[0].collectedFormats, {
      context,
      candidate
    });
  } catch {
    return null;
  }
  let container = postcss_default.root({ nodes: [match[1].clone()] });
  container.walkRules((rule2) => {
    if (inKeyframes(rule2)) {
      return;
    }
    try {
      rule2.selector = finalizeSelector(rule2.selector, finalFormat, {
        candidate: original,
        context
      });
    } catch {
      isValid = false;
      return false;
    }
  });
  if (!isValid) {
    return null;
  }
  match[1] = container.nodes[0];
  return match;
}
function inKeyframes(rule2) {
  return rule2.parent && rule2.parent.type === "atrule" && rule2.parent.name === "keyframes";
}
function getImportantStrategy(important) {
  if (important === true) {
    return (rule2) => {
      if (inKeyframes(rule2)) {
        return;
      }
      rule2.walkDecls((d3) => {
        if (d3.parent.type === "rule" && !inKeyframes(d3.parent)) {
          d3.important = true;
        }
      });
    };
  }
  if (typeof important === "string") {
    return (rule2) => {
      if (inKeyframes(rule2)) {
        return;
      }
      rule2.selectors = rule2.selectors.map((selector) => {
        return applyImportantSelector(selector, important);
      });
    };
  }
}
function generateRules(candidates, context) {
  let allRules = [];
  let strategy = getImportantStrategy(context.tailwindConfig.important);
  for (let candidate of candidates) {
    if (context.notClassCache.has(candidate)) {
      continue;
    }
    if (context.candidateRuleCache.has(candidate)) {
      allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));
      continue;
    }
    let matches2 = Array.from(resolveMatches(candidate, context));
    if (matches2.length === 0) {
      context.notClassCache.add(candidate);
      continue;
    }
    context.classCache.set(candidate, matches2);
    let rules = context.candidateRuleCache.get(candidate) ?? /* @__PURE__ */ new Set();
    context.candidateRuleCache.set(candidate, rules);
    for (const match of matches2) {
      let [{ sort, options }, rule2] = match;
      if (options.respectImportant && strategy) {
        let container = postcss_default.root({ nodes: [rule2.clone()] });
        container.walkRules(strategy);
        rule2 = container.nodes[0];
      }
      let newEntry = [sort, rule2];
      rules.add(newEntry);
      context.ruleCache.add(newEntry);
      allRules.push(newEntry);
    }
  }
  return allRules;
}
function isArbitraryValue2(input) {
  return input.startsWith("[") && input.endsWith("]");
}
function cloneNodes(nodes, source = void 0, raws = void 0) {
  return nodes.map((node) => {
    let cloned = node.clone();
    let shouldOverwriteSource = node.raws.tailwind?.preserveSource !== true || !cloned.source;
    if (source !== void 0 && shouldOverwriteSource) {
      cloned.source = source;
      if ("walk" in cloned) {
        cloned.walk((child) => {
          child.source = source;
        });
      }
    }
    if (raws !== void 0) {
      cloned.raws.tailwind = {
        ...cloned.raws.tailwind,
        ...raws
      };
    }
    return cloned;
  });
}
var REGEX_SPECIAL = /[\\^$.*+?()[\]{}|]/g;
var REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);
function toSource(source) {
  source = Array.isArray(source) ? source : [source];
  source = source.map((item) => item instanceof RegExp ? item.source : item);
  return source.join("");
}
function pattern(source) {
  return new RegExp(toSource(source), "g");
}
function any(sources) {
  return `(?:${sources.map(toSource).join("|")})`;
}
function optional(source) {
  return `(?:${toSource(source)})?`;
}
function zeroOrMore(source) {
  return `(?:${toSource(source)})*`;
}
function escape2(string) {
  return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, "\\$&") : string || "";
}
function defaultExtractor(context) {
  let patterns = Array.from(buildRegExps(context));
  return (content) => {
    let results = [];
    for (let pattern2 of patterns) {
      results = [...results, ...content.match(pattern2) ?? []];
    }
    return results.filter((v2) => v2 !== void 0).map(clipAtBalancedParens);
  };
}
function* buildRegExps(context) {
  let separator = context.tailwindConfig.separator;
  let variantGroupingEnabled = flagEnabled(context.tailwindConfig, "variantGrouping");
  let prefix3 = context.tailwindConfig.prefix !== "" ? optional(pattern([/-?/, escape2(context.tailwindConfig.prefix)])) : "";
  let utility = any([
    /\[[^\s:'"`]+:[^\s\[\]]+\]/,
    /\[[^\s:'"`]+:[^\s]+?\[[^\s]+?\][^\s]+?\]/,
    pattern([
      /-?(?:\w+)/,
      optional(
        any([
          pattern([
            /-(?:\w+-)*\[[^\s:]+\]/,
            /(?![{([]])/,
            /(?:\/[^\s'"`\\><$]*)?/
          ]),
          pattern([
            /-(?:\w+-)*\[[^\s]+\]/,
            /(?![{([]])/,
            /(?:\/[^\s'"`\\$]*)?/
          ]),
          /[-\/][^\s'"`\\$={><]*/
        ])
      )
    ])
  ]);
  let variantPatterns = [
    any([
      pattern([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, separator]),
      pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, separator]),
      pattern([/[^\s"'`\[\\]+/, separator])
    ]),
    any([
      pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, separator]),
      pattern([/[^\s`\[\\]+/, separator])
    ])
  ];
  for (const variantPattern of variantPatterns) {
    yield pattern([
      "((?=((",
      variantPattern,
      ")+))\\2)?",
      /!?/,
      prefix3,
      variantGroupingEnabled ? any([
        pattern([/\(/, utility, zeroOrMore([/,/, utility]), /\)/]),
        utility
      ]) : utility
    ]);
  }
  yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
var SPECIALS = /([\[\]'"`])([^\[\]'"`])?/g;
var ALLOWED_CLASS_CHARACTERS = /[^"'`\s<>\]]+/;
function clipAtBalancedParens(input) {
  if (!input.includes("-[")) {
    return input;
  }
  let depth = 0;
  let openStringTypes = [];
  let matches2 = input.matchAll(SPECIALS);
  matches2 = Array.from(matches2).flatMap((match) => {
    const [, ...groups] = match;
    return groups.map(
      (group, idx) => Object.assign([], match, {
        index: match.index + idx,
        0: group
      })
    );
  });
  for (let match of matches2) {
    let char = match[0];
    let inStringType = openStringTypes[openStringTypes.length - 1];
    if (char === inStringType) {
      openStringTypes.pop();
    } else if (char === "'" || char === '"' || char === "`") {
      openStringTypes.push(char);
    }
    if (inStringType) {
      continue;
    } else if (char === "[") {
      depth++;
      continue;
    } else if (char === "]") {
      depth--;
      continue;
    }
    if (depth < 0) {
      return input.substring(0, match.index - 1);
    }
    if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {
      return input.substring(0, match.index);
    }
  }
  return input;
}
var env2 = env;
var builtInExtractors = {
  DEFAULT: defaultExtractor
};
var builtInTransformers = {
  DEFAULT: (content) => content,
  svelte: (content) => content.replace(/(?:^|\s)class:/g, " ")
};
function getExtractor(context, fileExtension) {
  let extractors = context.tailwindConfig.content.extract;
  return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);
}
function getTransformer(tailwindConfig, fileExtension) {
  let transformers = tailwindConfig.content.transform;
  return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
}
var extractorCache = /* @__PURE__ */ new WeakMap();
function getClassCandidates(content, extractor, candidates, seen) {
  if (!extractorCache.has(extractor)) {
    extractorCache.set(extractor, new import_quick_lru.default({ maxSize: 25e3 }));
  }
  for (let line of content.split("\n")) {
    line = line.trim();
    if (seen.has(line)) {
      continue;
    }
    seen.add(line);
    if (extractorCache.get(extractor).has(line)) {
      for (let match of extractorCache.get(extractor).get(line)) {
        candidates.add(match);
      }
    } else {
      let extractorMatches = extractor(line).filter((s2) => s2 !== "!*");
      let lineMatchesSet = new Set(extractorMatches);
      for (let match of lineMatchesSet) {
        candidates.add(match);
      }
      extractorCache.get(extractor).set(line, lineMatchesSet);
    }
  }
}
function buildStylesheet(rules, context) {
  let sortedRules = context.offsets.sort(rules);
  let returnValue = {
    base: /* @__PURE__ */ new Set(),
    defaults: /* @__PURE__ */ new Set(),
    components: /* @__PURE__ */ new Set(),
    utilities: /* @__PURE__ */ new Set(),
    variants: /* @__PURE__ */ new Set()
  };
  for (let [sort, rule2] of sortedRules) {
    returnValue[sort.layer].add(rule2);
  }
  return returnValue;
}
function expandTailwindAtRules(context) {
  return (root2) => {
    let layerNodes = {
      base: null,
      components: null,
      utilities: null,
      variants: null
    };
    root2.walkAtRules((rule2) => {
      if (rule2.name === "tailwind") {
        if (Object.keys(layerNodes).includes(rule2.params)) {
          layerNodes[rule2.params] = rule2;
        }
      }
    });
    if (Object.values(layerNodes).every((n4) => n4 === null)) {
      return root2;
    }
    let candidates = /* @__PURE__ */ new Set([...context.candidates ?? [], NOT_ON_DEMAND]);
    let seen = /* @__PURE__ */ new Set();
    env2.DEBUG && console.time("Reading changed files");
    if (env2.OXIDE) {
      for (let candidate of __require2("@tailwindcss/oxide").parseCandidateStringsFromFiles(
        context.changedContent
      )) {
        candidates.add(candidate);
      }
    } else {
      for (let { file, content, extension } of context.changedContent) {
        let transformer = getTransformer(context.tailwindConfig, extension);
        let extractor = getExtractor(context, extension);
        content = file ? fs_default.readFileSync(file, "utf8") : content;
        getClassCandidates(transformer(content), extractor, candidates, seen);
      }
    }
    env2.DEBUG && console.timeEnd("Reading changed files");
    let classCacheCount = context.classCache.size;
    env2.DEBUG && console.time("Generate rules");
    env2.DEBUG && console.time("Sorting candidates");
    let sortedCandidates = env2.OXIDE ? candidates : new Set(
      [...candidates].sort((a3, z3) => {
        if (a3 === z3)
          return 0;
        if (a3 < z3)
          return -1;
        return 1;
      })
    );
    env2.DEBUG && console.timeEnd("Sorting candidates");
    generateRules(sortedCandidates, context);
    env2.DEBUG && console.timeEnd("Generate rules");
    env2.DEBUG && console.time("Build stylesheet");
    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
      context.stylesheetCache = buildStylesheet([...context.ruleCache], context);
    }
    env2.DEBUG && console.timeEnd("Build stylesheet");
    let {
      defaults: defaultNodes,
      base: baseNodes,
      components: componentNodes,
      utilities: utilityNodes,
      variants: screenNodes
    } = context.stylesheetCache;
    if (layerNodes.base) {
      layerNodes.base.before(
        cloneNodes([...baseNodes, ...defaultNodes], layerNodes.base.source, {
          layer: "base"
        })
      );
      layerNodes.base.remove();
    }
    if (layerNodes.components) {
      layerNodes.components.before(
        cloneNodes([...componentNodes], layerNodes.components.source, {
          layer: "components"
        })
      );
      layerNodes.components.remove();
    }
    if (layerNodes.utilities) {
      layerNodes.utilities.before(
        cloneNodes([...utilityNodes], layerNodes.utilities.source, {
          layer: "utilities"
        })
      );
      layerNodes.utilities.remove();
    }
    const variantNodes = Array.from(screenNodes).filter((node) => {
      const parentLayer = node.raws.tailwind?.parentLayer;
      if (parentLayer === "components") {
        return layerNodes.components !== null;
      }
      if (parentLayer === "utilities") {
        return layerNodes.utilities !== null;
      }
      return true;
    });
    if (layerNodes.variants) {
      layerNodes.variants.before(
        cloneNodes(variantNodes, layerNodes.variants.source, {
          layer: "variants"
        })
      );
      layerNodes.variants.remove();
    } else if (variantNodes.length > 0) {
      root2.append(
        cloneNodes(variantNodes, root2.source, {
          layer: "variants"
        })
      );
    }
    const hasUtilityVariants = variantNodes.some(
      (node) => node.raws.tailwind?.parentLayer === "utilities"
    );
    if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {
      log_default.warn("content-problems", [
        "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
        "https://tailwindcss.com/docs/content-configuration"
      ]);
    }
    if (env2.DEBUG) {
      console.log("Potential classes: ", candidates.size);
      console.log("Active contexts: ", contextSourcesMap.size);
    }
    context.changedContent = [];
    root2.walkAtRules("layer", (rule2) => {
      if (Object.keys(layerNodes).includes(rule2.params)) {
        rule2.remove();
      }
    });
  };
}
function extractClasses(node) {
  let groups = /* @__PURE__ */ new Map();
  let container = postcss_default.root({ nodes: [node.clone()] });
  container.walkRules((rule2) => {
    (0, import_postcss_selector_parser6.default)((selectors) => {
      selectors.walkClasses((classSelector) => {
        let parentSelector = classSelector.parent.toString();
        let classes2 = groups.get(parentSelector);
        if (!classes2) {
          groups.set(parentSelector, classes2 = /* @__PURE__ */ new Set());
        }
        classes2.add(classSelector.value);
      });
    }).processSync(rule2.selector);
  });
  let normalizedGroups = Array.from(groups.values(), (classes2) => Array.from(classes2));
  let classes = normalizedGroups.flat();
  return Object.assign(classes, { groups: normalizedGroups });
}
var selectorExtractor = (0, import_postcss_selector_parser6.default)();
function extractSelectors(ruleSelectors) {
  return selectorExtractor.astSync(ruleSelectors);
}
function extractBaseCandidates(candidates, separator) {
  let baseClasses = /* @__PURE__ */ new Set();
  for (let candidate of candidates) {
    baseClasses.add(candidate.split(separator).pop());
  }
  return Array.from(baseClasses);
}
function prefix2(context, selector) {
  let prefix3 = context.tailwindConfig.prefix;
  return typeof prefix3 === "function" ? prefix3(selector) : prefix3 + selector;
}
function* pathToRoot(node) {
  yield node;
  while (node.parent) {
    yield node.parent;
    node = node.parent;
  }
}
function shallowClone(node, overrides = {}) {
  let children = node.nodes;
  node.nodes = [];
  let tmp = node.clone(overrides);
  node.nodes = children;
  return tmp;
}
function nestedClone(node) {
  for (let parent of pathToRoot(node)) {
    if (node === parent) {
      continue;
    }
    if (parent.type === "root") {
      break;
    }
    node = shallowClone(parent, {
      nodes: [node]
    });
  }
  return node;
}
function buildLocalApplyCache(root2, context) {
  let cache2 = /* @__PURE__ */ new Map();
  root2.walkRules((rule2) => {
    for (let node of pathToRoot(rule2)) {
      if (node.raws.tailwind?.layer !== void 0) {
        return;
      }
    }
    let container = nestedClone(rule2);
    let sort = context.offsets.create("user");
    for (let className of extractClasses(rule2)) {
      let list22 = cache2.get(className) || [];
      cache2.set(className, list22);
      list22.push([
        {
          layer: "user",
          sort,
          important: false
        },
        container
      ]);
    }
  });
  return cache2;
}
function buildApplyCache(applyCandidates, context) {
  for (let candidate of applyCandidates) {
    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {
      continue;
    }
    if (context.classCache.has(candidate)) {
      context.applyClassCache.set(
        candidate,
        context.classCache.get(candidate).map(([meta, rule2]) => [meta, rule2.clone()])
      );
      continue;
    }
    let matches2 = Array.from(resolveMatches(candidate, context));
    if (matches2.length === 0) {
      context.notClassCache.add(candidate);
      continue;
    }
    context.applyClassCache.set(candidate, matches2);
  }
  return context.applyClassCache;
}
function lazyCache(buildCacheFn) {
  let cache2 = null;
  return {
    get: (name) => {
      cache2 = cache2 || buildCacheFn();
      return cache2.get(name);
    },
    has: (name) => {
      cache2 = cache2 || buildCacheFn();
      return cache2.has(name);
    }
  };
}
function combineCaches(caches) {
  return {
    get: (name) => caches.flatMap((cache2) => cache2.get(name) || []),
    has: (name) => caches.some((cache2) => cache2.has(name))
  };
}
function extractApplyCandidates(params) {
  let candidates = params.split(/[\s\t\n]+/g);
  if (candidates[candidates.length - 1] === "!important") {
    return [candidates.slice(0, -1), true];
  }
  return [candidates, false];
}
function processApply(root2, context, localCache) {
  let applyCandidates = /* @__PURE__ */ new Set();
  let applies = [];
  root2.walkAtRules("apply", (rule2) => {
    let [candidates] = extractApplyCandidates(rule2.params);
    for (let util2 of candidates) {
      applyCandidates.add(util2);
    }
    applies.push(rule2);
  });
  if (applies.length === 0) {
    return;
  }
  let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)]);
  function replaceSelector(selector, utilitySelectors, candidate) {
    let selectorList = extractSelectors(selector);
    let utilitySelectorsList = extractSelectors(utilitySelectors);
    let candidateList = extractSelectors(`.${escapeClassName(candidate)}`);
    let candidateClass = candidateList.nodes[0].nodes[0];
    selectorList.each((sel) => {
      let replaced = /* @__PURE__ */ new Set();
      utilitySelectorsList.each((utilitySelector) => {
        let hasReplaced = false;
        utilitySelector = utilitySelector.clone();
        utilitySelector.walkClasses((node) => {
          if (node.value !== candidateClass.value) {
            return;
          }
          if (hasReplaced) {
            return;
          }
          node.replaceWith(...sel.nodes.map((node2) => node2.clone()));
          replaced.add(utilitySelector);
          hasReplaced = true;
        });
      });
      for (let sel2 of replaced) {
        let groups = [[]];
        for (let node of sel2.nodes) {
          if (node.type === "combinator") {
            groups.push(node);
            groups.push([]);
          } else {
            let last = groups[groups.length - 1];
            last.push(node);
          }
        }
        sel2.nodes = [];
        for (let group of groups) {
          if (Array.isArray(group)) {
            group.sort((a3, b3) => {
              if (a3.type === "tag" && b3.type === "class") {
                return -1;
              } else if (a3.type === "class" && b3.type === "tag") {
                return 1;
              } else if (a3.type === "class" && b3.type === "pseudo" && b3.value.startsWith("::")) {
                return -1;
              } else if (a3.type === "pseudo" && a3.value.startsWith("::") && b3.type === "class") {
                return 1;
              }
              return 0;
            });
          }
          sel2.nodes = sel2.nodes.concat(group);
        }
      }
      sel.replaceWith(...replaced);
    });
    return selectorList.toString();
  }
  let perParentApplies = /* @__PURE__ */ new Map();
  for (let apply of applies) {
    let [candidates] = perParentApplies.get(apply.parent) || [[], apply.source];
    perParentApplies.set(apply.parent, [candidates, apply.source]);
    let [applyCandidates2, important] = extractApplyCandidates(apply.params);
    if (apply.parent.type === "atrule") {
      if (apply.parent.name === "screen") {
        let screenType = apply.parent.params;
        throw apply.error(
          `@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates2.map((c2) => `${screenType}:${c2}`).join(" ")} instead.`
        );
      }
      throw apply.error(
        `@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`
      );
    }
    for (let applyCandidate of applyCandidates2) {
      if ([prefix2(context, "group"), prefix2(context, "peer")].includes(applyCandidate)) {
        throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);
      }
      if (!applyClassCache.has(applyCandidate)) {
        throw apply.error(
          `The \`${applyCandidate}\` class does not exist. If \`${applyCandidate}\` is a custom class, make sure it is defined within a \`@layer\` directive.`
        );
      }
      let rules = applyClassCache.get(applyCandidate);
      candidates.push([applyCandidate, important, rules]);
    }
  }
  for (let [parent, [candidates, atApplySource]] of perParentApplies) {
    let siblings = [];
    for (let [applyCandidate, important, rules] of candidates) {
      let potentialApplyCandidates = [
        applyCandidate,
        ...extractBaseCandidates([applyCandidate], context.tailwindConfig.separator)
      ];
      for (let [meta, node] of rules) {
        let parentClasses = extractClasses(parent);
        let nodeClasses = extractClasses(node);
        nodeClasses = nodeClasses.groups.filter(
          (classList) => classList.some((className) => potentialApplyCandidates.includes(className))
        ).flat();
        nodeClasses = nodeClasses.concat(
          extractBaseCandidates(nodeClasses, context.tailwindConfig.separator)
        );
        let intersects = parentClasses.some((selector) => nodeClasses.includes(selector));
        if (intersects) {
          throw node.error(
            `You cannot \`@apply\` the \`${applyCandidate}\` utility here because it creates a circular dependency.`
          );
        }
        let root22 = postcss_default.root({ nodes: [node.clone()] });
        root22.walk((node2) => {
          node2.source = atApplySource;
        });
        let canRewriteSelector = node.type !== "atrule" || node.type === "atrule" && node.name !== "keyframes";
        if (canRewriteSelector) {
          root22.walkRules((rule2) => {
            if (!extractClasses(rule2).some((candidate) => candidate === applyCandidate)) {
              rule2.remove();
              return;
            }
            let importantSelector = typeof context.tailwindConfig.important === "string" ? context.tailwindConfig.important : null;
            let isGenerated = parent.raws.tailwind !== void 0;
            let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;
            rule2.selector = replaceSelector(parentSelector, rule2.selector, applyCandidate);
            if (importantSelector && parentSelector !== parent.selector) {
              rule2.selector = applyImportantSelector(rule2.selector, importantSelector);
            }
            rule2.walkDecls((d3) => {
              d3.important = meta.important || important;
            });
          });
        }
        if (!root22.nodes[0]) {
          continue;
        }
        siblings.push([meta.sort, root22.nodes[0]]);
      }
    }
    let nodes = context.offsets.sort(siblings).map((s2) => s2[1]);
    parent.after(nodes);
  }
  for (let apply of applies) {
    if (apply.parent.nodes.length > 1) {
      apply.remove();
    } else {
      apply.parent.remove();
    }
  }
  processApply(root2, context, localCache);
}
function expandApplyAtRules(context) {
  return (root2) => {
    let localCache = lazyCache(() => buildLocalApplyCache(root2, context));
    processApply(root2, context, localCache);
  };
}
function isObject(input) {
  return typeof input === "object" && input !== null;
}
function findClosestExistingPath(theme, path) {
  let parts = toPath(path);
  do {
    parts.pop();
    if ((0, import_dlv2.default)(theme, parts) !== void 0)
      break;
  } while (parts.length);
  return parts.length ? parts : void 0;
}
function pathToString(path) {
  if (typeof path === "string")
    return path;
  return path.reduce((acc, cur, i5) => {
    if (cur.includes("."))
      return `${acc}[${cur}]`;
    return i5 === 0 ? cur : `${acc}.${cur}`;
  }, "");
}
function list2(items) {
  return items.map((key) => `'${key}'`).join(", ");
}
function listKeys(obj) {
  return list2(Object.keys(obj));
}
function validatePath(config, path, defaultValue, themeOpts = {}) {
  const pathString = Array.isArray(path) ? pathToString(path) : path.replace(/^['"]+|['"]+$/g, "");
  const pathSegments = Array.isArray(path) ? path : toPath(pathString);
  const value2 = (0, import_dlv2.default)(config.theme, pathSegments, defaultValue);
  if (value2 === void 0) {
    let error = `'${pathString}' does not exist in your theme config.`;
    const parentSegments = pathSegments.slice(0, -1);
    const parentValue = (0, import_dlv2.default)(config.theme, parentSegments);
    if (isObject(parentValue)) {
      const validKeys = Object.keys(parentValue).filter(
        (key) => validatePath(config, [...parentSegments, key]).isValid
      );
      const suggestion = (0, import_didyoumean.default)(pathSegments[pathSegments.length - 1], validKeys);
      if (suggestion) {
        error += ` Did you mean '${pathToString([...parentSegments, suggestion])}'?`;
      } else if (validKeys.length > 0) {
        error += ` '${pathToString(parentSegments)}' has the following valid keys: ${list2(
          validKeys
        )}`;
      }
    } else {
      const closestPath = findClosestExistingPath(config.theme, pathString);
      if (closestPath) {
        const closestValue = (0, import_dlv2.default)(config.theme, closestPath);
        if (isObject(closestValue)) {
          error += ` '${pathToString(closestPath)}' has the following keys: ${listKeys(
            closestValue
          )}`;
        } else {
          error += ` '${pathToString(closestPath)}' is not an object.`;
        }
      } else {
        error += ` Your theme has the following top-level keys: ${listKeys(config.theme)}`;
      }
    }
    return {
      isValid: false,
      error
    };
  }
  if (!(typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "function" || value2 instanceof String || value2 instanceof Number || Array.isArray(value2))) {
    let error = `'${pathString}' was found but does not resolve to a string.`;
    if (isObject(value2)) {
      let validKeys = Object.keys(value2).filter(
        (key) => validatePath(config, [...pathSegments, key]).isValid
      );
      if (validKeys.length) {
        error += ` Did you mean something like '${pathToString([...pathSegments, validKeys[0]])}'?`;
      }
    }
    return {
      isValid: false,
      error
    };
  }
  const [themeSection] = pathSegments;
  return {
    isValid: true,
    value: transformThemeValue(themeSection)(value2, themeOpts)
  };
}
function extractArgs(node, vNodes, functions) {
  vNodes = vNodes.map((vNode) => resolveVNode(node, vNode, functions));
  let args = [""];
  for (let vNode of vNodes) {
    if (vNode.type === "div" && vNode.value === ",") {
      args.push("");
    } else {
      args[args.length - 1] += import_postcss_value_parser3.default.stringify(vNode);
    }
  }
  return args;
}
function resolveVNode(node, vNode, functions) {
  if (vNode.type === "function" && functions[vNode.value] !== void 0) {
    let args = extractArgs(node, vNode.nodes, functions);
    vNode.type = "word";
    vNode.value = functions[vNode.value](node, ...args);
  }
  return vNode;
}
function resolveFunctions(node, input, functions) {
  return (0, import_postcss_value_parser3.default)(input).walk((vNode) => {
    resolveVNode(node, vNode, functions);
  }).toString();
}
var nodeTypePropertyMap = {
  atrule: "params",
  decl: "value"
};
function* toPaths(path) {
  path = path.replace(/^['"]+|['"]+$/g, "");
  let matches2 = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
  let alpha = void 0;
  yield [path, void 0];
  if (matches2) {
    path = matches2[1];
    alpha = matches2[2];
    yield [path, alpha];
  }
}
function resolvePath(config, path, defaultValue) {
  const results = Array.from(toPaths(path)).map(([path2, alpha]) => {
    return Object.assign(validatePath(config, path2, defaultValue, { opacityValue: alpha }), {
      resolvedPath: path2,
      alpha
    });
  });
  return results.find((result) => result.isValid) ?? results[0];
}
function evaluateTailwindFunctions_default(context) {
  let config = context.tailwindConfig;
  let functions = {
    theme: (node, path, ...defaultValue) => {
      let { isValid, value: value2, error, alpha } = resolvePath(
        config,
        path,
        defaultValue.length ? defaultValue : void 0
      );
      if (!isValid) {
        let parentNode = node.parent;
        let candidate = parentNode?.raws.tailwind?.candidate;
        if (parentNode && candidate !== void 0) {
          context.markInvalidUtilityNode(parentNode);
          parentNode.remove();
          log_default.warn("invalid-theme-key-in-class", [
            `The utility \`${candidate}\` contains an invalid theme value and was not generated.`
          ]);
          return;
        }
        throw node.error(error);
      }
      let maybeColor = parseColorFormat(value2);
      let isColorFunction = maybeColor !== void 0 && typeof maybeColor === "function";
      if (alpha !== void 0 || isColorFunction) {
        if (alpha === void 0) {
          alpha = 1;
        }
        value2 = withAlphaValue(maybeColor, alpha, maybeColor);
      }
      return value2;
    },
    screen: (node, screen) => {
      screen = screen.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
      let screens = normalizeScreens(config.theme.screens);
      let screenDefinition = screens.find(({ name }) => name === screen);
      if (!screenDefinition) {
        throw node.error(`The '${screen}' screen does not exist in your theme.`);
      }
      return buildMediaQuery(screenDefinition);
    }
  };
  return (root2) => {
    root2.walk((node) => {
      let property = nodeTypePropertyMap[node.type];
      if (property === void 0) {
        return;
      }
      node[property] = resolveFunctions(node, node[property], functions);
    });
  };
}
function substituteScreenAtRules_default({ tailwindConfig: { theme } }) {
  return function(css) {
    css.walkAtRules("screen", (atRule2) => {
      let screen = atRule2.params;
      let screens = normalizeScreens(theme.screens);
      let screenDefinition = screens.find(({ name }) => name === screen);
      if (!screenDefinition) {
        throw atRule2.error(`No \`${screen}\` screen found.`);
      }
      atRule2.name = "media";
      atRule2.params = buildMediaQuery(screenDefinition);
    });
  };
}
var getNode = {
  id(node) {
    return import_postcss_selector_parser7.default.attribute({
      attribute: "id",
      operator: "=",
      value: node.value,
      quoteMark: '"'
    });
  }
};
function minimumImpactSelector(nodes) {
  let rest = nodes.filter((node2) => {
    if (node2.type !== "pseudo")
      return true;
    if (node2.nodes.length > 0)
      return true;
    return node2.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(node2.value);
  }).reverse();
  let searchFor = /* @__PURE__ */ new Set(["tag", "class", "id", "attribute"]);
  let splitPointIdx = rest.findIndex((n4) => searchFor.has(n4.type));
  if (splitPointIdx === -1)
    return rest.reverse().join("").trim();
  let node = rest[splitPointIdx];
  let bestNode = getNode[node.type] ? getNode[node.type](node) : node;
  rest = rest.slice(0, splitPointIdx);
  let combinatorIdx = rest.findIndex((n4) => n4.type === "combinator" && n4.value === ">");
  if (combinatorIdx !== -1) {
    rest.splice(0, combinatorIdx);
    rest.unshift(import_postcss_selector_parser7.default.universal());
  }
  return [bestNode, ...rest.reverse()].join("").trim();
}
var elementSelectorParser = (0, import_postcss_selector_parser7.default)((selectors) => {
  return selectors.map((s2) => {
    let nodes = s2.split((n4) => n4.type === "combinator" && n4.value === " ").pop();
    return minimumImpactSelector(nodes);
  });
});
var cache = /* @__PURE__ */ new Map();
function extractElementSelector(selector) {
  if (!cache.has(selector)) {
    cache.set(selector, elementSelectorParser.transformSync(selector));
  }
  return cache.get(selector);
}
function resolveDefaultsAtRules({ tailwindConfig }) {
  return (root2) => {
    let variableNodeMap = /* @__PURE__ */ new Map();
    let universals = /* @__PURE__ */ new Set();
    root2.walkAtRules("defaults", (rule2) => {
      if (rule2.nodes && rule2.nodes.length > 0) {
        universals.add(rule2);
        return;
      }
      let variable = rule2.params;
      if (!variableNodeMap.has(variable)) {
        variableNodeMap.set(variable, /* @__PURE__ */ new Set());
      }
      variableNodeMap.get(variable).add(rule2.parent);
      rule2.remove();
    });
    if (flagEnabled(tailwindConfig, "optimizeUniversalDefaults")) {
      for (let universal of universals) {
        let selectorGroups = /* @__PURE__ */ new Map();
        let rules = variableNodeMap.get(universal.params) ?? [];
        for (let rule2 of rules) {
          for (let selector of extractElementSelector(rule2.selector)) {
            let selectorGroupName = selector.includes(":-") || selector.includes("::-") ? selector : "__DEFAULT__";
            let selectors = selectorGroups.get(selectorGroupName) ?? /* @__PURE__ */ new Set();
            selectorGroups.set(selectorGroupName, selectors);
            selectors.add(selector);
          }
        }
        if (flagEnabled(tailwindConfig, "optimizeUniversalDefaults")) {
          if (selectorGroups.size === 0) {
            universal.remove();
            continue;
          }
          for (let [, selectors] of selectorGroups) {
            let universalRule = postcss_default.rule({
              source: universal.source
            });
            universalRule.selectors = [...selectors];
            universalRule.append(universal.nodes.map((node) => node.clone()));
            universal.before(universalRule);
          }
        }
        universal.remove();
      }
    } else if (universals.size) {
      let universalRule = postcss_default.rule({
        selectors: ["*", "::before", "::after"]
      });
      for (let universal of universals) {
        universalRule.append(universal.nodes);
        if (!universalRule.parent) {
          universal.before(universalRule);
        }
        if (!universalRule.source) {
          universalRule.source = universal.source;
        }
        universal.remove();
      }
      let backdropRule = universalRule.clone({
        selectors: ["::backdrop"]
      });
      universalRule.after(backdropRule);
    }
  };
}
var comparisonMap = {
  atrule: ["name", "params"],
  rule: ["selector"]
};
var types = new Set(Object.keys(comparisonMap));
function collapseAdjacentRules() {
  function collapseRulesIn(root2) {
    let currentRule = null;
    root2.each((node) => {
      if (!types.has(node.type)) {
        currentRule = null;
        return;
      }
      if (currentRule === null) {
        currentRule = node;
        return;
      }
      let properties = comparisonMap[node.type];
      if (node.type === "atrule" && node.name === "font-face") {
        currentRule = node;
      } else if (properties.every(
        (property) => (node[property] ?? "").replace(/\s+/g, " ") === (currentRule[property] ?? "").replace(/\s+/g, " ")
      )) {
        if (node.nodes) {
          currentRule.append(node.nodes);
        }
        node.remove();
      } else {
        currentRule = node;
      }
    });
    root2.each((node) => {
      if (node.type === "atrule") {
        collapseRulesIn(node);
      }
    });
  }
  return (root2) => {
    collapseRulesIn(root2);
  };
}
function collapseDuplicateDeclarations() {
  return (root2) => {
    root2.walkRules((node) => {
      let seen = /* @__PURE__ */ new Map();
      let droppable = /* @__PURE__ */ new Set([]);
      let byProperty = /* @__PURE__ */ new Map();
      node.walkDecls((decl2) => {
        if (decl2.parent !== node) {
          return;
        }
        if (seen.has(decl2.prop)) {
          if (seen.get(decl2.prop).value === decl2.value) {
            droppable.add(seen.get(decl2.prop));
            seen.set(decl2.prop, decl2);
            return;
          }
          if (!byProperty.has(decl2.prop)) {
            byProperty.set(decl2.prop, /* @__PURE__ */ new Set());
          }
          byProperty.get(decl2.prop).add(seen.get(decl2.prop));
          byProperty.get(decl2.prop).add(decl2);
        }
        seen.set(decl2.prop, decl2);
      });
      for (let decl2 of droppable) {
        decl2.remove();
      }
      for (let declarations of byProperty.values()) {
        let byUnit = /* @__PURE__ */ new Map();
        for (let decl2 of declarations) {
          let unit = resolveUnit(decl2.value);
          if (unit === null) {
            continue;
          }
          if (!byUnit.has(unit)) {
            byUnit.set(unit, /* @__PURE__ */ new Set());
          }
          byUnit.get(unit).add(decl2);
        }
        for (let declarations2 of byUnit.values()) {
          let removableDeclarations = Array.from(declarations2).slice(0, -1);
          for (let decl2 of removableDeclarations) {
            decl2.remove();
          }
        }
      }
    });
  };
}
var UNITLESS_NUMBER = Symbol("unitless-number");
function resolveUnit(input) {
  let result = /^-?\d*.?\d+([\w%]+)?$/g.exec(input);
  if (result) {
    return result[1] ?? UNITLESS_NUMBER;
  }
  return null;
}
function partitionRules(root2) {
  if (!root2.walkAtRules)
    return;
  let applyParents = /* @__PURE__ */ new Set();
  root2.walkAtRules("apply", (rule2) => {
    applyParents.add(rule2.parent);
  });
  if (applyParents.size === 0) {
    return;
  }
  for (let rule2 of applyParents) {
    let nodeGroups = [];
    let lastGroup = [];
    for (let node of rule2.nodes) {
      if (node.type === "atrule" && node.name === "apply") {
        if (lastGroup.length > 0) {
          nodeGroups.push(lastGroup);
          lastGroup = [];
        }
        nodeGroups.push([node]);
      } else {
        lastGroup.push(node);
      }
    }
    if (lastGroup.length > 0) {
      nodeGroups.push(lastGroup);
    }
    if (nodeGroups.length === 1) {
      continue;
    }
    for (let group of [...nodeGroups].reverse()) {
      let clone = rule2.clone({ nodes: [] });
      clone.append(group);
      rule2.after(clone);
    }
    rule2.remove();
  }
}
function expandApplyAtRules2() {
  return (root2) => {
    partitionRules(root2);
  };
}
function isRoot(node) {
  return node.type === "root";
}
function isAtLayer(node) {
  return node.type === "atrule" && node.name === "layer";
}
function detectNesting_default(_context) {
  return (root2, result) => {
    let found = false;
    root2.walkAtRules("tailwind", (node) => {
      if (found)
        return false;
      if (node.parent && !(isRoot(node.parent) || isAtLayer(node.parent))) {
        found = true;
        node.warn(
          result,
          [
            "Nested @tailwind rules were detected, but are not supported.",
            "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix",
            "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"
          ].join("\n")
        );
        return false;
      }
    });
    root2.walkRules((rule2) => {
      if (found)
        return false;
      rule2.walkRules((nestedRule) => {
        found = true;
        nestedRule.warn(
          result,
          [
            "Nested CSS was detected, but CSS nesting has not been configured correctly.",
            "Please enable a CSS nesting plugin *before* Tailwind in your configuration.",
            "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"
          ].join("\n")
        );
        return false;
      });
    });
  };
}
function processTailwindFeatures(setupContext) {
  return function(root2, result) {
    let { tailwindDirectives, applyDirectives } = normalizeTailwindDirectives(root2);
    detectNesting_default()(root2, result);
    expandApplyAtRules2()(root2, result);
    let context = setupContext({
      tailwindDirectives,
      applyDirectives,
      registerDependency(dependency) {
        result.messages.push({
          plugin: "tailwindcss",
          parent: result.opts.from,
          ...dependency
        });
      },
      createContext(tailwindConfig, changedContent) {
        return createContext(tailwindConfig, changedContent, root2);
      }
    })(root2, result);
    if (context.tailwindConfig.separator === "-") {
      throw new Error(
        "The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead."
      );
    }
    issueFlagNotices(context.tailwindConfig);
    expandTailwindAtRules(context)(root2, result);
    expandApplyAtRules2()(root2, result);
    expandApplyAtRules(context)(root2, result);
    evaluateTailwindFunctions_default(context)(root2, result);
    substituteScreenAtRules_default(context)(root2, result);
    resolveDefaultsAtRules(context)(root2, result);
    collapseAdjacentRules(context)(root2, result);
    collapseDuplicateDeclarations(context)(root2, result);
  };
}
var corePluginList_default = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"];
function configurePlugins_default(pluginConfig, plugins) {
  if (pluginConfig === void 0) {
    return plugins;
  }
  const pluginNames = Array.isArray(pluginConfig) ? pluginConfig : [
    ...new Set(
      plugins.filter((pluginName) => {
        return pluginConfig !== false && pluginConfig[pluginName] !== false;
      }).concat(
        Object.keys(pluginConfig).filter((pluginName) => {
          return pluginConfig[pluginName] !== false;
        })
      )
    )
  ];
  return pluginNames;
}
function warn({ version: version2, from, to }) {
  log_default.warn(`${from}-color-renamed`, [
    `As of Tailwind CSS ${version2}, \`${from}\` has been renamed to \`${to}\`.`,
    "Update your configuration file to silence this warning."
  ]);
}
var colors_default = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  },
  get lightBlue() {
    warn({ version: "v2.2", from: "lightBlue", to: "sky" });
    return this.sky;
  },
  get warmGray() {
    warn({ version: "v3.0", from: "warmGray", to: "stone" });
    return this.stone;
  },
  get trueGray() {
    warn({ version: "v3.0", from: "trueGray", to: "neutral" });
    return this.neutral;
  },
  get coolGray() {
    warn({ version: "v3.0", from: "coolGray", to: "gray" });
    return this.gray;
  },
  get blueGray() {
    warn({ version: "v3.0", from: "blueGray", to: "slate" });
    return this.slate;
  }
};
function defaults2(target, ...sources) {
  for (let source of sources) {
    for (let k3 in source) {
      if (!target?.hasOwnProperty?.(k3)) {
        target[k3] = source[k3];
      }
    }
    for (let k3 of Object.getOwnPropertySymbols(source)) {
      if (!target?.hasOwnProperty?.(k3)) {
        target[k3] = source[k3];
      }
    }
  }
  return target;
}
function normalizeConfig(config) {
  let valid = (() => {
    if (config.purge) {
      return false;
    }
    if (!config.content) {
      return false;
    }
    if (!Array.isArray(config.content) && !(typeof config.content === "object" && config.content !== null)) {
      return false;
    }
    if (Array.isArray(config.content)) {
      return config.content.every((path) => {
        if (typeof path === "string")
          return true;
        if (typeof path?.raw !== "string")
          return false;
        if (path?.extension && typeof path?.extension !== "string") {
          return false;
        }
        return true;
      });
    }
    if (typeof config.content === "object" && config.content !== null) {
      if (Object.keys(config.content).some(
        (key) => !["files", "relative", "extract", "transform"].includes(key)
      )) {
        return false;
      }
      if (Array.isArray(config.content.files)) {
        if (!config.content.files.every((path) => {
          if (typeof path === "string")
            return true;
          if (typeof path?.raw !== "string")
            return false;
          if (path?.extension && typeof path?.extension !== "string") {
            return false;
          }
          return true;
        })) {
          return false;
        }
        if (typeof config.content.extract === "object") {
          for (let value2 of Object.values(config.content.extract)) {
            if (typeof value2 !== "function") {
              return false;
            }
          }
        } else if (!(config.content.extract === void 0 || typeof config.content.extract === "function")) {
          return false;
        }
        if (typeof config.content.transform === "object") {
          for (let value2 of Object.values(config.content.transform)) {
            if (typeof value2 !== "function") {
              return false;
            }
          }
        } else if (!(config.content.transform === void 0 || typeof config.content.transform === "function")) {
          return false;
        }
        if (typeof config.content.relative !== "boolean" && typeof config.content.relative !== "undefined") {
          return false;
        }
      }
      return true;
    }
    return false;
  })();
  if (!valid) {
    log_default.warn("purge-deprecation", [
      "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
      "Update your configuration file to eliminate this warning.",
      "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
    ]);
  }
  config.safelist = (() => {
    let { content, purge, safelist } = config;
    if (Array.isArray(safelist))
      return safelist;
    if (Array.isArray(content?.safelist))
      return content.safelist;
    if (Array.isArray(purge?.safelist))
      return purge.safelist;
    if (Array.isArray(purge?.options?.safelist))
      return purge.options.safelist;
    return [];
  })();
  config.blocklist = (() => {
    let { blocklist } = config;
    if (Array.isArray(blocklist)) {
      if (blocklist.every((item) => typeof item === "string")) {
        return blocklist;
      }
      log_default.warn("blocklist-invalid", [
        "The `blocklist` option must be an array of strings.",
        "https://tailwindcss.com/docs/content-configuration#discarding-classes"
      ]);
    }
    return [];
  })();
  if (typeof config.prefix === "function") {
    log_default.warn("prefix-function", [
      "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
      "Update `prefix` in your configuration to be a string to eliminate this warning.",
      "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
    ]);
    config.prefix = "";
  } else {
    config.prefix = config.prefix ?? "";
  }
  config.content = {
    relative: (() => {
      let { content } = config;
      if (content?.relative) {
        return content.relative;
      }
      return flagEnabled(config, "relativeContentPathsByDefault");
    })(),
    files: (() => {
      let { content, purge } = config;
      if (Array.isArray(purge))
        return purge;
      if (Array.isArray(purge?.content))
        return purge.content;
      if (Array.isArray(content))
        return content;
      if (Array.isArray(content?.content))
        return content.content;
      if (Array.isArray(content?.files))
        return content.files;
      return [];
    })(),
    extract: (() => {
      let extract = (() => {
        if (config.purge?.extract)
          return config.purge.extract;
        if (config.content?.extract)
          return config.content.extract;
        if (config.purge?.extract?.DEFAULT)
          return config.purge.extract.DEFAULT;
        if (config.content?.extract?.DEFAULT)
          return config.content.extract.DEFAULT;
        if (config.purge?.options?.extractors)
          return config.purge.options.extractors;
        if (config.content?.options?.extractors)
          return config.content.options.extractors;
        return {};
      })();
      let extractors = {};
      let defaultExtractor2 = (() => {
        if (config.purge?.options?.defaultExtractor) {
          return config.purge.options.defaultExtractor;
        }
        if (config.content?.options?.defaultExtractor) {
          return config.content.options.defaultExtractor;
        }
        return void 0;
      })();
      if (defaultExtractor2 !== void 0) {
        extractors.DEFAULT = defaultExtractor2;
      }
      if (typeof extract === "function") {
        extractors.DEFAULT = extract;
      } else if (Array.isArray(extract)) {
        for (let { extensions, extractor } of extract ?? []) {
          for (let extension of extensions) {
            extractors[extension] = extractor;
          }
        }
      } else if (typeof extract === "object" && extract !== null) {
        Object.assign(extractors, extract);
      }
      return extractors;
    })(),
    transform: (() => {
      let transform = (() => {
        if (config.purge?.transform)
          return config.purge.transform;
        if (config.content?.transform)
          return config.content.transform;
        if (config.purge?.transform?.DEFAULT)
          return config.purge.transform.DEFAULT;
        if (config.content?.transform?.DEFAULT)
          return config.content.transform.DEFAULT;
        return {};
      })();
      let transformers = {};
      if (typeof transform === "function") {
        transformers.DEFAULT = transform;
      }
      if (typeof transform === "object" && transform !== null) {
        Object.assign(transformers, transform);
      }
      return transformers;
    })()
  };
  for (let file of config.content.files) {
    if (typeof file === "string" && /{([^,]*?)}/g.test(file)) {
      log_default.warn("invalid-glob-braces", [
        `The glob pattern ${dim(file)} in your Tailwind CSS configuration is invalid.`,
        `Update it to ${dim(file.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
      ]);
      break;
    }
  }
  if (config.plugins.length > 0) {
    let plugin2;
    try {
      plugin2 = __require2("@tailwindcss/line-clamp");
    } catch {
    }
    if (plugin2 && config.plugins.includes(plugin2)) {
      log_default.warn("line-clamp-in-core", [
        "As of Tailwind CSS v3.3, the `@tailwindcss/line-clamp` plugin is now included by default.",
        "Remove it from the `plugins` array in your configuration to eliminate this warning."
      ]);
      config.plugins = config.plugins.filter((p3) => p3 !== plugin2);
    }
  }
  return config;
}
function cloneDeep(value2) {
  if (Array.isArray(value2)) {
    return value2.map((child) => cloneDeep(child));
  }
  if (typeof value2 === "object" && value2 !== null) {
    return Object.fromEntries(Object.entries(value2).map(([k3, v2]) => [k3, cloneDeep(v2)]));
  }
  return value2;
}
function isFunction(input) {
  return typeof input === "function";
}
function mergeWith(target, ...sources) {
  let customizer = sources.pop();
  for (let source of sources) {
    for (let k3 in source) {
      let merged = customizer(target[k3], source[k3]);
      if (merged === void 0) {
        if (isPlainObject(target[k3]) && isPlainObject(source[k3])) {
          target[k3] = mergeWith({}, target[k3], source[k3], customizer);
        } else {
          target[k3] = source[k3];
        }
      } else {
        target[k3] = merged;
      }
    }
  }
  return target;
}
var configUtils = {
  colors: colors_default,
  negative(scale) {
    return Object.keys(scale).filter((key) => scale[key] !== "0").reduce((negativeScale, key) => {
      let negativeValue = negateValue(scale[key]);
      if (negativeValue !== void 0) {
        negativeScale[`-${key}`] = negativeValue;
      }
      return negativeScale;
    }, {});
  },
  breakpoints(screens) {
    return Object.keys(screens).filter((key) => typeof screens[key] === "string").reduce(
      (breakpoints, key) => ({
        ...breakpoints,
        [`screen-${key}`]: screens[key]
      }),
      {}
    );
  }
};
function value(valueToResolve, ...args) {
  return isFunction(valueToResolve) ? valueToResolve(...args) : valueToResolve;
}
function collectExtends(items) {
  return items.reduce((merged, { extend }) => {
    return mergeWith(merged, extend, (mergedValue, extendValue) => {
      if (mergedValue === void 0) {
        return [extendValue];
      }
      if (Array.isArray(mergedValue)) {
        return [extendValue, ...mergedValue];
      }
      return [extendValue, mergedValue];
    });
  }, {});
}
function mergeThemes(themes) {
  return {
    ...themes.reduce((merged, theme) => defaults2(merged, theme), {}),
    extend: collectExtends(themes)
  };
}
function mergeExtensionCustomizer(merged, value2) {
  if (Array.isArray(merged) && isPlainObject(merged[0])) {
    return merged.concat(value2);
  }
  if (Array.isArray(value2) && isPlainObject(value2[0]) && isPlainObject(merged)) {
    return [merged, ...value2];
  }
  if (Array.isArray(value2)) {
    return value2;
  }
  return void 0;
}
function mergeExtensions({ extend, ...theme }) {
  return mergeWith(theme, extend, (themeValue, extensions) => {
    if (!isFunction(themeValue) && !extensions.some(isFunction)) {
      return mergeWith({}, themeValue, ...extensions, mergeExtensionCustomizer);
    }
    return (resolveThemePath, utils) => mergeWith(
      {},
      ...[themeValue, ...extensions].map((e4) => value(e4, resolveThemePath, utils)),
      mergeExtensionCustomizer
    );
  });
}
function* toPaths2(key) {
  let path = toPath(key);
  if (path.length === 0) {
    return;
  }
  yield path;
  if (Array.isArray(key)) {
    return;
  }
  let pattern2 = /^(.*?)\s*\/\s*([^/]+)$/;
  let matches2 = key.match(pattern2);
  if (matches2 !== null) {
    let [, prefix3, alpha] = matches2;
    let newPath = toPath(prefix3);
    newPath.alpha = alpha;
    yield newPath;
  }
}
function resolveFunctionKeys(object) {
  const resolvePath2 = (key, defaultValue) => {
    for (const path of toPaths2(key)) {
      let index2 = 0;
      let val = object;
      while (val !== void 0 && val !== null && index2 < path.length) {
        val = val[path[index2++]];
        let shouldResolveAsFn = isFunction(val) && (path.alpha === void 0 || index2 <= path.length - 1);
        val = shouldResolveAsFn ? val(resolvePath2, configUtils) : val;
      }
      if (val !== void 0) {
        if (path.alpha !== void 0) {
          let normalized = parseColorFormat(val);
          return withAlphaValue(normalized, path.alpha, toColorValue(normalized));
        }
        if (isPlainObject(val)) {
          return cloneDeep(val);
        }
        return val;
      }
    }
    return defaultValue;
  };
  Object.assign(resolvePath2, {
    theme: resolvePath2,
    ...configUtils
  });
  return Object.keys(object).reduce((resolved, key) => {
    resolved[key] = isFunction(object[key]) ? object[key](resolvePath2, configUtils) : object[key];
    return resolved;
  }, {});
}
function extractPluginConfigs(configs) {
  let allConfigs = [];
  configs.forEach((config) => {
    allConfigs = [...allConfigs, config];
    const plugins = config?.plugins ?? [];
    if (plugins.length === 0) {
      return;
    }
    plugins.forEach((plugin2) => {
      if (plugin2.__isOptionsFunction) {
        plugin2 = plugin2();
      }
      allConfigs = [...allConfigs, ...extractPluginConfigs([plugin2?.config ?? {}])];
    });
  });
  return allConfigs;
}
function resolveCorePlugins(corePluginConfigs) {
  const result = [...corePluginConfigs].reduceRight((resolved, corePluginConfig) => {
    if (isFunction(corePluginConfig)) {
      return corePluginConfig({ corePlugins: resolved });
    }
    return configurePlugins_default(corePluginConfig, resolved);
  }, corePluginList_default);
  return result;
}
function resolvePluginLists(pluginLists) {
  const result = [...pluginLists].reduceRight((resolved, pluginList) => {
    return [...resolved, ...pluginList];
  }, []);
  return result;
}
function resolveConfig(configs) {
  let allConfigs = [
    ...extractPluginConfigs(configs),
    {
      prefix: "",
      important: false,
      separator: ":"
    }
  ];
  return normalizeConfig(
    defaults2(
      {
        theme: resolveFunctionKeys(
          mergeExtensions(mergeThemes(allConfigs.map((t5) => t5?.theme ?? {})))
        ),
        corePlugins: resolveCorePlugins(allConfigs.map((c2) => c2.corePlugins)),
        plugins: resolvePluginLists(configs.map((c2) => c2?.plugins ?? []))
      },
      ...allConfigs
    )
  );
}
var import_config_full = __toESM2(require_config_full());
function getAllConfigs(config) {
  const configs = (config?.presets ?? [import_config_full.default]).slice().reverse().flatMap((preset) => getAllConfigs(preset instanceof Function ? preset() : preset));
  const features = {
    respectDefaultRingColorOpacity: {
      theme: {
        ringColor: ({ theme }) => ({
          DEFAULT: "#3b82f67f",
          ...theme("colors")
        })
      }
    },
    disableColorOpacityUtilitiesByDefault: {
      corePlugins: {
        backgroundOpacity: false,
        borderOpacity: false,
        divideOpacity: false,
        placeholderOpacity: false,
        ringOpacity: false,
        textOpacity: false
      }
    }
  };
  const experimentals = Object.keys(features).filter((feature) => flagEnabled(config, feature)).map((feature) => features[feature]);
  return [config, ...experimentals, ...configs];
}
function resolveConfig2(...configs) {
  let [, ...defaultConfigs] = getAllConfigs(configs[0]);
  return resolveConfig([...configs, ...defaultConfigs]);
}
var createTailwindcssPlugin = ({ tailwindConfig, content: contentCollection }) => {
  const config = resolveConfig2(tailwindConfig ?? {});
  const tailwindcssPlugin = processTailwindFeatures(
    (processOptions) => () => processOptions.createContext(
      config,
      contentCollection.map((content) => typeof content === "string" ? { content } : content)
    )
  );
  return tailwindcssPlugin;
};

// src/tailwind/tailwind.tsx
var Tailwind = ({
  children,
  config
}) => {
  const markup = quickSafeRenderToString(children);
  const corePlugins2 = config?.corePlugins;
  const tailwindConfig = {
    ...config,
    corePlugins: {
      ...corePlugins2,
      preflight: false
    }
  };
  const { css } = postcss_default([
    createTailwindcssPlugin({
      tailwindConfig,
      content: [{ content: markup, extension: "html" }]
    }),
    // postcssCssVariables,
    postcssPlugin
  ]).process(
    String.raw`
        @tailwind base;
        @tailwind components;
        @tailwind utilities;

        ${preflight_default}
      `,
    {
      from: void 0
    }
  );
  return /* @__PURE__ */ React9.createElement(React9.Fragment, null, /* @__PURE__ */ React9.createElement(CSS, null, css), children);
};
export {
  CSS,
  CurrentPageTop,
  FloatBottom,
  Footnote,
  Latex,
  Markdown,
  NoBreak,
  PageBottom,
  PageBreak,
  PageNumber,
  PageTop,
  PagesNumber,
  RunningH1,
  RunningH2,
  RunningH3,
  RunningH4,
  RunningH5,
  RunningH6,
  Tailwind,
  compile
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)

cssesc/cssesc.js:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)

@csstools/color-helpers/dist/index.mjs:
  (**
   * Simple matrix (and vector) multiplication
   * Warning: No error handling for incompatible dimensions!
   * @author Lea Verou 2020 MIT License
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/multiply-matrices.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/multiply-matrices.js
   *)
  (**
   * Bradford chromatic adaptation from D65 to D50
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html
   *)
  (**
   * @param {number} hue - Hue as degrees 0..360
   * @param {number} sat - Saturation as percentage 0..100
   * @param {number} light - Lightness as percentage 0..100
   * @return {number[]} Array of RGB components 0..1
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hslToRgb.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hslToRgb.js
   *)
  (**
   * @param {number} hue -  Hue as degrees 0..360
   * @param {number} white -  Whiteness as percentage 0..100
   * @param {number} black -  Blackness as percentage 0..100
   * @return {number[]} Array of RGB components 0..1
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hwbToRgb.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/hwbToRgb.js
   *)
  (**
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *)
  (**
   * Convert Lab to D50-adapted XYZ
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
   *)
  (**
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js
   *)
  (**
   * Given OKLab, convert to XYZ relative to D65
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js
   *)
  (**
   * Convert an array of rec2020 RGB values in the range 0.0 - 1.0
   * to linear light (un-companded) form.
   * ITU-R BT.2020-2 p.4
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *)
  (**
   * Convert an array of linear-light rec2020 values to CIE XYZ
   * using  D65 (no chromatic adaptation)
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
   *)
  (**
   * Convert an array of of sRGB values where in-gamut values are in the range
   * [0 - 1] to linear light (un-companded) form.
   * Extended transfer function:
   *  For negative values, linear portion is extended on reflection of axis,
   *  then reflected power function is used.
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see https://en.wikipedia.org/wiki/SRGB
   *)
  (**
   * Convert an array of display-p3 RGB values in the range 0.0 - 1.0
   * to linear light (un-companded) form.
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *)
  (**
   * Convert an array of linear-light display-p3 values to CIE XYZ
   * using D65 (no chromatic adaptation)
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
   *)
  (**
   * Convert an array of prophoto-rgb values where in-gamut Colors are in the
   * range [0.0 - 1.0] to linear light (un-companded) form. Transfer curve is
   * gamma 1.8 with a small linear portion. Extended transfer function
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *)
  (**
   * Convert an array of linear-light sRGB values to CIE XYZ
   * using sRGB's own white, D65 (no chromatic adaptation)
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *)
  (**
   * Bradford chromatic adaptation from D50 to D65
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *)
  (**
   * Convert an array of linear-light sRGB values in the range 0.0-1.0 to gamma corrected form
   * Extended transfer function:
   *  For negative values, linear portion extends on reflection
   *  of axis, then uses reflected pow below that
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see https://en.wikipedia.org/wiki/SRGB
   *)
  (**
   * Convert an array of gamma-corrected sRGB values in the 0.0 to 1.0 range to HSL.
   *
   * @param {Color} RGB [r, g, b]
   * - Red component 0..1
   * - Green component 0..1
   * - Blue component 0..1
   * @return {number[]} Array of HSL values: Hue as degrees 0..360, Saturation and Lightness as percentages 0..100
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/utilities.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *
   * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/rgbToHsl.js
   *)
  (**
   * Convert XYZ to linear-light P3
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *)
  (**
   * Convert an array of linear-light display-p3 RGB in the range 0.0-1.0
   * to gamma corrected form
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *)
  (**
   * Assuming XYZ is relative to D50, convert to CIE Lab
   * from CIE standard, which now defines these as a rational fraction
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *)
  (**
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *
   * XYZ <-> LMS matrices recalculated for consistent reference white
   * @see https://github.com/w3c/csswg-drafts/issues/6642#issuecomment-943521484
   *)
  (**
   * Convert XYZ to linear-light a98-rgb
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *)
  (**
   * Convert an array of linear-light rec2020 RGB  in the range 0.0-1.0
   * to gamma corrected form ITU-R BT.2020-2 p.4
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   *)
  (**
   * Convert XYZ to linear-light prophoto-rgb
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/conversions.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
   *)
  (**
   * @description Calculate deltaE OK which is the simple root sum of squares
   * @param {number[]} reference - Array of OKLab values: L as 0..1, a and b as -1..1
   * @param {number[]} sample - Array of OKLab values: L as 0..1, a and b as -1..1
   * @return {number} How different a color sample is from reference
   *
   * @license W3C https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
   * @copyright This software or document includes material copied from or derived from https://github.com/w3c/csswg-drafts/blob/main/css-color-4/deltaEOK.js. Copyright  2022 W3C (MIT, ERCIM, Keio, Beihang).
   * @see https://github.com/w3c/csswg-drafts/blob/main/css-color-4/deltaEOK.js
   *)
*/
//# sourceMappingURL=index.mjs.map